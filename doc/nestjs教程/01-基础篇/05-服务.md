# 服务

在 NestJS 中，服务（Service）是处理业务逻辑的核心组件，负责与数据库交互、调用其他服务或执行复杂的业务计算。服务使用依赖注入（Dependency Injection）机制，可以被注入到控制器或其他服务中，实现松耦合的设计。

## 1. 服务的基本概念

服务是 NestJS 应用中的业务逻辑层，它封装了具体的业务逻辑，与控制器分离，使得代码更加模块化、可测试和可维护。服务使用 `@Injectable` 装饰器来标记，以便被 NestJS 的依赖注入容器管理。

## 2. 创建服务

### 2.1 使用 Nest CLI 创建服务

使用 Nest CLI 可以快速创建一个服务：

```bash
# 创建一个名为 "users" 的服务
nest generate service users

# 或者使用简写
nest g s users
```

运行该命令后，Nest CLI 会在 `src/users` 目录下生成以下文件：

- `users.service.ts` - 服务文件
- `users.service.spec.ts` - 服务测试文件

### 2.2 手动创建服务

你也可以手动创建服务文件。创建一个新的文件 `src/users/users.service.ts`，并添加以下内容：

```typescript
import { Injectable } from '@nestjs/common';

@Injectable() // 标记该类为可注入的服务
export class UsersService {
  private readonly users = [
    { id: 1, name: '张三', email: 'zhangsan@example.com' },
    { id: 2, name: '李四', email: 'lisi@example.com' },
    { id: 3, name: '王五', email: 'wangwu@example.com' },
  ];

  // 获取所有用户
  findAll() {
    return this.users;
  }

  // 根据 ID 获取用户
  findOne(id: number) {
    return this.users.find(user => user.id === id);
  }

  // 创建用户
  create(user: any) {
    const newUser = {
      id: this.users.length + 1,
      ...user,
    };
    this.users.push(newUser);
    return newUser;
  }

  // 更新用户
  update(id: number, user: any) {
    const index = this.users.findIndex(u => u.id === id);
    if (index >= 0) {
      this.users[index] = { ...this.users[index], ...user };
      return this.users[index];
    }
    return null;
  }

  // 删除用户
  remove(id: number) {
    const index = this.users.findIndex(u => u.id === id);
    if (index >= 0) {
      return this.users.splice(index, 1)[0];
    }
    return null;
  }
}
```

## 3. 注册服务

创建服务后，需要将其注册到模块中。打开 `src/users/users.module.ts` 文件，并将服务添加到 `providers` 数组中：

```typescript
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  controllers: [UsersController],
  providers: [UsersService], // 注册服务
})
export class UsersModule {}
```

## 4. 在控制器中使用服务

服务注册后，可以通过构造函数注入的方式在控制器中使用：

```typescript
import { Controller, Get, Post, Put, Delete, Param, Body } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('users')
export class UsersController {
  // 通过构造函数注入 UsersService
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id); // 将字符串转换为数字
  }

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Put(':id')
  update(@Param('id') id: string, @Body() updateUserDto: any) {
    return this.usersService.update(+id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id);
  }
}
```

## 5. 服务的依赖注入

服务可以依赖于其他服务，实现复杂的业务逻辑。NestJS 的依赖注入容器会自动处理服务之间的依赖关系。

### 5.1 创建依赖服务

创建一个新的服务 `src/users/user-profile.service.ts`，用于处理用户资料相关的业务逻辑：

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class UserProfileService {
  // 获取用户资料
  getProfile(userId: number) {
    return {
      userId,
      bio: '这是用户的个人简介',
      avatar: 'https://example.com/avatar.jpg',
      createdAt: new Date(),
    };
  }

  // 更新用户资料
  updateProfile(userId: number, profile: any) {
    return {
      userId,
      ...profile,
      updatedAt: new Date(),
    };
  }
}
```

### 5.2 注册依赖服务

将 `UserProfileService` 注册到 `UsersModule` 中：

```typescript
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { UserProfileService } from './user-profile.service';

@Module({
  controllers: [UsersController],
  providers: [UsersService, UserProfileService], // 注册多个服务
})
export class UsersModule {}
```

### 5.3 在服务中注入依赖服务

在 `UsersService` 中注入 `UserProfileService`：

```typescript
import { Injectable } from '@nestjs/common';
import { UserProfileService } from './user-profile.service';

@Injectable()
export class UsersService {
  private readonly users = [
    { id: 1, name: '张三', email: 'zhangsan@example.com' },
    { id: 2, name: '李四', email: 'lisi@example.com' },
    { id: 3, name: '王五', email: 'wangwu@example.com' },
  ];

  // 注入 UserProfileService
  constructor(private readonly userProfileService: UserProfileService) {}

  findAll() {
    return this.users;
  }

  findOne(id: number) {
    const user = this.users.find(user => user.id === id);
    if (user) {
      // 调用依赖服务的方法
      const profile = this.userProfileService.getProfile(id);
      return { ...user, profile };
    }
    return null;
  }

  // 其他方法...
}
```

## 6. 服务的作用域

NestJS 中的服务默认是单例（Singleton）作用域，也就是说，整个应用中只有一个服务实例。NestJS 还支持其他作用域：

| 作用域 | 描述 |
|--------|------|
| `DEFAULT` | 单例作用域，整个应用中只有一个实例 |
| `TRANSIENT` | 临时作用域，每次注入时创建一个新实例 |
| `REQUEST` | 请求作用域，每个 HTTP 请求创建一个新实例 |

### 6.1 设置服务作用域

使用 `@Injectable` 装饰器的 `scope` 参数来设置服务的作用域：

```typescript
import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT }) // 设置为临时作用域
export class UsersService {
  // 服务的实现
}
```

或者使用枚举值：

```typescript
import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST }) // 设置为请求作用域
export class UsersService {
  // 服务的实现
}
```

## 7. 异步服务

服务方法可以是异步的，使用 `async/await` 语法来处理异步操作，如数据库查询、HTTP 请求等。

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  private readonly users = [
    { id: 1, name: '张三', email: 'zhangsan@example.com' },
    { id: 2, name: '李四', email: 'lisi@example.com' },
    { id: 3, name: '王五', email: 'wangwu@example.com' },
  ];

  // 异步方法
  async findAll() {
    // 模拟异步操作
    return await this.getUsersFromDatabase();
  }

  async findOne(id: number) {
    const users = await this.getUsersFromDatabase();
    return users.find(user => user.id === id);
  }

  // 模拟数据库查询
  private async getUsersFromDatabase() {
    return new Promise<any[]>((resolve) => {
      setTimeout(() => {
        resolve(this.users);
      }, 500);
    });
  }
}
```

## 8. 服务的测试

服务的设计使得它们易于测试，因为它们是独立的组件，不依赖于控制器或其他外部组件。

### 8.1 单元测试

使用 Jest 进行单元测试，测试服务的各个方法：

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { UsersService } from './users.service';
import { UserProfileService } from './user-profile.service';

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UsersService, UserProfileService],
    }).compile();

    service = module.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should return all users', async () => {
    const result = await service.findAll();
    expect(result).toHaveLength(3);
  });

  it('should return a user by id', async () => {
    const result = await service.findOne(1);
    expect(result).toEqual(expect.objectContaining({
      id: 1,
      name: '张三',
    }));
  });

  it('should create a new user', async () => {
    const newUser = { name: '赵六', email: 'zhaoliu@example.com' };
    const result = await service.create(newUser);
    expect(result).toEqual(expect.objectContaining(newUser));
    expect(result.id).toBe(4);
  });
});
```

## 9. 服务的最佳实践

### 9.1 单一职责原则

每个服务应该只负责一个特定的业务领域，遵循单一职责原则。例如，`UsersService` 只负责用户相关的业务逻辑，`UserProfileService` 只负责用户资料相关的业务逻辑。

### 9.2 依赖注入

使用依赖注入机制，避免硬编码依赖，使得服务更加灵活和可测试。

### 9.3 异步编程

对于 I/O 密集型操作，如数据库查询、HTTP 请求等，使用异步编程，提高应用的性能和响应速度。

### 9.4 错误处理

在服务中实现适当的错误处理，抛出有意义的异常，便于控制器捕获和处理。

### 9.5 日志记录

在服务中添加适当的日志记录，便于调试和监控应用的运行状态。

### 9.6 接口定义

使用接口或抽象类来定义服务的契约，提高代码的可扩展性和可测试性。

```typescript
// 定义服务接口
export interface IUsersService {
  findAll(): Promise<any[]>;
  findOne(id: number): Promise<any>;
  create(user: any): Promise<any>;
  update(id: number, user: any): Promise<any>;
  remove(id: number): Promise<any>;
}

// 实现服务接口
@Injectable()
export class UsersService implements IUsersService {
  // 服务的实现
}
```

## 10. 总结

在本章中，我们学习了 NestJS 服务的基本概念和使用方法，包括：

- 如何创建和注册服务
- 如何在控制器中使用服务
- 如何实现服务之间的依赖注入
- 如何设置服务的作用域
- 如何编写异步服务
- 如何测试服务
- 服务的最佳实践

服务是 NestJS 应用中的核心组件之一，掌握服务的使用方法对于构建高效、可扩展的 NestJS 应用至关重要。在下一章中，我们将学习 NestJS 模块的使用方法。
