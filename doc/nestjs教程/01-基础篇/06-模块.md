# 模块

在 NestJS 中，模块（Module）是组织代码的基本单位，用于将应用程序分解为多个功能模块。每个模块包含控制器、服务、管道、过滤器等组件，并可以导入其他模块或导出自己的组件。

## 1. 模块的基本概念

模块是 NestJS 应用程序的构建块，它封装了一组相关的功能，如用户管理、订单管理等。每个应用程序至少有一个根模块（Root Module），即 `AppModule`，它是应用程序的入口点。

模块使用 `@Module` 装饰器来定义，该装饰器接受一个配置对象，包含以下属性：

| 属性 | 描述 |
|------|------|
| `imports` | 导入其他模块，以便使用它们的组件 |
| `controllers` | 声明该模块中的控制器 |
| `providers` | 声明该模块中的服务、工厂、拦截器等 |
| `exports` | 导出该模块中的组件，以便其他模块使用 |
| `exports` | 导出该模块中的组件，以便其他模块使用 |
| `global` | 标记该模块为全局模块，其组件可以在所有模块中使用，无需导入 |

## 2. 创建模块

### 2.1 使用 Nest CLI 创建模块

使用 Nest CLI 可以快速创建一个模块：

```bash
# 创建一个名为 "users" 的模块
nest generate module users

# 或者使用简写
nest g mo users
```

运行该命令后，Nest CLI 会在 `src/users` 目录下生成 `users.module.ts` 文件。

### 2.2 手动创建模块

你也可以手动创建模块文件。创建一个新的文件 `src/users/users.module.ts`，并添加以下内容：

```typescript
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [],           // 导入其他模块
  controllers: [UsersController], // 声明控制器
  providers: [UsersService],      // 声明服务
  exports: [UsersService],        // 导出服务
})
export class UsersModule {}
```

## 3. 根模块

每个 NestJS 应用程序都有一个根模块，即 `AppModule`，它是应用程序的入口点。根模块负责导入其他模块，并将它们组织在一起。

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';

@Module({
  imports: [UsersModule], // 导入 UsersModule
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## 4. 功能模块

功能模块是用于组织特定功能的模块，如用户管理、订单管理等。功能模块可以导入其他功能模块，并导出自己的组件。

### 4.1 创建功能模块

创建一个新的功能模块 `OrdersModule`：

```typescript
import { Module } from '@nestjs/common';
import { OrdersController } from './orders.controller';
import { OrdersService } from './orders.service';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule], // 导入 UsersModule，以便使用 UsersService
  controllers: [OrdersController],
  providers: [OrdersService],
})
export class OrdersModule {}
```

### 4.2 在根模块中导入功能模块

将 `OrdersModule` 导入到根模块 `AppModule` 中：

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';
import { OrdersModule } from './orders/orders.module';

@Module({
  imports: [UsersModule, OrdersModule], // 导入多个模块
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## 5. 共享模块

共享模块是指可以被多个其他模块导入和使用的模块。在 NestJS 中，每个模块默认是单例，因此可以轻松地在多个模块之间共享服务。

### 5.1 导出服务

要使模块成为共享模块，需要将其服务导出：

```typescript
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService], // 导出 UsersService
})
export class UsersModule {}
```

### 5.2 导入共享模块

其他模块可以导入共享模块，并使用其导出的服务：

```typescript
import { Module } from '@nestjs/common';
import { OrdersController } from './orders.controller';
import { OrdersService } from './orders.service';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule], // 导入 UsersModule
  controllers: [OrdersController],
  providers: [OrdersService],
})
export class OrdersModule {}
```

### 5.3 在服务中使用共享服务

在 `OrdersService` 中注入 `UsersService`：

```typescript
import { Injectable } from '@nestjs/common';
import { UsersService } from '../users/users.service';

@Injectable()
export class OrdersService {
  constructor(private readonly usersService: UsersService) {} // 注入 UsersService

  // 使用 UsersService
  async getOrderWithUser(orderId: number) {
    const order = await this.findOrderById(orderId);
    if (order) {
      const user = await this.usersService.findOne(order.userId);
      return { ...order, user };
    }
    return null;
  }

  private async findOrderById(id: number) {
    // 模拟数据库查询
    return {
      id,
      userId: 1,
      product: 'Product A',
      amount: 100,
    };
  }
}
```

## 6. 全局模块

全局模块是指其组件可以在所有模块中使用，无需导入的模块。使用 `@Global` 装饰器来标记全局模块：

```typescript
import { Module, Global } from '@nestjs/common';
import { ConfigService } from './config.service';

@Global() // 标记为全局模块
@Module({
  providers: [ConfigService],
  exports: [ConfigService], // 导出服务
})
export class ConfigModule {}
```

全局模块只需在根模块中导入一次，其导出的组件就可以在所有模块中使用：

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ConfigModule } from './config/config.module';

@Module({
  imports: [ConfigModule], // 只需要导入一次
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

然后，在其他模块中，可以直接注入全局模块导出的服务，无需导入该模块：

```typescript
import { Injectable } from '@nestjs/common';
import { ConfigService } from '../config/config.service';

@Injectable()
export class UsersService {
  constructor(private readonly configService: ConfigService) {} // 直接注入，无需导入 ConfigModule

  getConfig() {
    return this.configService.get('APP_NAME');
  }
}
```

## 7. 动态模块

动态模块是指可以根据配置动态创建的模块。动态模块允许你在导入模块时传递配置参数，从而创建定制化的模块实例。

### 7.1 创建动态模块

使用 `forRoot()` 或 `forFeature()` 静态方法来创建动态模块：

```typescript
import { Module, DynamicModule } from '@nestjs/common';
import { ConfigService } from './config.service';

@Module({})
export class ConfigModule {
  // 静态方法，用于创建动态模块
  static forRoot(options: any): DynamicModule {
    return {
      module: ConfigModule,
      providers: [
        {
          provide: 'CONFIG_OPTIONS', // 提供配置选项
          useValue: options,
        },
        ConfigService, // 服务
      ],
      exports: [ConfigService], // 导出服务
      global: true, // 可选，标记为全局模块
    };
  }
}
```

### 7.2 配置服务

在服务中注入配置选项：

```typescript
import { Injectable, Inject } from '@nestjs/common';

@Injectable()
export class ConfigService {
  private readonly config: any;

  constructor(@Inject('CONFIG_OPTIONS') options: any) {
    this.config = options;
  }

  get(key: string) {
    return this.config[key];
  }
}
```

### 7.3 使用动态模块

在根模块中导入动态模块，并传递配置参数：

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ConfigModule } from './config/config.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      APP_NAME: 'My Nest App',
      APP_VERSION: '1.0.0',
      APP_ENV: 'development',
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## 8. 模块的最佳实践

### 8.1 模块化设计

将应用程序分解为多个功能模块，每个模块负责特定的业务领域，遵循单一职责原则。

### 8.2 共享服务

将需要在多个模块中使用的服务放在共享模块中，并导出它们，以便其他模块使用。

### 8.3 全局模块

谨慎使用全局模块，只对真正需要在所有模块中使用的组件使用全局模块。

### 8.4 动态模块

对于需要根据配置动态创建的模块，使用动态模块，以便灵活配置。

### 8.5 模块依赖关系

避免模块之间的循环依赖，确保模块的依赖关系清晰。

### 8.6 模块命名

使用清晰、描述性的名称来命名模块，以便于理解其功能。

## 9. 总结

在本章中，我们学习了 NestJS 模块的基本概念和使用方法，包括：

- 如何创建和注册模块
- 根模块和功能模块的使用
- 共享模块和全局模块的使用
- 动态模块的创建和使用
- 模块的最佳实践

模块是 NestJS 应用程序的核心组织单位，掌握模块的使用方法对于构建高效、可扩展的 NestJS 应用至关重要。在下一章中，我们将学习 NestJS 中间件的使用方法。
