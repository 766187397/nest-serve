# 中间件

在 NestJS 中，中间件（Middleware）是在请求处理管道中执行的函数，用于处理请求和响应。中间件可以访问请求对象（Request）、响应对象（Response）和下一个中间件函数（Next Function）。

## 1. 中间件的基本概念

中间件是 NestJS 应用程序中的重要组成部分，它可以用于：

- 日志记录
- 身份验证
- 请求验证
- 数据转换
- 错误处理
- 速率限制

中间件遵循洋葱模型（Onion Model），即请求先经过外层中间件，然后经过内层中间件，最后到达控制器，响应则相反，从控制器返回，经过内层中间件，最后经过外层中间件返回给客户端。

## 2. 创建中间件

### 2.1 函数式中间件

函数式中间件是一个简单的函数，接收请求、响应和下一个中间件函数作为参数：

```typescript
// src/common/middleware/logger.middleware.ts
export function loggerMiddleware(req: any, res: any, next: any) {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  next(); // 调用下一个中间件
}
```

### 2.2 类中间件

类中间件是一个实现了 `NestMiddleware` 接口的类，使用 `@Injectable` 装饰器标记：

```typescript
// src/common/middleware/logger.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  // 实现 use 方法
  use(req: Request, res: Response, next: NextFunction) {
    console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
    next(); // 调用下一个中间件
  }
}
```

## 3. 注册中间件

中间件需要在模块的 `configure` 方法中注册。要注册中间件，模块需要实现 `NestModule` 接口：

### 3.1 在模块中注册中间件

```typescript
// src/users/users.module.ts
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { LoggerMiddleware } from '../common/middleware/logger.middleware';

@Module({
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule implements NestModule {
  // 实现 configure 方法
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware) // 应用中间件
      .forRoutes('users'); // 为 users 路由应用中间件
  }
}
```

### 3.2 为多个路由应用中间件

```typescript
configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware)
    .forRoutes('users', 'orders', 'products'); // 为多个路由应用中间件
}
```

### 3.3 为控制器应用中间件

```typescript
configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware)
    .forRoutes(UsersController); // 为整个 UsersController 应用中间件
}
```

### 3.4 为特定路由方法应用中间件

```typescript
import { Module, NestModule, MiddlewareConsumer, RequestMethod } from '@nestjs/common';

// ...

configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware)
    .forRoutes({
      path: 'users',
      method: RequestMethod.GET, // 只为 GET 请求应用中间件
    });
}
```

### 3.5 为路由路径模式应用中间件

```typescript
configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware)
    .forRoutes('users/*'); // 为所有以 users/ 开头的路由应用中间件
}
```

### 3.6 应用多个中间件

```typescript
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from '../common/middleware/logger.middleware';
import { AuthMiddleware } from '../common/middleware/auth.middleware';

// ...

configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware, AuthMiddleware) // 应用多个中间件
    .forRoutes('users');
}
```

## 4. 全局中间件

全局中间件是指应用于所有路由的中间件。在 NestJS 中，可以使用 `use()` 方法来注册全局中间件：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { loggerMiddleware } from './common/middleware/logger.middleware';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 注册全局中间件
  app.use(loggerMiddleware);
  
  await app.listen(3000);
}

bootstrap();
```

注意：全局中间件只能使用函数式中间件，不能使用类中间件。如果要使用类中间件作为全局中间件，可以将其转换为函数式中间件，或者使用拦截器。

## 5. 中间件的执行顺序

中间件的执行顺序遵循以下规则：

1. 全局中间件首先执行
2. 然后执行模块级中间件，按照注册顺序执行
3. 最后执行路由级中间件，按照注册顺序执行

例如：

```typescript
// src/main.ts
app.use(globalMiddleware1);
app.use(globalMiddleware2);

// src/users/users.module.ts
configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(moduleMiddleware1, moduleMiddleware2)
    .forRoutes('users');
}
```

执行顺序：`globalMiddleware1` → `globalMiddleware2` → `moduleMiddleware1` → `moduleMiddleware2` → 控制器

## 6. 中间件的依赖注入

类中间件可以使用依赖注入，就像控制器和服务一样。中间件可以注入服务、配置等：

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { ConfigService } from '../config/config.service';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  // 注入服务
  constructor(private readonly configService: ConfigService) {}

  use(req: Request, res: Response, next: NextFunction) {
    const appName = this.configService.get('APP_NAME');
    console.log(`[${appName}] [${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
    next();
  }
}
```

## 7. 异步中间件

中间件可以是异步的，使用 `async/await` 语法：

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class AsyncLoggerMiddleware implements NestMiddleware {
  async use(req: Request, res: Response, next: NextFunction) {
    // 模拟异步操作
    await this.logRequest(req);
    next();
  }

  private async logRequest(req: Request) {
    return new Promise<void>((resolve) => {
      setTimeout(() => {
        console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
        resolve();
      }, 100);
    });
  }
}
```

## 8. 中间件的最佳实践

### 8.1 单一职责原则

每个中间件应该只负责一个特定的功能，遵循单一职责原则。例如，`LoggerMiddleware` 只负责日志记录，`AuthMiddleware` 只负责身份验证。

### 8.2 错误处理

中间件应该处理自己的错误，并将错误传递给下一个中间件或全局错误过滤器：

```typescript
@Injectable()
export class ErrorHandlingMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    try {
      // 中间件逻辑
      next();
    } catch (error) {
      // 处理错误
      next(error);
    }
  }
}
```

### 8.3 避免阻塞操作

中间件应该避免执行阻塞操作，如长时间的同步计算或 I/O 操作，以免影响应用程序的性能。

### 8.4 使用依赖注入

使用依赖注入来获取服务和配置，而不是硬编码依赖。

### 8.5 测试中间件

中间件应该易于测试，可以使用 Jest 和 Supertest 来测试中间件：

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';
import { LoggerMiddleware } from './../src/common/middleware/logger.middleware';

describe('LoggerMiddleware', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.use(new LoggerMiddleware().use);
    await app.init();
  });

  it('should log request', () => {
    return request(app.getHttpServer())
      .get('/users')
      .expect(200);
    // 验证日志是否被记录
  });

  afterEach(async () => {
    await app.close();
  });
});
```

## 9. 内置中间件

NestJS 基于 Express 或 Fastify 构建，因此可以使用这些框架的内置中间件，如：

### 9.1 Express 内置中间件

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as express from 'express';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 使用 Express 内置中间件
  app.use(express.json()); // 解析 JSON 请求体
  app.use(express.urlencoded({ extended: true })); // 解析 URL 编码请求体
  app.use(express.static('public')); // 提供静态文件
  
  await app.listen(3000);
}

bootstrap();
```

### 9.2 第三方中间件

可以使用任何 Express 或 Fastify 兼容的第三方中间件，如：

```bash
# 安装 cors 中间件
npm install cors
```

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as cors from 'cors';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 使用 cors 中间件
  app.use(cors());
  
  await app.listen(3000);
}

bootstrap();
```

## 10. 总结

在本章中，我们学习了 NestJS 中间件的基本概念和使用方法，包括：

- 如何创建函数式中间件和类中间件
- 如何在模块中注册中间件
- 如何为不同的路由和控制器应用中间件
- 如何注册全局中间件
- 中间件的执行顺序
- 如何在中间件中使用依赖注入
- 如何编写异步中间件
- 中间件的最佳实践
- 如何使用内置和第三方中间件

中间件是 NestJS 应用程序中的重要组成部分，掌握中间件的使用方法对于构建高效、可扩展的 NestJS 应用至关重要。在下一章中，我们将学习 NestJS 管道的使用方法。
