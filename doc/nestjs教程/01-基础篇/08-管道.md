# 管道

在 NestJS 中，管道（Pipes）是用于转换和验证数据的类，它可以在控制器处理请求之前或之后执行。管道可以处理控制器方法的参数、请求体、查询参数等，并将处理后的结果传递给控制器。

## 1. 管道的基本概念

管道是 NestJS 应用程序中的重要组成部分，它可以用于：

- 数据转换：将输入数据转换为所需的格式
- 数据验证：验证输入数据是否符合预期格式
- 参数验证：验证控制器方法的参数
- 请求体验证：验证请求体数据
- 查询参数验证：验证查询参数

管道可以应用于：

- 控制器方法的参数
- 控制器方法的返回值
- 全局范围

## 2. 管道的类型

NestJS 提供了两种类型的管道：

### 2.1 转换管道（Transform Pipes）

转换管道用于将输入数据转换为所需的格式，例如将字符串转换为数字，将日期字符串转换为日期对象等。

### 2.2 验证管道（Validation Pipes）

验证管道用于验证输入数据是否符合预期格式，例如验证必填字段、验证数据类型、验证数据格式等。如果验证失败，管道会抛出异常，否则会将验证后的数据传递给控制器。

## 3. 创建管道

### 3.1 自定义管道

创建一个自定义管道需要实现 `PipeTransform` 接口，该接口定义了一个 `transform` 方法，接收两个参数：

- `value`：输入数据
- `metadata`：元数据，包含参数类型、参数名称等信息

#### 3.1.1 转换管道示例

```typescript
// src/common/pipes/parse-int.pipe.ts
import { PipeTransform, Injectable, BadRequestException } from '@nestjs/common';

@Injectable()
export class ParseIntPipe implements PipeTransform<string, number> {
  // 实现 transform 方法
  transform(value: string, metadata: any): number {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      // 抛出异常
      throw new BadRequestException(`Validation failed. "${value}" is not an integer.`);
    }
    // 返回转换后的值
    return val;
  }
}
```

#### 3.1.2 验证管道示例

```typescript
// src/common/pipes/validation.pipe.ts
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    // 验证数据是否存在
    if (!value) {
      throw new BadRequestException('Validation failed: No data provided');
    }
    
    // 验证数据类型
    if (metadata.type === 'body') {
      // 验证请求体数据
      if (typeof value !== 'object') {
        throw new BadRequestException('Validation failed: Body must be an object');
      }
    }
    
    // 返回验证后的数据
    return value;
  }
}
```

## 4. 内置管道

NestJS 提供了一些内置的管道，用于常见的数据转换和验证：

### 4.1 `ValidationPipe`

`ValidationPipe` 是一个强大的验证管道，用于验证请求数据是否符合 DTO（数据传输对象）的定义。它使用 `class-validator` 和 `class-transformer` 库来实现验证。

### 4.2 `ParseIntPipe`

`ParseIntPipe` 用于将字符串转换为数字。

### 4.3 `ParseFloatPipe`

`ParseFloatPipe` 用于将字符串转换为浮点数。

### 4.4 `ParseBoolPipe`

`ParseBoolPipe` 用于将字符串转换为布尔值。

### 4.5 `ParseArrayPipe`

`ParseArrayPipe` 用于将字符串或对象转换为数组。

### 4.6 `ParseUUIDPipe`

`ParseUUIDPipe` 用于验证字符串是否为有效的 UUID。

## 5. 使用管道

### 5.1 应用于控制器方法参数

使用 `@UsePipes()` 装饰器将管道应用于控制器方法参数：

```typescript
// src/users/users.controller.ts
import { Controller, Get, Param, UsePipes } from '@nestjs/common';
import { ParseIntPipe } from '../common/pipes/parse-int.pipe';
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get(':id')
  // 应用 ParseIntPipe 到 id 参数
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.usersService.findOne(id);
  }
}
```

### 5.2 应用于控制器方法

使用 `@UsePipes()` 装饰器将管道应用于整个控制器方法：

```typescript
// src/users/users.controller.ts
import { Controller, Post, Body, UsePipes } from '@nestjs/common';
import { ValidationPipe } from '../common/pipes/validation.pipe';
import { CreateUserDto } from './dto/create-user.dto';
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  // 应用 ValidationPipe 到整个方法
  @UsePipes(ValidationPipe)
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }
}
```

### 5.3 应用于控制器

使用 `@UsePipes()` 装饰器将管道应用于整个控制器：

```typescript
// src/users/users.controller.ts
import { Controller, UsePipes } from '@nestjs/common';
import { ValidationPipe } from '../common/pipes/validation.pipe';

@Controller('users')
// 应用 ValidationPipe 到整个控制器
@UsePipes(ValidationPipe)
export class UsersController {
  // 控制器方法
}
```

### 5.4 应用于全局范围

在 `main.ts` 文件中使用 `useGlobalPipes()` 方法将管道应用于全局范围：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from './common/pipes/validation.pipe';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 应用 ValidationPipe 到全局范围
  app.useGlobalPipes(new ValidationPipe());
  
  await app.listen(3000);
}

bootstrap();
```

## 6. 使用 `class-validator` 和 `class-transformer`

NestJS 推荐使用 `class-validator` 和 `class-transformer` 库来实现数据验证和转换。

### 6.1 安装依赖

```bash
# 安装依赖
npm install class-validator class-transformer
```

### 6.2 创建 DTO（数据传输对象）

创建一个 DTO 类，使用 `class-validator` 装饰器来定义验证规则：

```typescript
// src/users/dto/create-user.dto.ts
import { IsString, IsEmail, IsNotEmpty, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsString() // 验证是否为字符串
  @IsNotEmpty() // 验证是否不为空
  @MinLength(3) // 验证最小长度为 3
  name: string;

  @IsEmail() // 验证是否为有效的邮箱格式
  @IsNotEmpty() // 验证是否不为空
  email: string;

  @IsString() // 验证是否为字符串
  @IsNotEmpty() // 验证是否不为空
  @MinLength(6) // 验证最小长度为 6
  password: string;
}
```

### 6.3 使用 `ValidationPipe`

使用 NestJS 内置的 `ValidationPipe` 来验证 DTO：

```typescript
// src/users/users.controller.ts
import { Controller, Post, Body, UsePipes } from '@nestjs/common';
import { ValidationPipe } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  // 使用内置的 ValidationPipe
  @UsePipes(new ValidationPipe())
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }
}
```

### 6.4 配置 `ValidationPipe`

可以配置 `ValidationPipe` 的选项：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 配置 ValidationPipe
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, // 自动删除非白名单属性
      forbidNonWhitelisted: true, // 禁止非白名单属性
      transform: true, // 自动转换数据类型
      transformOptions: {
        enableImplicitConversion: true, // 启用隐式转换
      },
    })
  );
  
  await app.listen(3000);
}

bootstrap();
```

## 7. 管道的执行顺序

当多个管道应用于同一个参数或方法时，它们的执行顺序遵循以下规则：

1. 全局管道首先执行
2. 控制器级别的管道其次执行
3. 方法级别的管道再次执行
4. 参数级别的管道最后执行

## 8. 管道的依赖注入

管道可以使用依赖注入，就像控制器和服务一样。管道可以注入服务、配置等：

```typescript
// src/common/pipes/validation.pipe.ts
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';
import { ConfigService } from '../config/config.service';

@Injectable()
export class ValidationPipe implements PipeTransform {
  // 注入 ConfigService
  constructor(private readonly configService: ConfigService) {}

  transform(value: any, metadata: ArgumentMetadata) {
    // 使用 ConfigService
    const enableValidation = this.configService.get('ENABLE_VALIDATION');
    if (enableValidation) {
      // 验证逻辑
    }
    return value;
  }
}
```

## 9. 异步管道

管道可以是异步的，使用 `async/await` 语法：

```typescript
// src/common/pipes/async-validation.pipe.ts
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';

@Injectable()
export class AsyncValidationPipe implements PipeTransform {
  async transform(value: any, metadata: ArgumentMetadata) {
    // 模拟异步验证
    await this.validateAsync(value);
    return value;
  }

  private async validateAsync(value: any) {
    return new Promise<void>((resolve, reject) => {
      setTimeout(() => {
        if (!value) {
          reject(new BadRequestException('Validation failed: No data provided'));
        }
        resolve();
      }, 100);
    });
  }
}
```

## 10. 管道的最佳实践

### 10.1 单一职责原则

每个管道应该只负责一个特定的功能，遵循单一职责原则。例如，`ParseIntPipe` 只负责将字符串转换为数字，`ValidationPipe` 只负责验证数据。

### 10.2 使用内置管道

优先使用 NestJS 内置的管道，它们经过了充分的测试和优化。

### 10.3 使用 `class-validator` 和 `class-transformer`

对于复杂的数据验证，推荐使用 `class-validator` 和 `class-transformer` 库，它们提供了丰富的验证规则和转换功能。

### 10.4 配置 `ValidationPipe`

合理配置 `ValidationPipe` 的选项，例如启用 `whitelist`、`transform` 等选项，以提高验证的效率和准确性。

### 10.5 测试管道

管道应该易于测试，可以使用 Jest 来测试管道：

```typescript
// src/common/pipes/parse-int.pipe.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ParseIntPipe } from './parse-int.pipe';

describe('ParseIntPipe', () => {
  let pipe: ParseIntPipe;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ParseIntPipe],
    }).compile();

    pipe = module.get<ParseIntPipe>(ParseIntPipe);
  });

  it('should be defined', () => {
    expect(pipe).toBeDefined();
  });

  it('should transform string to number', () => {
    const result = pipe.transform('123', {} as any);
    expect(result).toBe(123);
    expect(typeof result).toBe('number');
  });

  it('should throw BadRequestException for invalid number', () => {
    expect(() => pipe.transform('abc', {} as any)).toThrow();
  });
});
```

## 11. 总结

在本章中，我们学习了 NestJS 管道的基本概念和使用方法，包括：

- 管道的基本概念和类型
- 如何创建自定义管道
- NestJS 内置管道
- 如何使用管道
- 如何使用 `class-validator` 和 `class-transformer` 进行数据验证和转换
- 管道的执行顺序
- 管道的依赖注入
- 异步管道
- 管道的最佳实践

管道是 NestJS 应用程序中的重要组成部分，掌握管道的使用方法对于构建高效、可扩展的 NestJS 应用至关重要。在下一章中，我们将学习 NestJS 过滤器的使用方法。
