# 过滤器

在 NestJS 中，过滤器（Filters）是用于处理异常的类，它可以捕获控制器、服务或管道中抛出的异常，并返回适当的 HTTP 响应。过滤器可以应用于控制器方法、控制器或全局范围。

## 1. 过滤器的基本概念

过滤器是 NestJS 应用程序中的重要组成部分，它可以用于：

- 统一异常处理
- 自定义错误响应格式
- 日志记录
- 错误分类处理
- 国际化错误消息

过滤器可以捕获以下类型的异常：

- NestJS 内置异常，如 `BadRequestException`、`NotFoundException` 等
- 自定义异常
- JavaScript 原生异常，如 `TypeError`、`ReferenceError` 等

## 2. 创建过滤器

### 2.1 自定义过滤器

创建一个自定义过滤器需要实现 `ExceptionFilter` 接口，该接口定义了一个 `catch` 方法，接收两个参数：

- `exception`：抛出的异常对象
- `host`：参数主机，用于获取请求和响应对象

#### 2.1.1 基础过滤器示例

```typescript
// src/common/filters/http-exception.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException) // 捕获 HttpException 类型的异常
export class HttpExceptionFilter implements ExceptionFilter {
  // 实现 catch 方法
  catch(exception: HttpException, host: ArgumentsHost) {
    // 获取请求和响应对象
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    
    // 获取异常状态码和消息
    const status = exception.getStatus();
    const message = exception.message || 'Internal Server Error';
    
    // 构建响应对象
    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message,
    };
    
    // 发送响应
    response.status(status).json(errorResponse);
  }
}
```

#### 2.1.2 捕获所有异常的过滤器

```typescript
// src/common/filters/all-exception.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpStatus } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch() // 捕获所有类型的异常
export class AllExceptionFilter implements ExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    
    // 确定状态码
    const status = exception.getStatus ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR;
    
    // 确定错误消息
    let message = 'Internal Server Error';
    if (exception instanceof Error) {
      message = exception.message;
    } else if (typeof exception === 'string') {
      message = exception;
    }
    
    // 构建响应对象
    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message,
    };
    
    // 记录日志
    console.error(`[${new Date().toISOString()}] ${request.method} ${request.url} - ${status} ${message}`);
    
    // 发送响应
    response.status(status).json(errorResponse);
  }
}
```

## 3. 内置异常

NestJS 提供了一些内置的异常类，用于处理常见的 HTTP 错误：

| 异常类 | HTTP 状态码 | 描述 |
|--------|------------|------|
| `BadRequestException` | 400 | 请求参数错误 |
| `UnauthorizedException` | 401 | 未授权 |
| `ForbiddenException` | 403 | 禁止访问 |
| `NotFoundException` | 404 | 资源未找到 |
| `MethodNotAllowedException` | 405 | 请求方法不允许 |
| `NotAcceptableException` | 406 | 不可接受的请求 |
| `RequestTimeoutException` | 408 | 请求超时 |
| `ConflictException` | 409 | 资源冲突 |
| `GoneException` | 410 | 资源已不存在 |
| `PayloadTooLargeException` | 413 | 请求体过大 |
| `UnsupportedMediaTypeException` | 415 | 不支持的媒体类型 |
| `UnprocessableEntityException` | 422 | 无法处理的实体 |
| `InternalServerErrorException` | 500 | 服务器内部错误 |
| `NotImplementedException` | 501 | 未实现的功能 |
| `BadGatewayException` | 502 | 网关错误 |
| `ServiceUnavailableException` | 503 | 服务不可用 |
| `GatewayTimeoutException` | 504 | 网关超时 |

## 4. 使用过滤器

### 4.1 应用于控制器方法

使用 `@UseFilters()` 装饰器将过滤器应用于控制器方法：

```typescript
// src/users/users.controller.ts
import { Controller, Get, Param, UseFilters, NotFoundException } from '@nestjs/common';
import { HttpExceptionFilter } from '../common/filters/http-exception.filter';
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get(':id')
  // 应用 HttpExceptionFilter 到 findOne 方法
  @UseFilters(HttpExceptionFilter)
  findOne(@Param('id') id: number) {
    const user = this.usersService.findOne(id);
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }
}
```

### 4.2 应用于控制器

使用 `@UseFilters()` 装饰器将过滤器应用于整个控制器：

```typescript
// src/users/users.controller.ts
import { Controller, UseFilters } from '@nestjs/common';
import { HttpExceptionFilter } from '../common/filters/http-exception.filter';

@Controller('users')
// 应用 HttpExceptionFilter 到整个控制器
@UseFilters(HttpExceptionFilter)
export class UsersController {
  // 控制器方法
}
```

### 4.3 应用于全局范围

在 `main.ts` 文件中使用 `useGlobalFilters()` 方法将过滤器应用于全局范围：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AllExceptionFilter } from './common/filters/all-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 应用 AllExceptionFilter 到全局范围
  app.useGlobalFilters(new AllExceptionFilter());
  
  await app.listen(3000);
}

bootstrap();
```

### 4.4 在模块中注册全局过滤器

你也可以在模块中注册全局过滤器，这样过滤器可以使用依赖注入：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { APP_FILTER } from '@nestjs/core';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AllExceptionFilter } from './common/filters/all-exception.filter';

@Module({
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: APP_FILTER,
      useClass: AllExceptionFilter, // 注册全局过滤器
    },
  ],
})
export class AppModule {}
```

## 5. 自定义异常

除了使用 NestJS 内置的异常类，你还可以创建自定义异常类，以便更好地组织和管理异常。

### 5.1 创建自定义异常类

创建一个自定义异常类，继承自 `HttpException` 或 `RuntimeException`：

```typescript
// src/common/exceptions/business.exception.ts
import { HttpException, HttpStatus } from '@nestjs/common';

// 自定义业务异常类
export class BusinessException extends HttpException {
  constructor(message: string, statusCode: HttpStatus = HttpStatus.BAD_REQUEST) {
    super(message, statusCode);
  }
}

// 自定义用户不存在异常类
export class UserNotFoundException extends HttpException {
  constructor(userId: number) {
    super(`User with ID ${userId} not found`, HttpStatus.NOT_FOUND);
  }
}
```

### 5.2 使用自定义异常

在服务或控制器中使用自定义异常：

```typescript
// src/users/users.service.ts
import { Injectable } from '@nestjs/common';
import { UserNotFoundException } from '../common/exceptions/business.exception';

@Injectable()
export class UsersService {
  private readonly users = [
    { id: 1, name: '张三', email: 'zhangsan@example.com' },
    { id: 2, name: '李四', email: 'lisi@example.com' },
  ];

  findOne(id: number) {
    const user = this.users.find(user => user.id === id);
    if (!user) {
      // 抛出自定义异常
      throw new UserNotFoundException(id);
    }
    return user;
  }
}
```

## 6. 过滤器的依赖注入

过滤器可以使用依赖注入，就像控制器和服务一样。过滤器可以注入服务、配置等：

```typescript
// src/common/filters/http-exception.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';
import { LoggerService } from '../services/logger.service';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  // 注入 LoggerService
  constructor(private readonly loggerService: LoggerService) {}

  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    
    const status = exception.getStatus();
    const message = exception.message;
    
    // 使用 LoggerService 记录日志
    this.loggerService.error(`[${request.method}] ${request.url} - ${status} - ${message}`);
    
    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message,
    });
  }
}
```

## 7. 异步过滤器

过滤器可以是异步的，使用 `async/await` 语法：

```typescript
// src/common/filters/async-exception.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';
import { LoggerService } from '../services/logger.service';

@Catch(HttpException)
export class AsyncExceptionFilter implements ExceptionFilter {
  constructor(private readonly loggerService: LoggerService) {}

  async catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    
    const status = exception.getStatus();
    const message = exception.message;
    
    // 异步记录日志
    await this.loggerService.saveLogAsync({
      level: 'error',
      message,
      path: request.url,
      method: request.method,
      status,
      timestamp: new Date().toISOString(),
    });
    
    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message,
    });
  }
}
```

## 8. 过滤器的最佳实践

### 8.1 单一职责原则

每个过滤器应该只负责一个特定的功能，遵循单一职责原则。例如，`HttpExceptionFilter` 只负责处理 HTTP 异常，`AllExceptionFilter` 只负责处理所有类型的异常。

### 8.2 统一错误格式

使用过滤器统一错误响应格式，使得客户端能够更容易地处理错误。

### 8.3 日志记录

在过滤器中添加日志记录，以便调试和监控应用程序的运行状态。

### 8.4 自定义异常

创建自定义异常类，以便更好地组织和管理异常。

### 8.5 测试过滤器

过滤器应该易于测试，可以使用 Jest 来测试过滤器：

```typescript
// src/common/filters/http-exception.filter.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { HttpExceptionFilter } from './http-exception.filter';
import { BadRequestException } from '@nestjs/common';

describe('HttpExceptionFilter', () => {
  let filter: HttpExceptionFilter;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [HttpExceptionFilter],
    }).compile();

    filter = module.get<HttpExceptionFilter>(HttpExceptionFilter);
  });

  it('should be defined', () => {
    expect(filter).toBeDefined();
  });

  it('should catch HttpException', () => {
    const exception = new BadRequestException('Validation failed');
    const host = {
      switchToHttp: () => ({
        getResponse: () => ({
          status: jest.fn().mockReturnThis(),
          json: jest.fn(),
        }),
        getRequest: () => ({
          url: '/users',
          method: 'POST',
        }),
      }),
    } as any;

    filter.catch(exception, host);
    
    expect(host.switchToHttp().getResponse().status).toHaveBeenCalledWith(400);
    expect(host.switchToHttp().getResponse().json).toHaveBeenCalled();
  });
});
```

## 9. 总结

在本章中，我们学习了 NestJS 过滤器的基本概念和使用方法，包括：

- 过滤器的基本概念和作用
- 如何创建自定义过滤器
- NestJS 内置异常类
- 如何使用过滤器
- 如何创建和使用自定义异常
- 过滤器的依赖注入
- 异步过滤器
- 过滤器的最佳实践

过滤器是 NestJS 应用程序中的重要组成部分，掌握过滤器的使用方法对于构建高效、可扩展的 NestJS 应用至关重要。在下一章中，我们将学习 NestJS 拦截器的使用方法。
