# 拦截器

在 NestJS 中，拦截器（Interceptors）是用于拦截控制器方法调用的类，它可以在控制器方法执行前后执行额外的逻辑。拦截器可以用于日志记录、数据转换、缓存、异常处理等。

## 1. 拦截器的基本概念

拦截器是 NestJS 应用程序中的重要组成部分，它可以用于：

- 请求/响应日志记录
- 请求/响应数据转换
- 缓存管理
- 性能监控
- 异常处理
- 权限验证
- 请求重试
- 超时处理

拦截器遵循洋葱模型（Onion Model），即请求先经过外层拦截器，然后经过内层拦截器，最后到达控制器，响应则相反，从控制器返回，经过内层拦截器，最后经过外层拦截器返回给客户端。

## 2. 创建拦截器

### 2.1 自定义拦截器

创建一个自定义拦截器需要实现 `NestInterceptor` 接口，该接口定义了一个 `intercept` 方法，接收两个参数：

- `context`：执行上下文，用于获取请求和响应对象
- `next`：调用处理器，用于执行下一个拦截器或控制器方法

#### 2.1.1 基础拦截器示例

```typescript
// src/common/interceptors/logging.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Request, Response } from 'express';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  // 实现 intercept 方法
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    // 获取请求和响应对象
    const httpContext = context.switchToHttp();
    const request = httpContext.getRequest<Request>();
    const response = httpContext.getResponse<Response>();
    
    // 记录请求开始时间
    const startTime = Date.now();
    const { method, url } = request;
    
    console.log(`[${new Date().toISOString()}] ${method} ${url} - Request started`);
    
    // 执行下一个拦截器或控制器方法，并在响应返回后执行后续逻辑
    return next.handle().pipe(
      tap(() => {
        // 计算请求处理时间
        const endTime = Date.now();
        const duration = endTime - startTime;
        const statusCode = response.statusCode;
        
        console.log(`[${new Date().toISOString()}] ${method} ${url} - ${statusCode} - ${duration}ms`);
      }),
    );
  }
}
```

#### 2.1.2 数据转换拦截器示例

```typescript
// src/common/interceptors/transform.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class TransformInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map(data => ({
        status: 'success',
        data,
        timestamp: new Date().toISOString(),
      })),
    );
  }
}
```

## 3. 内置操作符

拦截器使用 RxJS 操作符来处理响应流，常用的操作符包括：

| 操作符 | 描述 |
|--------|------|
| `tap` | 执行副作用操作，不改变响应数据 |
| `map` | 转换响应数据 |
| `catchError` | 捕获和处理异常 |
| `timeout` | 设置超时时间 |
| `retry` | 请求重试 |
| `delay` | 延迟响应 |
| `debounceTime` | 防抖 |
| `throttleTime` | 节流 |

## 4. 使用拦截器

### 4.1 应用于控制器方法

使用 `@UseInterceptors()` 装饰器将拦截器应用于控制器方法：

```typescript
// src/users/users.controller.ts
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { LoggingInterceptor } from '../common/interceptors/logging.interceptor';
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  // 应用 LoggingInterceptor 到 findAll 方法
  @UseInterceptors(LoggingInterceptor)
  findAll() {
    return this.usersService.findAll();
  }
}
```

### 4.2 应用于控制器

使用 `@UseInterceptors()` 装饰器将拦截器应用于整个控制器：

```typescript
// src/users/users.controller.ts
import { Controller, UseInterceptors } from '@nestjs/common';
import { LoggingInterceptor } from '../common/interceptors/logging.interceptor';

@Controller('users')
// 应用 LoggingInterceptor 到整个控制器
@UseInterceptors(LoggingInterceptor)
export class UsersController {
  // 控制器方法
}
```

### 4.3 应用于全局范围

在 `main.ts` 文件中使用 `useGlobalInterceptors()` 方法将拦截器应用于全局范围：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { LoggingInterceptor } from './common/interceptors/logging.interceptor';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 应用 LoggingInterceptor 到全局范围
  app.useGlobalInterceptors(new LoggingInterceptor());
  
  await app.listen(3000);
}

bootstrap();
```

### 4.4 在模块中注册全局拦截器

你也可以在模块中注册全局拦截器，这样拦截器可以使用依赖注入：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { LoggingInterceptor } from './common/interceptors/logging.interceptor';

@Module({
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: APP_INTERCEPTOR,
      useClass: LoggingInterceptor, // 注册全局拦截器
    },
  ],
})
export class AppModule {}
```

## 5. 拦截器的依赖注入

拦截器可以使用依赖注入，就像控制器和服务一样。拦截器可以注入服务、配置等：

```typescript
// src/common/interceptors/logging.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { LoggerService } from '../services/logger.service';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  // 注入 LoggerService
  constructor(private readonly loggerService: LoggerService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const httpContext = context.switchToHttp();
    const request = httpContext.getRequest();
    const response = httpContext.getResponse();
    
    const startTime = Date.now();
    const { method, url } = request;
    
    // 使用 LoggerService 记录日志
    this.loggerService.log(`[Request] ${method} ${url}`);
    
    return next.handle().pipe(
      tap(() => {
        const endTime = Date.now();
        const duration = endTime - startTime;
        const statusCode = response.statusCode;
        
        this.loggerService.log(`[Response] ${method} ${url} - ${statusCode} - ${duration}ms`);
      }),
    );
  }
}
```

## 6. 异常处理拦截器

拦截器可以用于捕获和处理异常，使用 `catchError` 操作符：

```typescript
// src/common/interceptors/exception.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, HttpStatus } from '@nestjs/common';
import { Observable, throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';

@Injectable()
export class ExceptionInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      catchError(error => {
        // 记录异常
        console.error(`[${new Date().toISOString()}] Exception: ${error.message}`);
        
        // 转换异常格式
        const errorResponse = {
          statusCode: error.getStatus ? error.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR,
          message: error.message || 'Internal Server Error',
          timestamp: new Date().toISOString(),
        };
        
        // 抛出转换后的异常
        return throwError(() => error);
      }),
    );
  }
}
```

## 7. 缓存拦截器

拦截器可以用于实现缓存功能，提高应用程序的性能：

```typescript
// src/common/interceptors/cache.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable, of } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  // 简单的内存缓存
  private cache = new Map<string, { data: any; timestamp: number }>();
  private readonly TTL = 60000; // 缓存过期时间：60秒

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    // 获取请求信息
    const httpContext = context.switchToHttp();
    const request = httpContext.getRequest();
    const { method, url } = request;
    
    // 只缓存 GET 请求
    if (method !== 'GET') {
      return next.handle();
    }
    
    // 生成缓存键
    const cacheKey = url;
    
    // 检查缓存是否存在且未过期
    const cachedData = this.cache.get(cacheKey);
    if (cachedData) {
      const now = Date.now();
      if (now - cachedData.timestamp < this.TTL) {
        console.log(`[Cache] Hit - ${url}`);
        return of(cachedData.data); // 返回缓存数据
      } else {
        // 缓存过期，删除缓存
        this.cache.delete(cacheKey);
      }
    }
    
    // 执行请求并缓存结果
    return next.handle().pipe(
      tap(data => {
        console.log(`[Cache] Miss - ${url}`);
        // 缓存结果
        this.cache.set(cacheKey, {
          data,
          timestamp: Date.now(),
        });
      }),
    );
  }
}
```

## 8. 拦截器的执行顺序

当多个拦截器应用于同一个方法或控制器时，它们的执行顺序遵循以下规则：

1. 全局拦截器首先执行
2. 控制器级别的拦截器其次执行
3. 方法级别的拦截器再次执行

例如：

```typescript
// src/main.ts
app.useGlobalInterceptors(new GlobalInterceptor1());
app.useGlobalInterceptors(new GlobalInterceptor2());

// src/users/users.controller.ts
@Controller('users')
@UseInterceptors(ControllerInterceptor1, ControllerInterceptor2)
export class UsersController {
  @Get()
  @UseInterceptors(MethodInterceptor1, MethodInterceptor2)
  findAll() {
    // 方法实现
  }
}
```

执行顺序：
- 请求：`GlobalInterceptor1` → `GlobalInterceptor2` → `ControllerInterceptor1` → `ControllerInterceptor2` → `MethodInterceptor1` → `MethodInterceptor2` → 控制器方法
- 响应：控制器方法 → `MethodInterceptor2` → `MethodInterceptor1` → `ControllerInterceptor2` → `ControllerInterceptor1` → `GlobalInterceptor2` → `GlobalInterceptor1`

## 9. 拦截器的最佳实践

### 9.1 单一职责原则

每个拦截器应该只负责一个特定的功能，遵循单一职责原则。例如，`LoggingInterceptor` 只负责日志记录，`TransformInterceptor` 只负责数据转换。

### 9.2 使用 RxJS 操作符

充分利用 RxJS 操作符来处理响应流，实现复杂的业务逻辑。

### 9.3 避免阻塞操作

拦截器应该避免执行阻塞操作，如长时间的同步计算或 I/O 操作，以免影响应用程序的性能。

### 9.4 使用依赖注入

使用依赖注入来获取服务和配置，而不是硬编码依赖。

### 9.5 测试拦截器

拦截器应该易于测试，可以使用 Jest 和 RxJS 测试工具来测试拦截器：

```typescript
// src/common/interceptors/logging.interceptor.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { LoggingInterceptor } from './logging.interceptor';
import { ExecutionContext } from '@nestjs/common';

describe('LoggingInterceptor', () => {
  let interceptor: LoggingInterceptor;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [LoggingInterceptor],
    }).compile();

    interceptor = module.get<LoggingInterceptor>(LoggingInterceptor);
  });

  it('should be defined', () => {
    expect(interceptor).toBeDefined();
  });

  it('should intercept request and response', () => {
    const context = {
      switchToHttp: () => ({
        getRequest: () => ({ method: 'GET', url: '/users' }),
        getResponse: () => ({}),
      }),
    } as ExecutionContext;

    const next = {
      handle: () => ({ pipe: jest.fn().mockReturnThis() }),
    } as any;

    interceptor.intercept(context, next);
    
    expect(next.handle).toHaveBeenCalled();
  });
});
```

## 10. 总结

在本章中，我们学习了 NestJS 拦截器的基本概念和使用方法，包括：

- 拦截器的基本概念和作用
- 如何创建自定义拦截器
- 常用的 RxJS 操作符
- 如何使用拦截器
- 拦截器的依赖注入
- 异常处理拦截器
- 缓存拦截器
- 拦截器的执行顺序
- 拦截器的最佳实践

拦截器是 NestJS 应用程序中的重要组成部分，掌握拦截器的使用方法对于构建高效、可扩展的 NestJS 应用至关重要。

到此为止，我们已经完成了 NestJS 基础篇教程的学习，包括控制器、服务、模块、中间件、管道、过滤器和拦截器等核心概念。这些概念是构建 NestJS 应用程序的基础，掌握它们对于学习更高级的 NestJS 特性至关重要。

在接下来的进阶篇教程中，我们将学习更高级的 NestJS 特性，如配置管理、数据库集成、认证与授权、API 文档等。
