# 认证与授权

## 1. JWT 认证机制

JWT（JSON Web Token）是一种用于在网络应用间传递声明的安全方式，常用于认证和授权。

### 1.1 JWT 结构

JWT 由三部分组成，用点号分隔：
- Header（头部）：包含算法和令牌类型
- Payload（负载）：包含声明信息
- Signature（签名）：用于验证令牌完整性

### 1.2 安装依赖

```bash
# 安装 JWT 和 Passport 相关依赖
npm install @nestjs/jwt @nestjs/passport passport passport-jwt
# 安装类型定义
npm install -D @types/passport-jwt
```

### 1.3 配置 JWT 模块

```typescript
// src/config/jwt.ts
// JWT 配置文件，首次出现，详细注释说明
import { JwtModuleOptions } from '@nestjs/jwt';

export const jwtConfig: JwtModuleOptions = {
  secret: process.env.JWT_SECRET || 'your-secret-key', // JWT 密钥，生产环境需使用环境变量
  signOptions: {
    expiresIn: '24h', // 令牌有效期
  },
};
```

### 1.4 创建 AuthGuard

```typescript
// src/common/guards/auth.guard.ts
// 认证守卫，首次出现，详细注释说明
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
// 使用 Passport 的 JWT 策略进行认证
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

### 1.5 创建 JWT 策略

```typescript
// src/module/auth/auth.strategy.ts
// JWT 策略，首次出现，详细注释说明
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { jwtConfig } from '../../config/jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      // 从请求头的 Authorization 字段中提取 JWT
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      // 是否忽略过期令牌
      ignoreExpiration: false,
      // 使用配置的密钥验证令牌
      secretOrKey: jwtConfig.secret,
    });
  }

  // 验证成功后，将令牌中的用户信息添加到请求对象中
  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username, roles: payload.roles };
  }
}
```

### 1.6 创建设置装饰器

```typescript
// src/common/decorator/roles.decorator.ts
// 角色装饰器，首次出现，详细注释说明
import { SetMetadata } from '@nestjs/common';

// 定义元数据键
export const ROLES_KEY = 'roles';
// 创建装饰器，用于设置路由需要的角色

export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

### 1.7 创建角色守卫

```typescript
// src/common/guards/roles.guard.ts
// 角色守卫，首次出现，详细注释说明
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorator/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    // 从路由中获取需要的角色
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    // 如果没有设置角色，则允许访问
    if (!requiredRoles) {
      return true;
    }
    // 从请求中获取用户信息
    const { user } = context.switchToHttp().getRequest();
    // 检查用户角色是否包含需要的角色
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
```

### 1.8 使用示例

```typescript
// src/module/users/users.controller.ts
import { Controller, Get, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../../common/guards/auth.guard';
import { RolesGuard } from '../../common/guards/roles.guard';
import { Roles } from '../../common/decorator/roles.decorator';

@Controller('users')
@UseGuards(JwtAuthGuard, RolesGuard) // 应用认证守卫和角色守卫
export class UsersController {
  // 需要 admin 角色才能访问
  @Get('admin')
  @Roles('admin')
  getAdminUsers() {
    return 'Admin users list';
  }

  // 任何认证用户都可以访问
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}
```

## 2. Passport 策略

Passport 是一个功能强大的认证中间件，支持多种认证策略。

### 2.1 本地策略

用于用户名密码认证：

```typescript
// src/module/auth/local.strategy.ts
// 本地策略，首次出现，详细注释说明
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { UsersService } from '../users/users.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private usersService: UsersService) {
    super();
  }

  async validate(username: string, password: string): Promise<any> {
    // 验证用户名和密码
    const user = await this.usersService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException('用户名或密码错误');
    }
    return user;
  }
}
```

## 3. 刷新令牌机制

### 3.1 实现思路

- 生成访问令牌（Access Token）和刷新令牌（Refresh Token）
- 访问令牌有效期短，刷新令牌有效期长
- 当访问令牌过期时，使用刷新令牌获取新的访问令牌

### 3.2 实现代码

```typescript
// src/module/auth/auth.service.ts
// AuthService，首次出现，详细注释说明
import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  // 登录并生成令牌
  async login(user: any) {
    const payload = { username: user.username, sub: user.id, roles: user.roles };
    return {
      access_token: this.jwtService.sign(payload), // 生成访问令牌
      refresh_token: this.jwtService.sign(payload, { expiresIn: '7d' }), // 生成刷新令牌，有效期7天
    };
  }

  // 使用刷新令牌获取新的访问令牌
  async refreshToken(refreshToken: string) {
    try {
      const payload = this.jwtService.verify(refreshToken); // 验证刷新令牌
      const user = await this.usersService.findOne(payload.sub); // 获取用户信息
      if (!user) {
        throw new UnauthorizedException('用户不存在');
      }
      // 生成新的访问令牌
      const newPayload = { username: user.username, sub: user.id, roles: user.roles };
      return {
        access_token: this.jwtService.sign(newPayload),
      };
    } catch (error) {
      throw new UnauthorizedException('刷新令牌无效');
    }
  }
}
```

## 4. 最佳实践

1. **使用环境变量存储密钥**：生产环境中，JWT 密钥应通过环境变量配置，避免硬编码
2. **设置合理的令牌有效期**：访问令牌有效期不宜过长，刷新令牌可适当延长
3. **实现令牌黑名单**：支持注销登录，将无效令牌加入黑名单
4. **使用 HTTPS**：在生产环境中，必须使用 HTTPS 传输令牌，防止被窃取
5. **添加角色权限控制**：根据用户角色限制资源访问
6. **实现令牌刷新机制**：避免用户频繁登录
7. **记录认证日志**：记录登录、注销等关键操作，便于审计

## 5. 常见问题

### 5.1 令牌过期处理

在前端拦截器中处理令牌过期：

```javascript
// axios 拦截器示例
axios.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config;
    // 如果是 401 错误且没有重试过
    if (error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      try {
        // 使用刷新令牌获取新的访问令牌
        const refreshToken = localStorage.getItem('refreshToken');
        const res = await axios.post('/auth/refresh', { refreshToken });
        localStorage.setItem('accessToken', res.data.access_token);
        // 重新请求原来的接口
        originalRequest.headers.Authorization = `Bearer ${res.data.access_token}`;
        return axios(originalRequest);
      } catch (err) {
        // 刷新令牌也失效，跳转到登录页
        window.location.href = '/login';
        return Promise.reject(err);
      }
    }
    return Promise.reject(error);
  }
);
```

### 5.2 跨域资源共享 (CORS)

在 NestJS 中配置 CORS：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  // 配置 CORS
  app.enableCors({
    origin: process.env.CORS_ORIGIN || '*', // 允许的源
    credentials: true, // 允许携带凭证
  });
  await app.listen(3000);
}
bootstrap();
```
