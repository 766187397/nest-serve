# 数据库操作

## 1. TypeORM 简介

TypeORM 是一个功能强大的 ORM（对象关系映射）库，支持多种数据库，包括 MySQL、PostgreSQL、SQLite、MongoDB 等。它允许开发者使用 TypeScript 或 JavaScript 定义实体，并通过简单的 API 进行数据库操作。

## 2. 安装依赖

```bash
# 安装 TypeORM 和相关依赖
npm install @nestjs/typeorm typeorm mysql2
```

## 3. 配置 TypeORM

### 3.1 基本配置

```typescript
// src/config/db.ts
// 数据库配置文件，首次出现，详细注释说明
import { TypeOrmModuleOptions } from '@nestjs/typeorm';
import { join } from 'path';

export const typeOrmConfig: TypeOrmModuleOptions = {
  type: 'mysql', // 数据库类型
  host: process.env.DB_HOST || 'localhost', // 数据库主机
  port: parseInt(process.env.DB_PORT || '3306'), // 数据库端口
  username: process.env.DB_USERNAME || 'root', // 数据库用户名
  password: process.env.DB_PASSWORD || 'password', // 数据库密码
  database: process.env.DB_DATABASE || 'nest_demo', // 数据库名称
  entities: [join(__dirname, '..', '**', '*.entity{.ts,.js}')], // 实体文件路径
  synchronize: process.env.DB_SYNCHRONIZE === 'true' || false, // 自动同步数据库结构
  logging: process.env.DB_LOGGING === 'true' || false, // 是否启用日志
  autoLoadEntities: true, // 自动加载实体
  charset: 'utf8mb4', // 字符集
  timezone: '+08:00', // 时区
};
```

### 3.2 注册 TypeORM 模块

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { typeOrmConfig } from './config/db';

@Module({
  imports: [
    TypeOrmModule.forRoot(typeOrmConfig), // 注册 TypeORM 模块
    // 其他模块
  ],
})
export class AppModule {}
```

## 4. 创建实体

实体是数据库表的映射，使用装饰器定义。

### 4.1 基本实体

```typescript
// src/module/users/entities/user.entity.ts
// 用户实体，首次出现，详细注释说明
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, DeleteDateColumn } from 'typeorm';

@Entity('users') // 数据库表名
@Unique(['username', 'email']) // 唯一约束
export class User {
  @PrimaryGeneratedColumn('uuid') // 主键，UUID 类型
  id: string;

  @Column({ length: 50, comment: '用户名' }) // 用户名列，长度 50
  username: string;

  @Column({ length: 100, comment: '密码' }) // 密码列，长度 100
  password: string;

  @Column({ length: 100, comment: '邮箱' }) // 邮箱列，长度 100
  email: string;

  @Column({ length: 11, nullable: true, comment: '手机号' }) // 手机号列，可空
  phone: string;

  @Column({ default: 1, comment: '状态：0-禁用，1-启用' }) // 状态列，默认值 1
  status: number;

  @Column({ type: 'json', default: [], comment: '角色列表' }) // 角色列表，JSON 类型
  roles: string[];

  @CreateDateColumn({ comment: '创建时间' }) // 创建时间，自动生成
  createdAt: Date;

  @UpdateDateColumn({ comment: '更新时间' }) // 更新时间，自动生成
  updatedAt: Date;

  @DeleteDateColumn({ comment: '删除时间' }) // 删除时间，用于软删除
  deletedAt: Date;
}
```

### 4.2 实体关系

#### 4.2.1 一对多关系

```typescript
// src/module/roles/entities/role.entity.ts
import { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';
import { User } from '../users/entities/user.entity';

@Entity('roles')
export class Role {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ length: 50, comment: '角色名称' })
  name: string;

  @Column({ length: 200, nullable: true, comment: '角色描述' })
  description: string;

  // 一对多关系：一个角色可以对应多个用户
  @OneToMany(() => User, (user) => user.role)
  users: User[];
}

// 更新 User 实体，添加多对一关系
@Entity('users')
export class User {
  // 其他字段...

  @ManyToOne(() => Role, (role) => role.users, { nullable: true })
  role: Role;
}
```

#### 4.2.2 多对多关系

```typescript
// src/module/permissions/entities/permission.entity.ts
import { Entity, Column, PrimaryGeneratedColumn, ManyToMany, JoinTable } from 'typeorm';
import { Role } from '../roles/entities/role.entity';

@Entity('permissions')
export class Permission {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ length: 50, comment: '权限名称' })
  name: string;

  @Column({ length: 100, comment: '权限标识' })
  code: string;

  // 多对多关系：一个权限可以分配给多个角色
  @ManyToMany(() => Role, (role) => role.permissions)
  @JoinTable({
    name: 'role_permissions', // 中间表名
    joinColumn: { name: 'permission_id' }, // 权限表外键
    inverseJoinColumn: { name: 'role_id' }, // 角色表外键
  })
  roles: Role[];
}

// 更新 Role 实体，添加多对多关系
@Entity('roles')
export class Role {
  // 其他字段...

  // 多对多关系：一个角色可以拥有多个权限
  @ManyToMany(() => Permission, (permission) => permission.roles)
  permissions: Permission[];
}
```

## 5. 基本操作

使用 TypeORM Repository 进行数据库操作。

### 5.1 注册 Repository

```typescript
// src/module/users/users.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [TypeOrmModule.forFeature([User])], // 注册 User Repository
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```

### 5.2 基本 CRUD 操作

```typescript
// src/module/users/users.service.ts
// 用户服务，包含基本 CRUD 操作，首次出现，详细注释说明
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User) // 注入 User Repository
    private userRepository: Repository<User>,
  ) {}

  // 创建用户
  async create(createUserDto: CreateUserDto): Promise<User> {
    const user = this.userRepository.create(createUserDto); // 创建实体实例
    return await this.userRepository.save(user); // 保存到数据库
  }

  // 查询所有用户
  async findAll(): Promise<User[]> {
    return await this.userRepository.find(); // 查询所有用户
  }

  // 根据 ID 查询用户
  async findOne(id: string): Promise<User> {
    const user = await this.userRepository.findOneBy({ id }); // 根据 ID 查询
    if (!user) {
      throw new NotFoundException(`用户 ${id} 不存在`); // 抛出 404 异常
    }
    return user;
  }

  // 更新用户
  async update(id: string, updateUserDto: UpdateUserDto): Promise<User> {
    const user = await this.findOne(id); // 先查询用户是否存在
    const updatedUser = this.userRepository.merge(user, updateUserDto); // 合并更新
    return await this.userRepository.save(updatedUser); // 保存到数据库
  }

  // 删除用户
  async remove(id: string): Promise<void> {
    const result = await this.userRepository.delete(id); // 删除用户
    if (result.affected === 0) {
      throw new NotFoundException(`用户 ${id} 不存在`); // 抛出 404 异常
    }
  }

  // 软删除用户
  async softRemove(id: string): Promise<void> {
    const user = await this.findOne(id); // 先查询用户是否存在
    await this.userRepository.softRemove(user); // 软删除
  }

  // 查询被软删除的用户
  async findDeleted(): Promise<User[]> {
    return await this.userRepository.find({
      withDeleted: true, // 包含被软删除的记录
      where: { deletedAt: Not(IsNull()) }, // 筛选已删除的记录
    });
  }

  // 恢复被软删除的用户
  async restore(id: string): Promise<User> {
    const user = await this.userRepository.findOne({
      withDeleted: true, // 包含被软删除的记录
      where: { id },
    });
    if (!user) {
      throw new NotFoundException(`用户 ${id} 不存在`);
    }
    await this.userRepository.restore(id); // 恢复用户
    return this.findOne(id); // 返回恢复后的用户
  }
}
```

## 6. 查询构建器

查询构建器提供了更灵活的查询方式。

### 6.1 基本查询

```typescript
// src/module/users/users.service.ts
async findUsersWithQueryBuilder(): Promise<User[]> {
  return await this.userRepository
    .createQueryBuilder('user') // 创建查询构建器
    .select(['user.id', 'user.username', 'user.email']) // 选择字段
    .where('user.status = :status', { status: 1 }) // 条件
    .andWhere('user.createdAt > :date', { date: new Date('2023-01-01') }) // 附加条件
    .orderBy('user.createdAt', 'DESC') // 排序
    .skip(0) // 跳过记录数
    .take(10) // 获取记录数
    .getMany(); // 查询多条
}
```

### 6.2 关联查询

```typescript
async findUsersWithRoles(): Promise<User[]> {
  return await this.userRepository
    .createQueryBuilder('user')
    .leftJoinAndSelect('user.role', 'role') // 左连接角色表
    .where('user.status = :status', { status: 1 })
    .getMany();
}
```

### 6.3 原生 SQL 查询

```typescript
async findUsersWithNativeSql(): Promise<any[]> {
  return await this.userRepository.query(
    'SELECT u.id, u.username, u.email, r.name as role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.status = ?',
    [1],
  );
}
```

## 7. 事务管理

事务用于确保一系列操作的原子性。

### 7.1 使用 @Transactional 装饰器

```typescript
// src/module/users/users.service.ts
import { Transactional } from 'typeorm-transactional-cls-hooked';

@Injectable()
export class UsersService {
  // 其他方法...

  @Transactional() // 事务装饰器
  async createUserWithRole(createUserDto: CreateUserDto): Promise<User> {
    // 创建用户
    const user = this.userRepository.create(createUserDto);
    await this.userRepository.save(user);

    // 分配角色
    const role = await this.roleRepository.findOneBy({ name: 'user' });
    if (role) {
      user.role = role;
      await this.userRepository.save(user);
    }

    return user;
  }
}
```

### 7.2 手动事务

```typescript
async createUserWithManualTransaction(createUserDto: CreateUserDto): Promise<User> {
  // 获取事务管理器
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    // 在事务中执行操作
    const user = queryRunner.manager.create(User, createUserDto);
    await queryRunner.manager.save(user);

    const role = await queryRunner.manager.findOneBy(Role, { name: 'user' });
    if (role) {
      user.role = role;
      await queryRunner.manager.save(user);
    }

    await queryRunner.commitTransaction(); // 提交事务
    return user;
  } catch (error) {
    await queryRunner.rollbackTransaction(); // 回滚事务
    throw error;
  } finally {
    await queryRunner.release(); // 释放事务管理器
  }
}
```

## 8. 迁移

迁移用于管理数据库结构的变更。

### 8.1 生成迁移

```bash
# 生成迁移文件
npm run typeorm migration:generate -- -n CreateUsersTable
```

### 8.2 运行迁移

```bash
# 运行迁移
npm run typeorm migration:run
```

### 8.3 回滚迁移

```bash
# 回滚上一次迁移
npm run typeorm migration:revert
```

### 8.4 创建迁移文件

```typescript
// src/migrations/1620000000000-CreateUsersTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class CreateUsersTable1620000000000 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      CREATE TABLE users (
        id VARCHAR(36) NOT NULL PRIMARY KEY,
        username VARCHAR(50) NOT NULL,
        email VARCHAR(100) NOT NULL,
        password VARCHAR(100) NOT NULL,
        status INT NOT NULL DEFAULT 1,
        created_at DATETIME NOT NULL,
        updated_at DATETIME NOT NULL,
        deleted_at DATETIME NULL,
        UNIQUE INDEX IDX_users_username (username),
        UNIQUE INDEX IDX_users_email (email)
      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query('DROP TABLE users;');
  }
}
```

## 9. 最佳实践

1. **使用 UUID 作为主键**：避免使用自增 ID，提高安全性和分布式系统兼容性
2. **软删除**：使用 `@DeleteDateColumn` 实现软删除，便于数据恢复
3. **索引优化**：为经常查询的字段添加索引
4. **事务管理**：重要操作使用事务确保数据一致性
5. **查询优化**：避免 N+1 查询问题，使用 `leftJoinAndSelect` 优化关联查询
6. **分页查询**：使用 `skip` 和 `take` 实现分页，避免一次性查询大量数据
7. **数据验证**：在实体中添加验证规则，使用管道进行数据验证
8. **环境变量配置**：使用环境变量管理数据库连接信息
9. **迁移管理**：使用迁移文件管理数据库结构变更
10. **日志记录**：开启数据库日志，便于调试和性能分析

## 10. 常见问题

### 10.1 N+1 查询问题

**问题**：当查询包含关联实体时，可能会导致 N+1 查询问题。

**解决方案**：使用 `leftJoinAndSelect` 或 `innerJoinAndSelect` 进行关联查询。

### 10.2 数据库连接池配置

**问题**：数据库连接数过多或过少，影响性能。

**解决方案**：合理配置连接池参数。

```typescript
// src/config/db.ts
export const typeOrmConfig: TypeOrmModuleOptions = {
  // 其他配置...
  extra: {
    connectionLimit: parseInt(process.env.DB_CONNECTION_LIMIT || '10'), // 最大连接数
    queueLimit: parseInt(process.env.DB_QUEUE_LIMIT || '0'), // 等待队列限制
  },
};
```

### 10.3 事务嵌套问题

**问题**：嵌套事务可能导致死锁或性能问题。

**解决方案**：避免深度嵌套事务，使用 `@Transactional` 装饰器或手动事务管理。

### 10.4 大数据量查询优化

**问题**：查询大量数据时，内存占用过高。

**解决方案**：使用流式查询或分页查询。

```typescript
async findUsersWithStream(): Promise<void> {
  const stream = await this.userRepository
    .createQueryBuilder('user')
    .stream();

  stream.on('data', (user) => {
    // 处理单条数据
    console.log(user);
  });

  stream.on('end', () => {
    // 数据处理完成
    console.log('Done');
  });
}
```
