# 文件上传与处理

## 1. 文件上传基础

文件上传是Web应用中常见的功能，NestJS提供了基于`multer`的文件上传支持。

### 1.1 安装依赖

```bash
# 安装文件上传相关依赖
npm install @nestjs/platform-express multer
# 安装类型定义
npm install -D @types/multer
```

## 2. 基本配置

### 2.1 配置文件存储路径

```typescript
// src/config/multer.ts
// 文件上传配置，首次出现，详细注释说明
import { diskStorage } from 'multer';
import { extname, join } from 'path';

// 确保上传目录存在
import { existsSync, mkdirSync } from 'fs';
const uploadPath = join(__dirname, '..', '..', 'uploads');
if (!existsSync(uploadPath)) {
  mkdirSync(uploadPath, { recursive: true });
}

export const multerConfig = {
  storage: diskStorage({
    destination: (req, file, callback) => {
      callback(null, uploadPath); // 文件存储目录
    },
    filename: (req, file, callback) => {
      // 生成唯一文件名
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
      const extension = extname(file.originalname);
      callback(null, `${file.fieldname}-${uniqueSuffix}${extension}`);
    },
  }),
  limits: {
    fileSize: 1024 * 1024 * 50, // 限制文件大小为50MB
    files: 10, // 限制单次上传文件数量
  },
  fileFilter: (req, file, callback) => {
    // 允许的文件类型
    const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx|xls|xlsx|txt|zip|rar/;
    const ext = extname(file.originalname).toLowerCase();
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && allowedTypes.test(ext)) {
      return callback(null, true);
    }
    callback(new Error('不支持的文件类型'));
  },
};
```

### 2.2 配置文件上传模块

```typescript
// src/module/upload/upload.module.ts
import { Module } from '@nestjs/common';
import { MulterModule } from '@nestjs/platform-express';
import { multerConfig } from '../../config/multer';
import { UploadController } from './upload.controller';
import { UploadService } from './upload.service';

@Module({
  imports: [
    MulterModule.register(multerConfig), // 注册 Multer 模块
  ],
  controllers: [UploadController],
  providers: [UploadService],
})
export class UploadModule {}
```

## 3. 基本文件上传

### 3.1 创建上传控制器

```typescript
// src/module/upload/upload.controller.ts
// 文件上传控制器，首次出现，详细注释说明
import { Controller, Post, UploadedFile, UseInterceptors, UploadedFiles } from '@nestjs/common';
import { FileInterceptor, FilesInterceptor } from '@nestjs/platform-express';
import { ApiTags, ApiOperation, ApiResponse, ApiConsumes, ApiBody } from '@nestjs/swagger';
import { UploadService } from './upload.service';
import { UploadDto } from './dto/index.dto';

@ApiTags('文件上传')
@Controller('upload')
export class UploadController {
  constructor(private readonly uploadService: UploadService) {}

  @ApiOperation({ summary: '单文件上传' })
  @ApiResponse({ status: 200, description: '上传成功' })
  @ApiResponse({ status: 400, description: '上传失败' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({ type: UploadDto })
  @UseInterceptors(FileInterceptor('file')) // 单文件上传拦截器
  @Post('single')
  async uploadSingleFile(@UploadedFile() file: Express.Multer.File) {
    return await this.uploadService.uploadFile(file);
  }

  @ApiOperation({ summary: '多文件上传' })
  @ApiResponse({ status: 200, description: '上传成功' })
  @ApiResponse({ status: 400, description: '上传失败' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({ type: UploadDto })
  @UseInterceptors(FilesInterceptor('files', 10)) // 多文件上传拦截器，最多10个文件
  @Post('multiple')
  async uploadMultipleFiles(@UploadedFiles() files: Express.Multer.File[]) {
    return await this.uploadService.uploadFiles(files);
  }
}
```

### 3.2 创建上传服务

```typescript
// src/module/upload/upload.service.ts
// 文件上传服务，首次出现，详细注释说明
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Upload } from './entities/upload.entity';
import { join } from 'path';

@Injectable()
export class UploadService {
  constructor(
    @InjectRepository(Upload) // 注入 Upload Repository
    private uploadRepository: Repository<Upload>,
  ) {}

  // 上传单文件
  async uploadFile(file: Express.Multer.File): Promise<any> {
    // 保存文件信息到数据库
    const upload = this.uploadRepository.create({
      filename: file.filename,
      originalName: file.originalname,
      mimetype: file.mimetype,
      size: file.size,
      path: file.path,
    });
    await this.uploadRepository.save(upload);

    return {
      code: 200,
      message: '上传成功',
      data: {
        id: upload.id,
        filename: upload.filename,
        originalName: upload.originalName,
        mimetype: upload.mimetype,
        size: upload.size,
        url: `/uploads/${upload.filename}`, // 文件访问URL
      },
    };
  }

  // 上传多文件
  async uploadFiles(files: Express.Multer.File[]): Promise<any> {
    const uploads = [];
    for (const file of files) {
      const upload = await this.uploadFile(file);
      uploads.push(upload.data);
    }

    return {
      code: 200,
      message: '上传成功',
      data: uploads,
    };
  }
}
```

### 3.3 创建上传实体

```typescript
// src/module/upload/entities/upload.entity.ts
// 文件上传实体，首次出现，详细注释说明
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn } from 'typeorm';

@Entity('uploads')
export class Upload {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ length: 255, comment: '文件名' })
  filename: string;

  @Column({ length: 255, comment: '原始文件名' })
  originalName: string;

  @Column({ length: 100, comment: '文件类型' })
  mimetype: string;

  @Column({ comment: '文件大小（字节）' })
  size: number;

  @Column({ length: 255, comment: '文件路径' })
  path: string;

  @CreateDateColumn({ comment: '上传时间' })
  createdAt: Date;
}
```

### 3.4 配置静态资源访问

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { join } from 'path';
import { NestExpressApplication } from '@nestjs/platform-express';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);
  
  // 配置静态资源访问
  app.useStaticAssets(join(__dirname, '..', 'uploads'), {
    prefix: '/uploads/', // 访问前缀
  });
  
  await app.listen(3000);
}
bootstrap();
```

## 4. 大文件切片上传

### 4.1 实现思路

大文件上传容易出现超时、失败等问题，使用切片上传可以解决这些问题：

1. 将大文件分割成多个小切片
2. 逐个上传切片
3. 服务端接收切片并保存
4. 所有切片上传完成后，服务端合并切片

### 4.2 安装 TUS 协议支持

```bash
# 安装 TUS 协议支持
npm install tus-node-server @nestjs/platform-socket.io
```

### 4.3 配置 TUS 服务器

```typescript
// src/module/upload/tus.controller.ts
// TUS 上传控制器，首次出现，详细注释说明
import { Controller, Get, Post, Res, Req } from '@nestjs/common';
import { IncomingMessage, ServerResponse } from 'http';
import { TusServer } from 'tus-node-server';
import { join } from 'path';

@Controller('tus')
export class TusController {
  private tusServer: TusServer;

  constructor() {
    this.tusServer = new TusServer({
      server: {
        path: '/api/tus/files', // TUS 服务路径
      },
      datastore: {
        path: join(__dirname, '..', '..', '..', 'uploads'), // 文件存储路径
      },
    });
  }

  @Post('*')
  @Get('*')
  handleTusRequests(@Req() req: IncomingMessage, @Res() res: ServerResponse) {
    return this.tusServer.handle(req, res);
  }
}
```

### 4.4 前端实现切片上传

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>大文件切片上传</title>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body>
  <input type="file" id="fileInput">
  <button id="uploadBtn">上传</button>
  <div id="progress"></div>
  <div id="status"></div>

  <script>
    const chunkSize = 1024 * 1024; // 1MB 切片大小
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const progress = document.getElementById('progress');
    const status = document.getElementById('status');

    uploadBtn.addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (!file) return;

      const fileId = Date.now() + '-' + Math.round(Math.random() * 1e9);
      const totalChunks = Math.ceil(file.size / chunkSize);
      let uploadedChunks = 0;

      status.textContent = `开始上传：${file.name}`;

      // 上传所有切片
      for (let i = 0; i < totalChunks; i++) {
        const start = i * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        const chunk = file.slice(start, end);

        await uploadChunk(chunk, i, totalChunks, fileId, file.name, file.type);
        uploadedChunks++;
        
        // 更新进度
        const progressPercent = Math.round((uploadedChunks / totalChunks) * 100);
        progress.textContent = `上传进度：${progressPercent}%`;
      }

      // 合并切片
      await mergeChunks(fileId, totalChunks, file.name, file.type);
      status.textContent = `上传完成：${file.name}`;
    });

    async function uploadChunk(chunk, chunkIndex, totalChunks, fileId, fileName, fileType) {
      const formData = new FormData();
      formData.append('file', chunk);
      formData.append('chunkIndex', chunkIndex);
      formData.append('totalChunks', totalChunks);
      formData.append('fileId', fileId);
      formData.append('fileName', fileName);
      formData.append('fileType', fileType);

      await axios.post('/api/upload/chunk', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
    }

    async function mergeChunks(fileId, totalChunks, fileName, fileType) {
      await axios.post('/api/upload/merge', {
        fileId,
        totalChunks,
        fileName,
        fileType,
      });
    }
  </script>
</body>
</html>
```

### 4.5 服务端实现切片合并

```typescript
// src/module/upload/upload.controller.ts
@Controller('upload')
export class UploadController {
  // 其他方法...

  @ApiOperation({ summary: '上传文件切片' })
  @ApiResponse({ status: 200, description: '上传成功' })
  @ApiResponse({ status: 400, description: '上传失败' })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(FileInterceptor('file'))
  @Post('chunk')
  async uploadChunk(
    @UploadedFile() file: Express.Multer.File,
    @Body() body: { chunkIndex: string; totalChunks: string; fileId: string; fileName: string; fileType: string },
  ) {
    return await this.uploadService.uploadChunk(file, body);
  }

  @ApiOperation({ summary: '合并文件切片' })
  @ApiResponse({ status: 200, description: '合并成功' })
  @ApiResponse({ status: 400, description: '合并失败' })
  @Post('merge')
  async mergeChunks(@Body() body: { fileId: string; totalChunks: string; fileName: string; fileType: string }) {
    return await this.uploadService.mergeChunks(body);
  }
}
```

```typescript
// src/module/upload/upload.service.ts
import { Injectable } from '@nestjs/common';
import { writeFileSync, mkdirSync, existsSync, createWriteStream, readFileSync } from 'fs';
import { join } from 'path';

@Injectable()
export class UploadService {
  // 其他方法...

  // 上传文件切片
  async uploadChunk(file: Express.Multer.File, body: { chunkIndex: string; totalChunks: string; fileId: string; fileName: string; fileType: string }) {
    const { chunkIndex, fileId } = body;
    const chunksPath = join(__dirname, '..', '..', '..', 'uploads', 'chunks', fileId);
    
    // 确保切片目录存在
    if (!existsSync(chunksPath)) {
      mkdirSync(chunksPath, { recursive: true });
    }
    
    // 保存切片
    const chunkPath = join(chunksPath, `${chunkIndex}`);
    writeFileSync(chunkPath, file.buffer);
    
    return {
      code: 200,
      message: '切片上传成功',
    };
  }

  // 合并文件切片
  async mergeChunks(body: { fileId: string; totalChunks: string; fileName: string; fileType: string }) {
    const { fileId, totalChunks, fileName } = body;
    const chunksPath = join(__dirname, '..', '..', '..', 'uploads', 'chunks', fileId);
    const filePath = join(__dirname, '..', '..', '..', 'uploads', `${fileId}-${fileName}`);
    
    // 创建写入流
    const writeStream = createWriteStream(filePath);
    
    // 合并切片
    for (let i = 0; i < parseInt(totalChunks); i++) {
      const chunkPath = join(chunksPath, `${i}`);
      const chunkData = readFileSync(chunkPath);
      writeStream.write(chunkData);
    }
    
    writeStream.end();
    
    // 保存文件信息到数据库
    const upload = this.uploadRepository.create({
      filename: `${fileId}-${fileName}`,
      originalName: fileName,
      mimetype: body.fileType,
      size: writeStream.bytesWritten,
      path: filePath,
    });
    await this.uploadRepository.save(upload);
    
    return {
      code: 200,
      message: '文件合并成功',
      data: {
        id: upload.id,
        filename: upload.filename,
        originalName: upload.originalName,
        mimetype: upload.mimetype,
        size: upload.size,
        url: `/uploads/${upload.filename}`,
      },
    };
  }
}
```

## 5. 文件处理

### 5.1 图片处理

使用 `sharp` 库处理图片：

```bash
# 安装 sharp 库
npm install sharp
```

```typescript
// src/module/upload/upload.service.ts
import * as sharp from 'sharp';

@Injectable()
export class UploadService {
  // 其他方法...

  // 处理图片
  async processImage(file: Express.Multer.File): Promise<any> {
    // 生成缩略图
    const thumbnailPath = join(__dirname, '..', '..', '..', 'uploads', `thumbnail-${file.filename}`);
    await sharp(file.path)
      .resize(200, 200, { fit: 'cover' })
      .toFile(thumbnailPath);
    
    // 生成 WebP 格式
    const webpPath = join(__dirname, '..', '..', '..', 'uploads', `${file.filename.replace(/\.(jpe?g|png|gif)$/i, '')}.webp`);
    await sharp(file.path)
      .webp({ quality: 80 })
      .toFile(webpPath);
    
    return {
      original: `/uploads/${file.filename}`,
      thumbnail: `/uploads/thumbnail-${file.filename}`,
      webp: `/uploads/${file.filename.replace(/\.(jpe?g|png|gif)$/i, '')}.webp`,
    };
  }
}
```

### 5.2 文件压缩

使用 `archiver` 库压缩文件：

```bash
# 安装 archiver 库
npm install archiver
```

```typescript
// src/module/upload/upload.service.ts
import * as archiver from 'archiver';

@Injectable()
export class UploadService {
  // 其他方法...

  // 压缩文件
  async compressFiles(files: string[]): Promise<string> {
    const archivePath = join(__dirname, '..', '..', '..', 'uploads', `archive-${Date.now()}.zip`);
    const output = createWriteStream(archivePath);
    const archive = archiver('zip', { zlib: { level: 9 } });
    
    output.on('close', () => {
      console.log(`Archive created: ${archivePath}`);
    });
    
    archive.on('error', (err) => {
      throw err;
    });
    
    archive.pipe(output);
    
    // 添加文件到压缩包
    for (const file of files) {
      archive.file(file, { name: file.split('/').pop() });
    }
    
    await archive.finalize();
    
    return `/uploads/${archivePath.split('/').pop()}`;
  }
}
```

## 6. 最佳实践

1. **限制文件大小**：防止恶意上传大文件占用服务器空间
2. **限制文件类型**：只允许上传安全的文件类型
3. **使用唯一文件名**：避免文件名冲突
4. **保存文件信息到数据库**：便于管理和查询
5. **配置静态资源访问**：方便前端访问上传的文件
6. **大文件使用切片上传**：提高上传成功率
7. **添加上传进度反馈**：提升用户体验
8. **定期清理过期文件**：释放服务器空间
9. **使用 CDN 加速**：提高文件访问速度
10. **添加文件校验**：确保文件完整性

## 7. 常见问题

### 7.1 文件上传超时

**问题**：上传大文件时出现超时错误。

**解决方案**：
1. 增加服务器超时时间
2. 使用切片上传
3. 优化网络环境

### 7.2 文件类型验证失败

**问题**：上传的文件类型明明符合要求，但验证失败。

**解决方案**：
1. 同时验证文件扩展名和 MIME 类型
2. 定期更新允许的文件类型列表

### 7.3 静态资源无法访问

**问题**：上传的文件无法通过 URL 访问。

**解决方案**：
1. 检查是否正确配置了静态资源访问
2. 检查文件路径是否正确
3. 检查文件权限是否正确

### 7.4 切片合并失败

**问题**：所有切片都上传成功，但合并失败。

**解决方案**：
1. 检查切片数量是否正确
2. 检查切片顺序是否正确
3. 检查文件权限是否正确
4. 检查磁盘空间是否足够

## 8. 安全考虑

1. **文件类型白名单**：只允许上传安全的文件类型
2. **文件大小限制**：防止 DOS 攻击
3. **文件内容检查**：使用杀毒软件或安全库检查文件内容
4. **防止路径遍历**：确保上传的文件不会被保存到敏感目录
5. **使用 HTTPS**：保护文件传输安全
6. **访问控制**：对敏感文件添加访问权限控制
7. **定期备份**：定期备份上传的文件
8. **日志记录**：记录文件上传和访问日志
