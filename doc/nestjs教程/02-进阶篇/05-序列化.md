# 序列化

序列化是将对象转换为可以传输或存储的格式（如JSON）的过程，反序列化则是将传输或存储的格式转换回对象的过程。在NestJS中，序列化是API开发中的重要环节，用于控制API响应中返回的数据结构和内容。

## 1. 序列化的概念

### 1.1 什么是序列化

序列化是指将内存中的对象转换为可以传输或存储的格式的过程。在API开发中，序列化主要用于：

- 控制API响应中返回的数据字段
- 格式化数据，使其符合特定的规范
- 保护敏感数据，防止泄露
- 优化数据传输，减少数据大小

### 1.2 为什么需要序列化

在实际开发中，我们经常需要：

- 从数据库查询到的实体对象包含很多字段，但API只需要返回部分字段
- 隐藏敏感字段，如密码、token等
- 格式化数据，如日期格式、数字格式等
- 转换数据结构，如将嵌套对象转换为扁平结构

## 2. NestJS中的序列化

NestJS提供了强大的序列化支持，主要通过装饰器实现。

### 2.1 安装依赖

序列化功能是NestJS的核心功能，不需要额外安装依赖。

### 2.2 基本使用

NestJS使用`ClassSerializerInterceptor`拦截器来实现序列化，结合`@Exclude`、`@Expose`等装饰器来控制序列化行为。

#### 2.2.1 创建序列化装饰器

```typescript
// src/decorators/serialize.decorator.ts
import { applyDecorators, UseInterceptors } from '@nestjs/common';
import { ClassSerializerInterceptor } from '@nestjs/common/serializer';

// 创建序列化装饰器
export function Serialize() {
  return applyDecorators(
    UseInterceptors(ClassSerializerInterceptor),
  );
}
```

#### 2.2.2 在实体类中使用装饰器

```typescript
// src/entities/user.entity.ts
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';
import { Exclude, Expose } from 'class-transformer';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  @Expose()
  name: string;
  
  @Column()
  @Expose()
  email: string;
  
  @Column()
  @Exclude() // 排除密码字段，不返回给客户端
  password: string;
  
  @Column()
  @Expose()
  createdAt: Date;
  
  @Column()
  @Expose()
  updatedAt: Date;
  
  // 自定义序列化字段
  @Expose()
  get fullName() {
    return `${this.name}`;
  }
}
```

#### 2.2.3 在控制器中使用序列化

```typescript
// src/controllers/user.controller.ts
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { UserService } from '../services/user.service';
import { ClassSerializerInterceptor } from '@nestjs/common/serializer';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}
  
  // 使用序列化拦截器
  @UseInterceptors(ClassSerializerInterceptor)
  @Get()
  async getUsers() {
    return this.userService.getUsers();
  }
  
  // 使用自定义序列化装饰器
  @Serialize()
  @Get(':id')
  async getUserById(@Param('id') id: number) {
    return this.userService.getUserById(id);
  }
}
```

## 3. 常用序列化装饰器

### 3.1 @Exclude

用于排除特定字段，不返回给客户端。

```typescript
import { Exclude } from 'class-transformer';

@Entity()
export class User {
  // ...
  
  @Column()
  @Exclude()
  password: string;
  
  // ...
}
```

### 3.2 @Expose

用于暴露特定字段，或创建计算字段。

```typescript
import { Expose } from 'class-transformer';

@Entity()
export class User {
  // ...
  
  @Column()
  firstName: string;
  
  @Column()
  lastName: string;
  
  // 计算字段
  @Expose()
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
  
  // ...
}
```

### 3.3 @Transform

用于转换字段值，如格式化日期、转换数据类型等。

```typescript
import { Transform } from 'class-transformer';

@Entity()
export class User {
  // ...
  
  @Column()
  @Transform(({ value }) => value.toISOString())
  createdAt: Date;
  
  @Column()
  @Transform(({ value }) => value * 100) // 将数字乘以100
  score: number;
  
  // ...
}
```

### 3.4 @Type

用于指定嵌套对象的类型，确保正确序列化。

```typescript
import { Type } from 'class-transformer';

@Entity()
export class User {
  // ...
  
  @OneToMany(() => Post, post => post.user)
  @Type(() => Post)
  posts: Post[];
  
  // ...
}
```

## 4. 序列化策略

### 4.1 基于实体的序列化

直接在实体类上使用序列化装饰器，适用于简单的API响应。

```typescript
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  @Expose()
  name: string;
  
  @Column()
  @Exclude()
  password: string;
}
```

### 4.2 基于DTO的序列化

创建专门的DTO（数据传输对象）用于序列化，适用于复杂的API响应。

```typescript
// src/dtos/user-response.dto.ts
import { Expose, Transform } from 'class-transformer';

export class UserResponseDto {
  @Expose()
  id: number;
  
  @Expose()
  name: string;
  
  @Expose()
  email: string;
  
  @Expose()
  @Transform(({ value }) => value.toISOString())
  createdAt: Date;
  
  @Expose()
  @Transform(({ obj }) => `${obj.firstName} ${obj.lastName}`)
  fullName: string;
}
```

在服务中使用DTO：

```typescript
// src/services/user.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../entities/user.entity';
import { UserResponseDto } from '../dtos/user-response.dto';
import { plainToClass } from 'class-transformer';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}
  
  async getUsers(): Promise<UserResponseDto[]> {
    const users = await this.userRepository.find();
    // 将实体转换为DTO
    return users.map(user => plainToClass(UserResponseDto, user));
  }
}
```

### 4.3 动态序列化

根据不同的条件返回不同的序列化结果，适用于复杂的业务场景。

```typescript
// src/decorators/serialize.decorator.ts
import { applyDecorators, UseInterceptors } from '@nestjs/common';
import { ClassSerializerInterceptor } from '@nestjs/common/serializer';

export function Serialize(dto: any) {
  return applyDecorators(
    UseInterceptors(ClassSerializerInterceptor),
    // 可以在这里添加自定义逻辑
  );
}
```

## 5. 高级序列化技术

### 5.1 序列化组

使用序列化组可以根据不同的场景返回不同的字段。

```typescript
// src/entities/user.entity.ts
import { Exclude, Expose } from 'class-transformer';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  @Expose({ groups: ['basic', 'detailed'] })
  id: number;
  
  @Column()
  @Expose({ groups: ['basic', 'detailed'] })
  name: string;
  
  @Column()
  @Expose({ groups: ['detailed'] })
  email: string;
  
  @Column()
  @Exclude()
  password: string;
  
  @Column()
  @Expose({ groups: ['detailed'] })
  createdAt: Date;
}
```

在控制器中使用序列化组：

```typescript
// src/controllers/user.controller.ts
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { UserService } from '../services/user.service';
import { ClassSerializerInterceptor } from '@nestjs/common/serializer';
import { plainToClass } from 'class-transformer';
import { User } from '../entities/user.entity';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}
  
  @Get()
  async getUsers() {
    const users = await this.userService.getUsers();
    // 使用basic组
    return users.map(user => plainToClass(User, user, { groups: ['basic'] }));
  }
  
  @Get('detailed')
  async getDetailedUsers() {
    const users = await this.userService.getUsers();
    // 使用detailed组
    return users.map(user => plainToClass(User, user, { groups: ['detailed'] }));
  }
}
```

### 5.2 自定义序列化器

创建自定义序列化器，实现更复杂的序列化逻辑。

```typescript
// src/serializers/user.serializer.ts
import { Serializer, SerializationContext } from '@nestjs/common/serializer';

@Injectable()
export class UserSerializer implements Serializer {
  serialize(value: any, context: SerializationContext) {
    // 自定义序列化逻辑
    return {
      id: value.id,
      name: value.name,
      email: value.email,
      createdAt: value.createdAt.toISOString(),
      customField: 'custom-value',
    };
  }
}
```

### 5.3 序列化拦截器

创建自定义序列化拦截器，实现全局或局部的序列化逻辑。

```typescript
// src/interceptors/serialize.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { plainToClass } from 'class-transformer';

@Injectable()
export class SerializeInterceptor implements NestInterceptor {
  constructor(private readonly dto: any) {}
  
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map(data => {
        // 将数据转换为DTO
        return plainToClass(this.dto, data, {
          excludeExtraneousValues: true,
        });
      })
    );
  }
}
```

在控制器中使用自定义序列化拦截器：

```typescript
// src/controllers/user.controller.ts
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { UserService } from '../services/user.service';
import { SerializeInterceptor } from '../interceptors/serialize.interceptor';
import { UserResponseDto } from '../dtos/user-response.dto';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}
  
  @UseInterceptors(new SerializeInterceptor(UserResponseDto))
  @Get()
  async getUsers() {
    return this.userService.getUsers();
  }
}
```

## 6. 序列化最佳实践

### 6.1 使用DTO进行序列化

- 为每个API响应创建专门的DTO
- 分离实体和DTO，保持实体的纯净性
- 在DTO中定义明确的响应结构

### 6.2 保护敏感数据

- 始终排除敏感字段，如密码、token等
- 使用环境变量存储敏感配置
- 对敏感数据进行加密存储

### 6.3 优化API响应

- 只返回客户端需要的字段
- 避免返回过多的嵌套数据
- 使用分页减少单次返回的数据量

### 6.4 保持一致性

- 统一API响应格式
- 统一日期和数字格式
- 统一错误响应格式

### 6.5 测试序列化

- 测试不同场景下的序列化结果
- 测试敏感字段是否正确排除
- 测试自定义字段是否正确生成

## 7. 常见问题与解决方案

### 7.1 嵌套对象无法正确序列化

**问题**：嵌套对象没有正确序列化，只返回了ID。

**解决方案**：使用`@Type`装饰器指定嵌套对象的类型。

```typescript
@Entity()
export class User {
  // ...
  
  @OneToMany(() => Post, post => post.user)
  @Type(() => Post)
  posts: Post[];
  
  // ...
}
```

### 7.2 计算字段不返回

**问题**：使用`get`方法定义的计算字段没有返回。

**解决方案**：确保计算字段使用了`@Expose`装饰器。

```typescript
@Entity()
export class User {
  // ...
  
  @Expose()
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
  
  // ...
}
```

### 7.3 日期格式不正确

**问题**：日期字段返回的是日期对象，而不是字符串。

**解决方案**：使用`@Transform`装饰器格式化日期。

```typescript
@Entity()
export class User {
  // ...
  
  @Column()
  @Transform(({ value }) => value.toISOString())
  createdAt: Date;
  
  // ...
}
```

## 8. 总结

序列化是NestJS API开发中的重要环节，通过序列化可以：

1. 控制API响应中返回的数据字段
2. 保护敏感数据，防止泄露
3. 格式化数据，使其符合特定规范
4. 优化数据传输，减少数据大小

NestJS提供了强大的序列化支持，通过装饰器和拦截器可以轻松实现复杂的序列化逻辑。在实际开发中，建议使用DTO进行序列化，分离实体和响应结构，保持代码的可维护性和扩展性。

通过合理使用序列化技术，可以创建更加安全、高效、易用的API，提升用户体验和开发效率。