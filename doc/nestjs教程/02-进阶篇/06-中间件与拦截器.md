# 中间件与拦截器

## 1. 中间件 (Middleware)

中间件是在请求处理管道中执行的函数，可以访问请求对象、响应对象和下一个中间件函数。中间件可以用于日志记录、身份验证、错误处理等。

### 1.1 中间件的执行顺序

1. 客户端发送请求
2. 服务器接收请求
3. 中间件按顺序执行
4. 路由处理函数执行
5. 响应返回给客户端

### 1.2 创建中间件

```typescript
// src/common/middleware/logger.middleware.ts
// 日志中间件，首次出现，详细注释说明
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  private logger = new Logger('HTTP');

  use(req: Request, res: Response, next: NextFunction) {
    const { method, originalUrl, ip } = req;
    const startTime = Date.now();

    // 监听响应结束事件
    res.on('finish', () => {
      const { statusCode } = res;
      const responseTime = Date.now() - startTime;
      this.logger.log(`${method} ${originalUrl} ${statusCode} ${responseTime}ms - ${ip}`);
    });

    next(); // 调用下一个中间件
  }
}
```

### 1.3 注册中间件

#### 1.3.1 全局中间件

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { NestExpressApplication } from '@nestjs/platform-express';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);
  
  // 使用全局中间件
  app.use(new LoggerMiddleware().use);
  
  await app.listen(3000);
}
bootstrap();
```

#### 1.3.2 模块级中间件

```typescript
// src/app.module.ts
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { UsersModule } from './module/users/users.module';

@Module({
  imports: [UsersModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware) // 应用中间件
      .forRoutes('users'); // 为特定路由应用中间件
  }
}
```

#### 1.3.3 路由级中间件

```typescript
// src/app.module.ts
@Module({
  imports: [UsersModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes(
        { path: 'users', method: RequestMethod.GET }, // 特定路由和方法
        { path: 'users/:id', method: RequestMethod.PUT },
      );
  }
}
```

#### 1.3.4 排除路由

```typescript
// src/app.module.ts
@Module({
  imports: [UsersModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .exclude(
        { path: 'users/login', method: RequestMethod.POST }, // 排除特定路由
        { path: 'users/register', method: RequestMethod.POST },
      )
      .forRoutes('users');
  }
}
```

### 1.4 函数式中间件

```typescript
// src/common/middleware/logger.middleware.ts
// 函数式中间件，首次出现，详细注释说明
import { Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

const logger = new Logger('HTTP');

export function loggerMiddleware(req: Request, res: Response, next: NextFunction) {
  const { method, originalUrl, ip } = req;
  const startTime = Date.now();

  res.on('finish', () => {
    const { statusCode } = res;
    const responseTime = Date.now() - startTime;
    logger.log(`${method} ${originalUrl} ${statusCode} ${responseTime}ms - ${ip}`);
  });

  next();
}
```

注册函数式中间件：

```typescript
// src/app.module.ts
@Module({
  imports: [UsersModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(loggerMiddleware) // 使用函数式中间件
      .forRoutes('users');
  }
}
```

## 2. 拦截器 (Interceptor)

拦截器是NestJS的一个特性，允许在请求处理前后执行额外的逻辑。拦截器可以用于日志记录、响应格式化、异常处理、性能监控等。

### 2.1 拦截器的特性

- **在函数执行前后绑定额外逻辑**
- **转换函数返回的结果**
- **转换函数抛出的异常**
- **扩展基本函数行为**
- **根据特定条件重写函数**

### 2.2 创建拦截器

```typescript
// src/common/interceptor/api-result.interceptor.ts
// API 结果拦截器，首次出现，详细注释说明
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class ApiResultInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return {
          code: 200,
          message: 'success',
          data,
          timestamp: new Date().toISOString(),
        };
      }),
    );
  }
}
```

### 2.3 注册拦截器

#### 2.3.1 全局拦截器

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ApiResultInterceptor } from './common/interceptor/api-result.interceptor';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 注册全局拦截器
  app.useGlobalInterceptors(new ApiResultInterceptor());
  
  await app.listen(3000);
}
bootstrap();
```

#### 2.3.2 模块级拦截器

```typescript
// src/common/common.module.ts
import { Module, Global } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { ApiResultInterceptor } from './interceptor/api-result.interceptor';

@Global()
@Module({
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: ApiResultInterceptor,
    },
  ],
  exports: [],
})
export class CommonModule {}
```

#### 2.3.3 控制器级拦截器

```typescript
// src/module/users/users.controller.ts
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { ApiResultInterceptor } from '../../common/interceptor/api-result.interceptor';

@Controller('users')
@UseInterceptors(ApiResultInterceptor) // 控制器级拦截器
export class UsersController {
  // 控制器方法...
}
```

#### 2.3.4 方法级拦截器

```typescript
// src/module/users/users.controller.ts
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { ApiResultInterceptor } from '../../common/interceptor/api-result.interceptor';

@Controller('users')
export class UsersController {
  @Get()
  @UseInterceptors(ApiResultInterceptor) // 方法级拦截器
  findAll() {
    // 方法实现...
  }
}
```

### 2.4 日志记录拦截器

```typescript
// src/module/logger/logger.interceptor.ts
// 日志记录拦截器，首次出现，详细注释说明
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, Logger } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggerInterceptor implements NestInterceptor {
  private logger = new Logger('LoggerInterceptor');

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const { method, url, body } = context.switchToHttp().getRequest();
    const startTime = Date.now();

    return next.handle().pipe(
      tap((response) => {
        const responseTime = Date.now() - startTime;
        this.logger.log(
          `${method} ${url} ${responseTime}ms\n` +
          `Request Body: ${JSON.stringify(body)}\n` +
          `Response: ${JSON.stringify(response)}`,
        );
      }),
    );
  }
}
```

### 2.5 异常处理拦截器

```typescript
// src/common/interceptor/exception.interceptor.ts
// 异常处理拦截器，首次出现，详细注释说明
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, HttpException, HttpStatus } from '@nestjs/common';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable()
export class ExceptionInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      catchError((error) => {
        if (error instanceof HttpException) {
          return throwError(() => error);
        }

        // 统一处理其他异常
        return throwError(() => {
          return new HttpException(
            { message: error.message || '服务器内部错误', code: HttpStatus.INTERNAL_SERVER_ERROR },
            HttpStatus.INTERNAL_SERVER_ERROR,
          );
        });
      }),
    );
  }
}
```

## 3. 中间件 vs 拦截器

| 特性 | 中间件 | 拦截器 |
|------|--------|--------|
| 基于 | Express/Fastify | NestJS (RxJS) |
| 访问对象 | Request, Response, NextFunction | ExecutionContext, CallHandler |
| 执行时机 | 请求处理前/后 | 路由处理前/后，支持异步流处理 |
| 功能 | 日志、认证、CORS等 | 日志、响应格式化、异常处理、性能监控等 |
| 适用场景 | 全局请求处理 | 业务逻辑层面的拦截和处理 |
| 异步支持 | 支持 | 支持RxJS异步流 |

## 4. 管道 (Pipe)

管道用于数据转换和验证，可以将输入数据转换为所需格式，并验证数据的有效性。

### 4.1 创建管道

```typescript
// src/common/pipeTransform/filterEmptyPipe.ts
// 过滤空值管道，首次出现，详细注释说明
import { Injectable, PipeTransform, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class FilterEmptyPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if (metadata.type === 'body') {
      // 过滤掉空值和 undefined
      const filteredValue = Object.fromEntries(
        Object.entries(value).filter(([_, v]) => v !== '' && v !== undefined),
      );
      return filteredValue;
    }
    return value;
  }
}
```

### 4.2 使用管道

```typescript
// src/module/users/users.controller.ts
import { Controller, Post, Body, UsePipes } from '@nestjs/common';
import { FilterEmptyPipe } from '../../common/pipeTransform/filterEmptyPipe';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('users')
export class UsersController {
  @Post()
  @UsePipes(FilterEmptyPipe) // 方法级管道
  create(@Body() createUserDto: CreateUserDto) {
    // 方法实现...
  }
}
```

## 5. 过滤器 (Filter)

过滤器用于处理异常，可以捕获控制器和服务中抛出的异常，并返回统一的响应格式。

### 5.1 创建全局过滤器

```typescript
// src/common/filter/global-exception.filter.ts
// 全局异常过滤器，首次出现，详细注释说明
import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus, Logger } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private logger = new Logger('GlobalExceptionFilter');

  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status: HttpStatus;
    let message: string;
    let code: number;

    if (exception instanceof HttpException) {
      status = exception.getStatus() as HttpStatus;
      const exceptionResponse = exception.getResponse();
      if (typeof exceptionResponse === 'string') {
        message = exceptionResponse;
        code = status;
      } else {
        message = (exceptionResponse as any).message || '请求失败';
        code = (exceptionResponse as any).code || status;
      }
    } else {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = exception.message || '服务器内部错误';
      code = HttpStatus.INTERNAL_SERVER_ERROR;
    }

    // 记录异常日志
    this.logger.error(
      `[${request.method}] ${request.url} - ${status} - ${message}\n` +
      `Request Body: ${JSON.stringify(request.body)}\n` +
      `Stack: ${exception.stack}`,
    );

    // 返回统一的错误响应
    response.status(status).json({
      code,
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
    });
  }
}
```

### 5.2 注册全局过滤器

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { GlobalExceptionFilter } from './common/filter/global-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 注册全局过滤器
  app.useGlobalFilters(new GlobalExceptionFilter());
  
  await app.listen(3000);
}
bootstrap();
```

## 6. 守卫 (Guard)

守卫用于权限控制，可以根据请求上下文决定是否允许访问特定路由。

### 6.1 创建守卫

```typescript
// src/common/guards/roles.guard.ts
// 角色守卫，首次出现，详细注释说明
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorator/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    // 从路由中获取需要的角色
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    
    // 如果没有设置角色，则允许访问
    if (!requiredRoles) {
      return true;
    }
    
    // 从请求中获取用户信息
    const { user } = context.switchToHttp().getRequest();
    
    // 检查用户角色是否包含需要的角色
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
```

### 6.2 使用守卫

```typescript
// src/module/users/users.controller.ts
import { Controller, Get, UseGuards } from '@nestjs/common';
import { RolesGuard } from '../../common/guards/roles.guard';
import { Roles } from '../../common/decorator/roles.decorator';

@Controller('users')
@UseGuards(RolesGuard) // 控制器级守卫
export class UsersController {
  @Get('admin')
  @Roles('admin') // 需要 admin 角色
  getAdminUsers() {
    // 方法实现...
  }
}
```

## 7. 执行顺序

NestJS 中各种拦截机制的执行顺序如下：

1. 中间件 (Middleware)
2. 守卫 (Guard)
3. 管道 (Pipe)
4. 拦截器 (Interceptor) - 执行前
5. 控制器方法 (Controller Method)
6. 拦截器 (Interceptor) - 执行后
7. 过滤器 (Filter) - 异常处理

## 8. 最佳实践

1. **合理使用中间件和拦截器**：中间件适合全局请求处理，拦截器适合业务逻辑层面的处理
2. **统一响应格式**：使用拦截器统一响应格式，提高 API 一致性
3. **统一异常处理**：使用全局过滤器处理异常，返回统一的错误格式
4. **权限控制**：使用守卫进行权限控制，确保只有授权用户才能访问特定路由
5. **数据验证**：使用管道进行数据验证，确保输入数据的有效性
6. **日志记录**：使用中间件或拦截器记录请求和响应日志，便于调试和监控
7. **性能监控**：使用拦截器监控请求处理时间，便于性能分析
8. **分层设计**：根据功能需求选择合适的拦截机制，避免过度使用

## 9. 常见问题

### 9.1 中间件不执行

**问题**：中间件没有执行，请求直接到达路由处理函数。

**解决方案**：
1. 检查中间件是否正确注册
2. 检查路由路径是否匹配
3. 检查中间件是否调用了 `next()` 函数

### 9.2 拦截器不执行

**问题**：拦截器没有执行，响应没有被格式化。

**解决方案**：
1. 检查拦截器是否正确注册
2. 检查是否使用了 `@UseInterceptors()` 装饰器
3. 检查拦截器是否返回了 `next.handle()`

### 9.3 全局过滤器不生效

**问题**：全局过滤器没有捕获异常，响应格式不一致。

**解决方案**：
1. 检查过滤器是否正确注册
2. 检查过滤器是否使用了 `@Catch()` 装饰器
3. 检查是否在过滤器中调用了 `response.status().json()`

### 9.4 执行顺序问题

**问题**：拦截机制的执行顺序不符合预期。

**解决方案**：
1. 了解 NestJS 中各种拦截机制的执行顺序
2. 合理安排不同拦截机制的使用
3. 避免在多个拦截机制中重复处理相同的逻辑

## 10. 总结

中间件、拦截器、管道、守卫和过滤器是 NestJS 中重要的拦截机制，它们共同构成了 NestJS 的请求处理管道。合理使用这些拦截机制可以提高代码的可维护性、可扩展性和安全性。在实际应用中，我们需要根据功能需求选择合适的拦截机制，并遵循最佳实践，确保代码的质量和性能。
