# 部署策略

## 1. 部署前准备

### 1.1 环境配置

在部署应用之前，需要确保服务器环境满足以下要求：

- Node.js 18.x 或更高版本
- npm 或 yarn 包管理器
- Git 版本控制
- 数据库（MySQL、PostgreSQL 等）
- Web 服务器（Nginx、Apache 等，可选）
- SSL 证书（用于 HTTPS，可选）

### 1.2 构建应用

#### 1.2.1 安装依赖

```bash
npm install
```

#### 1.2.2 构建生产版本

```bash
npm run build
```

构建完成后，会在 `dist` 目录生成编译后的代码。

#### 1.2.3 配置环境变量

在服务器上创建 `.env` 文件，配置生产环境的环境变量：

```env
# .env.production
APP_PORT=8080
APP_ENV=production
DB_HOST=db.example.com
DB_PORT=3306
DB_USERNAME=prod_user
DB_PASSWORD=prod_password
DB_DATABASE=nest_demo_prod
DB_SYNCHRONIZE=false
DB_LOGGING=false
JWT_SECRET=your-secret-key
JWT_EXPIRES_IN=24h
```

## 2. 部署方式

### 2.1 直接部署

直接在服务器上运行应用，适合小型应用或测试环境。

#### 2.1.1 上传代码

使用 Git 或 FTP 将代码上传到服务器：

```bash
# 使用 Git 克隆代码
git clone https://github.com/your-username/your-project.git
cd your-project
```

#### 2.1.2 安装依赖并构建

```bash
npm install --production
npm run build
```

#### 2.1.3 启动应用

```bash
# 直接启动应用
node dist/main.js

# 使用 PM2 管理进程
npm install -g pm2
pm2 start dist/main.js --name nestjs-api
```

#### 2.1.4 配置 PM2

创建 `ecosystem.config.js` 文件：

```javascript
// ecosystem.config.js
module.exports = {
  apps: [
    {
      name: 'nestjs-api',
      script: 'dist/main.js',
      instances: 'max',
      exec_mode: 'cluster',
      env: {
        NODE_ENV: 'production',
      },
      env_production: {
        NODE_ENV: 'production',
      },
      log_date_format: 'YYYY-MM-DD HH:mm:ss',
      error_file: './logs/error.log',
      out_file: './logs/out.log',
      combine_logs: true,
      max_memory_restart: '1G',
    },
  ],
};
```

使用 PM2 启动应用：

```bash
pm2 start ecosystem.config.js --env production
```

### 2.2 Docker 部署

使用 Docker 容器化部署，适合生产环境，便于管理和扩展。

#### 2.2.1 创建 Dockerfile

```dockerfile
# Dockerfile
# 使用 Node.js 18 作为基础镜像
FROM node:18-alpine AS builder

# 设置工作目录
WORKDIR /app

# 复制 package.json 和 package-lock.json
COPY package*.json ./

# 安装依赖
RUN npm ci

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 使用 Node.js 18 作为运行时镜像
FROM node:18-alpine

# 设置工作目录
WORKDIR /app

# 复制构建产物和依赖
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/node_modules ./node_modules

# 暴露端口
EXPOSE 3000

# 设置环境变量
ENV NODE_ENV=production

# 启动应用
CMD ["node", "dist/main.js"]
```

#### 2.2.2 创建 docker-compose.yml

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    container_name: nestjs-api
    restart: unless-stopped
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - DB_HOST=db
      - DB_PORT=3306
      - DB_USERNAME=root
      - DB_PASSWORD=password
      - DB_DATABASE=nest_demo
    depends_on:
      - db
    volumes:
      - ./uploads:/app/uploads
      - ./.env:/app/.env

  db:
    image: mysql:8.0
    container_name: nestjs-db
    restart: unless-stopped
    ports:
      - '3306:3306'
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=nest_demo
    volumes:
      - mysql-data:/var/lib/mysql
      - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql

volumes:
  mysql-data:
    driver: local
```

#### 2.2.3 构建并运行 Docker 容器

```bash
# 构建镜像
docker-compose build

# 运行容器
docker-compose up -d
```

### 2.3 使用 Zeabur 部署

Zeabur 是一个现代化的云平台，支持一键部署 NestJS 应用。

#### 2.3.1 注册 Zeabur 账号

访问 [Zeabur](https://zeabur.com/) 注册账号。

#### 2.3.2 创建项目

在 Zeabur 控制台创建一个新的项目。

#### 2.3.3 部署应用

1. 选择 "部署服务"
2. 选择 "从 Git 仓库部署"
3. 连接你的 GitHub 账号
4. 选择要部署的仓库和分支
5. 配置环境变量
6. 点击 "部署"

#### 2.3.4 配置域名

在 Zeabur 控制台为应用配置自定义域名。

### 2.4 Kubernetes 部署

使用 Kubernetes 部署，适合大规模应用，提供高可用和自动扩展。

#### 2.4.1 创建 Deployment

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nestjs-api
  labels:
    app: nestjs-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nestjs-api
  template:
    metadata:
      labels:
        app: nestjs-api
    spec:
      containers:
        - name: nestjs-api
          image: your-registry/nestjs-api:latest
          ports:
            - containerPort: 3000
          envFrom:
            - secretRef:
                name: nestjs-api-secrets
          resources:
            limits:
              cpu: "1"
              memory: "1Gi"
            requests:
              cpu: "500m"
              memory: "512Mi"
```

#### 2.4.2 创建 Service

```yaml
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: nestjs-api-service
spec:
  selector:
    app: nestjs-api
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: LoadBalancer
```

#### 2.4.3 创建 Secret

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: nestjs-api-secrets
type: Opaque
stringData:
  DB_HOST: db.example.com
  DB_PORT: "3306"
  DB_USERNAME: prod_user
  DB_PASSWORD: prod_password
  DB_DATABASE: nest_demo_prod
  JWT_SECRET: your-secret-key
```

#### 2.4.4 部署到 Kubernetes

```bash
# 应用部署
tkubectl apply -f deployment.yaml
kubectl apply -f service.yaml
kubectl apply -f secret.yaml
```

## 3. 反向代理配置

使用 Nginx 或 Apache 作为反向代理，提供负载均衡、HTTPS 支持等功能。

### 3.1 Nginx 配置

创建 Nginx 配置文件：

```nginx
# /etc/nginx/conf.d/nestjs-api.conf
server {
    listen 80;
    server_name api.example.com;

    # 重定向到 HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.example.com;

    # SSL 证书配置
    ssl_certificate /path/to/your/certificate.crt;
    ssl_certificate_key /path/to/your/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # 代理配置
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # WebSocket 支持
    location /socket.io {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # 静态资源配置
    location /uploads {
        alias /path/to/your/uploads;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }
}
```

### 3.2 Apache 配置

创建 Apache 配置文件：

```apache
# /etc/apache2/sites-available/nestjs-api.conf
<VirtualHost *:80>
    ServerName api.example.com
    Redirect permanent / https://api.example.com/
</VirtualHost>

<VirtualHost *:443>
    ServerName api.example.com

    # SSL 证书配置
    SSLEngine on
    SSLCertificateFile /path/to/your/certificate.crt
    SSLCertificateKeyFile /path/to/your/private.key

    # 代理配置
    ProxyPreserveHost On
    ProxyPass / http://localhost:3000/
    ProxyPassReverse / http://localhost:3000/

    # WebSocket 支持
    RewriteEngine on
    RewriteCond %{HTTP:Upgrade} =websocket [NC]
    RewriteRule /(.*) ws://localhost:3000/$1 [P,L]
    RewriteCond %{HTTP:Upgrade} !=websocket [NC]
    RewriteRule /(.*) http://localhost:3000/$1 [P,L]

    # 静态资源配置
    Alias /uploads /path/to/your/uploads
    <Directory /path/to/your/uploads>
        AllowOverride None
        Require all granted
        ExpiresActive On
        ExpiresDefault "access plus 30 days"
        Header set Cache-Control "public, immutable"
    </Directory>
</VirtualHost>
```

## 4. 数据库部署

### 4.1 MySQL 部署

#### 4.1.1 使用 Docker 部署 MySQL

```bash
docker run -d \
  --name mysql \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=password \
  -e MYSQL_DATABASE=nest_demo \
  -v mysql-data:/var/lib/mysql \
  mysql:8.0
```

#### 4.1.2 配置 MySQL

创建用户和数据库：

```sql
-- 创建数据库
CREATE DATABASE IF NOT EXISTS nest_demo_prod CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 创建用户
CREATE USER IF NOT EXISTS 'prod_user'@'%' IDENTIFIED BY 'prod_password';

-- 授予权限
GRANT ALL PRIVILEGES ON nest_demo_prod.* TO 'prod_user'@'%';

-- 刷新权限
FLUSH PRIVILEGES;
```

### 4.2 PostgreSQL 部署

#### 4.2.1 使用 Docker 部署 PostgreSQL

```bash
docker run -d \
  --name postgres \
  -p 5432:5432 \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_DB=nest_demo \
  -v postgres-data:/var/lib/postgresql/data \
  postgres:15
```

#### 4.2.2 配置 PostgreSQL

创建用户和数据库：

```sql
-- 创建用户
CREATE USER prod_user WITH PASSWORD 'prod_password';

-- 创建数据库
CREATE DATABASE nest_demo_prod OWNER prod_user;

-- 授予权限
GRANT ALL PRIVILEGES ON DATABASE nest_demo_prod TO prod_user;
```

## 5. 监控与日志

### 5.1 应用监控

#### 5.1.1 使用 PM2 监控

```bash
# 查看应用状态
pm2 status

# 查看应用日志
pm2 logs

# 查看应用详情
pm2 show nestjs-api

# 监控应用资源使用情况
pm2 monit
```

#### 5.1.2 使用 Prometheus 和 Grafana

1. 安装 Prometheus 和 Grafana
2. 配置 Prometheus 采集应用指标
3. 在 Grafana 中创建监控面板

### 5.2 日志管理

#### 5.2.1 使用 Winston 日志库

安装 Winston：

```bash
npm install winston winston-daily-rotate-file
```

配置 Winston：

```typescript
// src/config/logger.ts
import { createLogger, transports, format } from 'winston';
import 'winston-daily-rotate-file';
import { join } from 'path';

const logDir = join(process.cwd(), 'logs');

const logger = createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: format.combine(
    format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss',
    }),
    format.errors({ stack: true }),
    format.splat(),
    format.json(),
  ),
  defaultMeta: { service: 'nestjs-api' },
  transports: [
    // 控制台日志
    new transports.Console({
      format: format.combine(
        format.colorize(),
        format.simple(),
      ),
    }),
    // 错误日志文件
    new transports.DailyRotateFile({
      filename: `${logDir}/error-%DATE%.log`,
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      level: 'error',
    }),
    // 所有日志文件
    new transports.DailyRotateFile({
      filename: `${logDir}/combined-%DATE%.log`,
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
    }),
  ],
});

export default logger;
```

#### 5.2.2 使用 ELK Stack

ELK Stack（Elasticsearch、Logstash、Kibana）用于集中管理和分析日志。

1. 安装 ELK Stack
2. 配置 Logstash 采集应用日志
3. 在 Kibana 中查看和分析日志

## 6. 性能优化

### 6.1 应用优化

1. **使用集群模式**：使用 PM2 或 Kubernetes 集群模式，充分利用多核 CPU
2. **启用压缩**：使用 Gzip 或 Brotli 压缩响应数据
3. **启用缓存**：使用 Redis 或其他缓存机制缓存频繁访问的数据
4. **优化数据库查询**：添加索引，优化查询语句
5. **使用异步操作**：避免阻塞主线程
6. **减少依赖**：只安装生产环境必需的依赖
7. **使用静态资源 CDN**：将静态资源托管到 CDN
8. **启用 HTTP/2**：提高传输效率

### 6.2 Nginx 优化

```nginx
# /etc/nginx/nginx.conf
http {
    # 启用 Gzip 压缩
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    gzip_proxied any;
    gzip_min_length 1024;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;

    # 启用 HTTP/2
    listen 443 ssl http2;

    # 配置连接超时
    keepalive_timeout 65;
    keepalive_requests 100;

    # 配置缓冲区
    client_body_buffer_size 16k;
    client_header_buffer_size 1k;
    large_client_header_buffers 4 4k;

    # 配置 worker 进程数
    worker_processes auto;
    worker_connections 1024;
}
```

## 7. 安全配置

### 7.1 SSL/TLS 配置

1. 获取 SSL 证书（使用 Let's Encrypt 或其他证书颁发机构）
2. 配置 Nginx 或 Apache 使用 SSL 证书
3. 启用 HTTP 严格传输安全（HSTS）
4. 配置 SSL 协议和密码套件

### 7.2 应用安全

1. **使用环境变量存储敏感信息**：避免硬编码敏感配置
2. **启用 CORS**：限制跨域请求
3. **使用 JWT 认证**：确保 API 安全
4. **输入验证**：使用管道验证输入数据
5. **防止 SQL 注入**：使用 ORM 或参数化查询
6. **防止 XSS 攻击**：对输出进行转义
7. **防止 CSRF 攻击**：使用 CSRF 令牌
8. **定期更新依赖**：修复安全漏洞

### 7.3 服务器安全

1. **配置防火墙**：限制访问端口
2. **使用 SSH 密钥登录**：禁用密码登录
3. **定期更新系统**：修复安全漏洞
4. **配置 SELinux 或 AppArmor**：增强系统安全性
5. **监控服务器日志**：及时发现异常

## 8. 自动化部署

### 8.1 使用 GitHub Actions

创建 `.github/workflows/deploy.yml` 文件：

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build application
        run: npm run build
      
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          password: ${{ secrets.SERVER_PASSWORD }}
          script: |
            cd /path/to/your/project
            git pull origin main
            npm install --production
            npm run build
            pm2 restart nestjs-api
```

### 8.2 使用 Jenkins

1. 安装 Jenkins
2. 创建 Jenkins 任务
3. 配置源代码管理
4. 配置构建步骤
5. 配置部署步骤

## 9. 部署后检查

部署完成后，需要进行以下检查：

1. **应用是否正常运行**：访问应用 URL，检查是否能正常访问
2. **API 是否正常响应**：使用 Postman 或 curl 测试 API
3. **数据库连接是否正常**：检查应用日志，确认数据库连接正常
4. **监控是否正常**：检查监控面板，确认应用资源使用正常
5. **日志是否正常**：检查应用日志，确认没有错误
6. **安全配置是否生效**：使用 SSL Labs 测试 SSL 配置

## 10. 常见问题

### 10.1 应用启动失败

**问题**：应用启动失败，日志显示错误信息。

**解决方案**：
1. 检查环境变量是否正确配置
2. 检查数据库连接是否正常
3. 检查端口是否被占用
4. 检查依赖是否正确安装
5. 检查日志文件，查看详细错误信息

### 10.2 API 响应缓慢

**问题**：API 响应缓慢，用户体验差。

**解决方案**：
1. 优化数据库查询，添加索引
2. 启用缓存，减少数据库访问
3. 使用集群模式，提高并发处理能力
4. 优化应用代码，减少不必要的计算
5. 配置 CDN，加速静态资源访问

### 10.3 SSL 证书过期

**问题**：SSL 证书过期，浏览器显示安全警告。

**解决方案**：
1. 续订 SSL 证书
2. 更新 Nginx 或 Apache 配置
3. 重启 Web 服务器

### 10.4 数据库连接超时

**问题**：应用无法连接到数据库，显示连接超时错误。

**解决方案**：
1. 检查数据库服务是否正常运行
2. 检查数据库连接配置是否正确
3. 检查网络连接是否正常
4. 检查数据库防火墙配置
5. 增加数据库连接超时时间

## 11. 总结

部署是应用开发的重要环节，需要考虑多种因素，包括环境配置、部署方式、反向代理、数据库部署、监控与日志、性能优化、安全配置等。选择合适的部署策略，可以提高应用的可用性、可靠性和安全性。在实际部署过程中，需要根据应用的规模和需求，选择合适的部署方案，并进行充分的测试和监控，确保应用能够稳定运行。
