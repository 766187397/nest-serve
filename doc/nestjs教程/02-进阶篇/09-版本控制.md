# 版本控制

API版本控制是API设计中的重要环节，用于管理API的演进和兼容性。随着业务需求的变化，API会不断更新和迭代，版本控制可以确保不同版本的API同时存在，互不影响，从而保护现有客户端的利益。

## 1. 版本控制的概念

### 1.1 什么是API版本控制

API版本控制是指在API设计中引入版本标识，使得不同版本的API可以同时存在和运行，客户端可以根据需要选择调用不同版本的API。

### 1.2 为什么需要版本控制

- **兼容性**：确保旧版本客户端继续工作，不被强制升级
- **演进性**：允许API不断演进和改进，同时保持向后兼容
- **稳定性**：降低API变更对现有系统的影响
- **可测试性**：可以独立测试不同版本的API
- **可维护性**：便于管理和维护不同版本的API

### 1.3 版本控制的常见策略

1. **URI路径版本控制**：将版本号放在URI路径中，如 `/api/v1/users`
2. **查询参数版本控制**：将版本号作为查询参数，如 `/api/users?version=1`
3. **HTTP头版本控制**：将版本号放在HTTP头中，如 `Accept-Version: v1`
4. **媒体类型版本控制**：将版本号放在Accept头的媒体类型中，如 `Accept: application/vnd.example.v1+json`

## 2. NestJS中的版本控制

NestJS提供了内置的版本控制支持，可以轻松实现各种版本控制策略。

### 2.1 安装依赖

版本控制功能是NestJS的核心功能，不需要额外安装依赖。

### 2.2 基本配置

首先，在应用模块中配置版本控制策略：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { VersioningModule } from '@nestjs/common/versioning';

@Module({
  imports: [
    VersioningModule.forRoot({
      type: 'uri', // 使用URI路径版本控制
      defaultVersion: '1', // 默认版本
      prefix: 'v', // 版本前缀
    }),
    // 其他模块
  ],
})
export class AppModule {}
```

### 2.3 版本控制类型

NestJS支持以下版本控制类型：

1. **URI路径版本控制**（`type: 'uri'`）
2. **查询参数版本控制**（`type: 'query'`）
3. **HTTP头版本控制**（`type: 'header'`）
4. **媒体类型版本控制**（`type: 'media-type'`）

#### 2.3.1 URI路径版本控制

将版本号放在URI路径中，这是最常用的版本控制策略。

```typescript
// src/app.module.ts
@Module({
  imports: [
    VersioningModule.forRoot({
      type: 'uri',
      defaultVersion: '1',
      prefix: 'v',
    }),
  ],
})
export class AppModule {}
```

在控制器中使用版本控制：

```typescript
// src/controllers/user.controller.ts
import { Controller, Get, Version } from '@nestjs/common';

@Controller('users')
export class UserController {
  // 版本v1
  @Version('1')
  @Get()
  async getUsersV1() {
    return {
      version: 'v1',
      data: [{ id: 1, name: '张三' }],
    };
  }
  
  // 版本v2
  @Version('2')
  @Get()
  async getUsersV2() {
    return {
      version: 'v2',
      data: [{ id: 1, name: '张三', email: 'zhangsan@example.com' }],
    };
  }
}
```

客户端访问方式：
- v1版本：`GET /v1/users`
- v2版本：`GET /v2/users`

#### 2.3.2 查询参数版本控制

将版本号作为查询参数。

```typescript
// src/app.module.ts
@Module({
  imports: [
    VersioningModule.forRoot({
      type: 'query',
      defaultVersion: '1',
      parameter: 'version', // 查询参数名称
    }),
  ],
})
export class AppModule {}
```

客户端访问方式：
- v1版本：`GET /users?version=1`
- v2版本：`GET /users?version=2`

#### 2.3.3 HTTP头版本控制

将版本号放在HTTP头中。

```typescript
// src/app.module.ts
@Module({
  imports: [
    VersioningModule.forRoot({
      type: 'header',
      defaultVersion: '1',
      header: 'Accept-Version', // HTTP头名称
    }),
  ],
})
export class AppModule {}
```

客户端访问方式：
```
GET /users
Accept-Version: v1
```

#### 2.3.4 媒体类型版本控制

将版本号放在Accept头的媒体类型中。

```typescript
// src/app.module.ts
@Module({
  imports: [
    VersioningModule.forRoot({
      type: 'media-type',
      defaultVersion: '1',
      key: 'v', // 媒体类型中的版本键
    }),
  ],
})
export class AppModule {}
```

客户端访问方式：
```
GET /users
Accept: application/vnd.example.v1+json
```

## 3. 版本控制的高级用法

### 3.1 控制器级别的版本控制

可以在控制器级别设置默认版本，然后在方法级别覆盖：

```typescript
// src/controllers/user.controller.ts
import { Controller, Get, Version } from '@nestjs/common';

@Controller('users')
@Version('1') // 控制器默认版本v1
export class UserController {
  // 使用控制器默认版本v1
  @Get()
  async getUsers() {
    return { version: 'v1', data: [{ id: 1, name: '张三' }] };
  }
  
  // 覆盖为v2版本
  @Version('2')
  @Get('v2')
  async getUsersV2() {
    return { version: 'v2', data: [{ id: 1, name: '张三', email: 'zhangsan@example.com' }] };
  }
}
```

### 3.2 多版本支持

一个路由可以支持多个版本：

```typescript
// src/controllers/user.controller.ts
@Controller('users')
export class UserController {
  // 支持v1和v2版本
  @Version(['1', '2'])
  @Get()
  async getUsers() {
    return { data: [{ id: 1, name: '张三' }] };
  }
}
```

### 3.3 版本范围

可以使用版本范围来匹配多个版本：

```typescript
// src/controllers/user.controller.ts
@Controller('users')
export class UserController {
  // 支持v1到v3版本
  @Version('^1') // 匹配v1.x版本
  @Get()
  async getUsers() {
    return { data: [{ id: 1, name: '张三' }] };
  }
}
```

### 3.4 自定义版本解析器

可以创建自定义版本解析器，实现更复杂的版本匹配逻辑：

```typescript
// src/versioning/custom-version-resolver.ts
import { VersionValue, VersionResolver } from '@nestjs/common/versioning';

// 自定义版本解析器
export class CustomVersionResolver implements VersionResolver {
  resolve(version: string): VersionValue {
    // 自定义版本解析逻辑
    if (version === 'latest') {
      return '2'; // 最新版本为v2
    }
    return version;
  }
}
```

在配置中使用自定义版本解析器：

```typescript
// src/app.module.ts
@Module({
  imports: [
    VersioningModule.forRoot({
      type: 'uri',
      defaultVersion: '1',
      prefix: 'v',
      resolver: new CustomVersionResolver(),
    }),
  ],
})
export class AppModule {}
```

## 4. 版本控制最佳实践

### 4.1 选择合适的版本控制策略

- **URI路径版本控制**：最常用，直观易用，适合大多数场景
- **查询参数版本控制**：适合简单的API，版本切换灵活
- **HTTP头版本控制**：适合RESTful API，保持URI简洁
- **媒体类型版本控制**：适合复杂的API，支持内容协商

### 4.2 版本号命名规范

- 使用语义化版本号：`v1.0.0`
- 主要版本号变更：不兼容的API变更
- 次要版本号变更：向后兼容的功能性新增
- 补丁版本号变更：向后兼容的问题修复

### 4.3 版本管理

- 保持版本的稳定性：每个版本应保持稳定，避免频繁变更
- 提供版本迁移指南：帮助用户从旧版本迁移到新版本
- 设定版本生命周期：明确每个版本的支持期限
- 定期清理旧版本：及时移除不再支持的旧版本

### 4.4 API设计

- 保持API的一致性：同一版本的API应保持一致的设计风格
- 提供完整的API文档：每个版本都应有对应的文档
- 使用DTO分离不同版本的响应：为每个版本创建专门的DTO
- 实现优雅降级：新版本API应兼容旧版本的客户端

### 4.5 测试

- 测试不同版本的API：确保每个版本都能正常工作
- 测试版本切换：确保客户端可以正确切换不同版本
- 测试向后兼容性：确保新版本不破坏旧版本的功能

## 5. 版本控制示例

### 5.1 URI路径版本控制示例

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { VersioningModule } from '@nestjs/common/versioning';
import { UserModule } from './modules/user/user.module';

@Module({
  imports: [
    VersioningModule.forRoot({
      type: 'uri',
      defaultVersion: '1',
      prefix: 'v',
    }),
    UserModule,
  ],
})
export class AppModule {}

// src/modules/user/user.module.ts
import { Module } from '@nestjs/common';
import { UserController } from './user.controller';
import { UserService } from './user.service';

@Module({
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}

// src/modules/user/user.controller.ts
import { Controller, Get, Post, Body, Param, Version } from '@nestjs/common';
import { UserService } from './user.service';
import { CreateUserDtoV1 } from './dto/create-user-v1.dto';
import { CreateUserDtoV2 } from './dto/create-user-v2.dto';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}
  
  // v1版本：创建用户
  @Version('1')
  @Post()
  async createUserV1(@Body() createUserDto: CreateUserDtoV1) {
    return this.userService.createUserV1(createUserDto);
  }
  
  // v2版本：创建用户（增加了email字段）
  @Version('2')
  @Post()
  async createUserV2(@Body() createUserDto: CreateUserDtoV2) {
    return this.userService.createUserV2(createUserDto);
  }
  
  // v1版本：获取用户列表
  @Version('1')
  @Get()
  async getUsersV1() {
    return this.userService.getUsersV1();
  }
  
  // v2版本：获取用户列表（增加了email字段）
  @Version('2')
  @Get()
  async getUsersV2() {
    return this.userService.getUsersV2();
  }
  
  // v1版本：获取单个用户
  @Version('1')
  @Get(':id')
  async getUserByIdV1(@Param('id') id: string) {
    return this.userService.getUserByIdV1(+id);
  }
  
  // v2版本：获取单个用户（增加了email字段）
  @Version('2')
  @Get(':id')
  async getUserByIdV2(@Param('id') id: string) {
    return this.userService.getUserByIdV2(+id);
  }
}

// src/modules/user/user.service.ts
import { Injectable } from '@nestjs/common';
import { CreateUserDtoV1 } from './dto/create-user-v1.dto';
import { CreateUserDtoV2 } from './dto/create-user-v2.dto';

@Injectable()
export class UserService {
  // 模拟数据库
  private users = [
    { id: 1, name: '张三', email: 'zhangsan@example.com' },
    { id: 2, name: '李四', email: 'lisi@example.com' },
  ];
  
  // v1版本：创建用户
  async createUserV1(createUserDto: CreateUserDtoV1) {
    const newUser = { id: this.users.length + 1, name: createUserDto.name };
    this.users.push(newUser);
    return { id: newUser.id, name: newUser.name };
  }
  
  // v2版本：创建用户
  async createUserV2(createUserDto: CreateUserDtoV2) {
    const newUser = { id: this.users.length + 1, ...createUserDto };
    this.users.push(newUser);
    return newUser;
  }
  
  // v1版本：获取用户列表
  async getUsersV1() {
    return this.users.map(user => ({ id: user.id, name: user.name }));
  }
  
  // v2版本：获取用户列表
  async getUsersV2() {
    return this.users;
  }
  
  // v1版本：获取单个用户
  async getUserByIdV1(id: number) {
    const user = this.users.find(user => user.id === id);
    if (!user) {
      return null;
    }
    return { id: user.id, name: user.name };
  }
  
  // v2版本：获取单个用户
  async getUserByIdV2(id: number) {
    return this.users.find(user => user.id === id);
  }
}

// src/modules/user/dto/create-user-v1.dto.ts
export class CreateUserDtoV1 {
  name: string;
}

// src/modules/user/dto/create-user-v2.dto.ts
export class CreateUserDtoV2 {
  name: string;
  email: string;
}
```

### 5.2 测试版本控制

使用Postman或curl测试不同版本的API：

```bash
# 创建v1版本用户
curl -X POST http://localhost:3000/v1/users \
  -H "Content-Type: application/json" \
  -d '{"name": "王五"}'

# 创建v2版本用户
curl -X POST http://localhost:3000/v2/users \
  -H "Content-Type: application/json" \
  -d '{"name": "赵六", "email": "zhaoliu@example.com"}'

# 获取v1版本用户列表
curl http://localhost:3000/v1/users

# 获取v2版本用户列表
curl http://localhost:3000/v2/users
```

## 6. 版本控制的常见问题

### 6.1 版本冲突

**问题**：不同版本的API之间可能存在冲突，导致某些请求无法正确路由。

**解决方案**：
- 确保版本号唯一且明确
- 使用精确的版本匹配
- 避免在同一控制器中使用过多的版本

### 6.2 维护成本高

**问题**：维护多个版本的API会增加开发和维护成本。

**解决方案**：
- 合理规划API演进，减少版本数量
- 使用自动化测试减少测试成本
- 定期清理不再使用的旧版本

### 6.3 客户端困惑

**问题**：客户端可能会对多个版本的API感到困惑，不知道该使用哪个版本。

**解决方案**：
- 提供清晰的版本迁移指南
- 在文档中明确推荐使用的版本
- 为新版本提供明确的优势说明

### 6.4 版本号膨胀

**问题**：随着版本的不断增加，版本号可能会变得很大，难以管理。

**解决方案**：
- 使用语义化版本控制
- 定期合并和清理旧版本
- 为不同的API组使用独立的版本号

## 7. 总结

API版本控制是API设计中的重要环节，它可以确保API的演进和兼容性，保护现有客户端的利益。NestJS提供了强大的版本控制支持，可以轻松实现各种版本控制策略。

在实际开发中，建议：

1. **选择合适的版本控制策略**：根据API的复杂度和使用场景选择合适的版本控制策略
2. **使用语义化版本号**：遵循语义化版本控制规范，明确版本变更的含义
3. **合理规划版本演进**：避免频繁变更版本，减少维护成本
4. **提供完整的文档**：为每个版本提供详细的文档和迁移指南
5. **定期清理旧版本**：及时移除不再支持的旧版本，保持API的简洁性

通过合理的版本控制，可以构建出既灵活又稳定的API，满足不断变化的业务需求，同时保护现有客户端的利益。