# 任务调度

任务调度是指按照预定的时间间隔或特定时间点自动执行特定任务的机制。在后端应用中，任务调度常用于处理定时任务，如数据备份、报表生成、邮件发送、数据同步等。NestJS提供了强大的任务调度支持，可以轻松实现各种复杂的任务调度需求。

## 1. 任务调度的概念

### 1.1 什么是任务调度

任务调度是指在预定的时间点或时间间隔自动执行特定任务的过程。常见的任务调度场景包括：

- **定时任务**：在特定时间点执行，如每天凌晨2点执行数据备份
- **周期性任务**：按照固定时间间隔执行，如每5分钟检查一次系统状态
- **延迟任务**：延迟一段时间后执行，如用户注册后24小时发送欢迎邮件
- **CRON任务**：使用CRON表达式定义复杂的执行规则

### 1.2 任务调度的重要性

- **自动化处理**：减少人工干预，提高工作效率
- **及时性**：确保任务在正确的时间执行
- **可靠性**：自动重试失败的任务
- **可扩展性**：支持大规模任务调度
- **可监控性**：提供任务执行日志和监控

### 1.3 常见的任务调度框架

- **Linux Crontab**：Linux系统内置的任务调度工具
- **Jenkins**：持续集成工具，支持任务调度
- **Quartz**：Java中的任务调度框架
- **node-cron**：Node.js中的CRON任务调度库
- **Bull**：基于Redis的任务队列，支持延迟任务
- ** Agenda**：基于MongoDB的轻量级任务调度库

## 2. NestJS中的任务调度

NestJS提供了内置的任务调度支持，基于`@nestjs/schedule`模块，可以轻松实现各种任务调度需求。

### 2.1 安装依赖

首先，安装任务调度相关依赖：

```bash
npm install @nestjs/schedule cron
npm install -D @types/cron
```

- `@nestjs/schedule`：NestJS的任务调度模块
- `cron`：用于解析CRON表达式
- `@types/cron`：TypeScript类型定义文件

### 2.2 配置模块

在应用模块中导入任务调度模块：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';

@Module({
  imports: [
    // 注册任务调度模块
    ScheduleModule.forRoot(),
    // 其他模块
  ],
})
export class AppModule {}
```

### 2.3 基本使用

NestJS提供了三种装饰器来定义任务：

1. `@Cron()`：使用CRON表达式定义任务
2. `@Interval()`：按照固定时间间隔执行任务
3. `@Timeout()`：延迟执行一次任务

#### 2.3.1 使用@Cron装饰器

`@Cron()`装饰器用于定义CRON任务，支持标准的CRON表达式。

```typescript
// src/tasks/cron-task.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';

@Injectable()
export class CronTaskService {
  private readonly logger = new Logger(CronTaskService.name);
  
  // 每5秒执行一次
  @Cron('*/5 * * * * *')
  handleCron() {
    this.logger.debug('每5秒执行的CRON任务');
  }
  
  // 每天凌晨2点执行
  @Cron('0 2 * * *')
  handleDailyTask() {
    this.logger.debug('每天凌晨2点执行的CRON任务');
  }
  
  // 使用Cron表达式枚举
  @Cron(CronExpression.EVERY_HOUR)
  handleHourlyTask() {
    this.logger.debug('每小时执行的CRON任务');
  }
}
```

#### 2.3.2 使用@Interval装饰器

`@Interval()`装饰器用于按照固定时间间隔执行任务，单位为毫秒。

```typescript
// src/tasks/interval-task.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { Interval } from '@nestjs/schedule';

@Injectable()
export class IntervalTaskService {
  private readonly logger = new Logger(IntervalTaskService.name);
  
  // 每3秒执行一次
  @Interval(3000)
  handleInterval() {
    this.logger.debug('每3秒执行的间隔任务');
  }
}
```

#### 2.3.3 使用@Timeout装饰器

`@Timeout()`装饰器用于延迟执行一次任务，单位为毫秒。

```typescript
// src/tasks/timeout-task.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { Timeout } from '@nestjs/schedule';

@Injectable()
export class TimeoutTaskService {
  private readonly logger = new Logger(TimeoutTaskService.name);
  
  // 延迟5秒后执行一次
  @Timeout(5000)
  handleTimeout() {
    this.logger.debug('延迟5秒后执行的超时任务');
  }
}
```

## 3. CRON表达式

CRON表达式是用于定义任务执行时间的字符串，由6个字段组成，格式为：

```
秒 分 时 日 月 周
```

### 3.1 CRON字段说明

| 字段 | 允许值 | 允许的特殊字符 | 说明 |
|------|--------|----------------|------|
| 秒 | 0-59 | , - * / | 每分钟的第几秒 |
| 分 | 0-59 | , - * / | 每小时的第几分钟 |
| 时 | 0-23 | , - * / | 每天的第几小时 |
| 日 | 1-31 | , - * / ? L W | 每月的第几天 |
| 月 | 1-12 或 JAN-DEC | , - * / | 每年的第几月 |
| 周 | 0-6 或 SUN-SAT | , - * / ? L # | 每周的第几天 |

### 3.2 特殊字符说明

- `*`：匹配该字段的所有可能值
- `?`：仅用于日和周字段，表示不指定值
- `-`：指定范围，如`1-5`表示周一到周五
- `,`：指定多个值，如`MON,WED,FRI`表示周一、周三、周五
- `/`：指定增量，如`*/5`表示每5个单位
- `L`：表示最后一天，如每月最后一天
- `W`：表示最近的工作日
- `#`：表示每月的第几个星期几，如`6#3`表示每月第三个星期五

### 3.3 常用CRON表达式示例

| 表达式 | 说明 |
|--------|------|
| `* * * * * *` | 每秒执行一次 |
| `0 * * * * *` | 每分钟执行一次 |
| `0 0 * * * *` | 每小时执行一次 |
| `0 0 2 * * *` | 每天凌晨2点执行一次 |
| `0 0 2 1 * *` | 每月1号凌晨2点执行一次 |
| `0 0 2 * * 0` | 每周日凌晨2点执行一次 |
| `0 0 2 * * 1-5` | 每周一到周五凌晨2点执行一次 |
| `*/5 * * * * *` | 每5秒执行一次 |
| `0 */5 * * * *` | 每5分钟执行一次 |
| `0 0/2 * * * *` | 每2小时执行一次 |

### 3.4 使用CronExpression枚举

NestJS提供了`CronExpression`枚举，包含常用的CRON表达式：

```typescript
import { Cron, CronExpression } from '@nestjs/schedule';

@Injectable()
export class TaskService {
  // 使用CronExpression枚举
  @Cron(CronExpression.EVERY_HOUR)
  handleHourlyTask() {
    // 任务逻辑
  }
}
```

常用的`CronExpression`值：
- `CronExpression.EVERY_SECOND`：每秒执行
- `CronExpression.EVERY_MINUTE`：每分钟执行
- `CronExpression.EVERY_HOUR`：每小时执行
- `CronExpression.EVERY_DAY_AT_MIDNIGHT`：每天午夜执行
- `CronExpression.EVERY_WEEK`：每周执行
- `CronExpression.EVERY_MONTH_FIRST_DAY_AT_MIDNIGHT`：每月第一天午夜执行

## 4. 高级任务调度

### 4.1 动态任务调度

有时需要动态创建或取消任务，可以使用`SchedulerRegistry`服务：

```typescript
// src/services/dynamic-task.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { SchedulerRegistry } from '@nestjs/schedule';
import { CronJob } from 'cron';

@Injectable()
export class DynamicTaskService {
  private readonly logger = new Logger(DynamicTaskService.name);
  
  constructor(private schedulerRegistry: SchedulerRegistry) {}
  
  // 添加CRON任务
  addCronJob(name: string, cronExpression: string) {
    // 创建CRON任务
    const job = new CronJob(cronExpression, () => {
      this.logger.log(`动态任务 ${name} 执行`);
    });
    
    // 注册任务
    this.schedulerRegistry.addCronJob(name, job);
    // 启动任务
    job.start();
    
    this.logger.log(`添加动态任务 ${name}`);
  }
  
  // 删除CRON任务
  deleteCronJob(name: string) {
    this.schedulerRegistry.deleteCronJob(name);
    this.logger.log(`删除动态任务 ${name}`);
  }
  
  // 获取所有CRON任务
  getCronJobs() {
    return this.schedulerRegistry.getCronJobs();
  }
  
  // 暂停任务
  pauseCronJob(name: string) {
    this.schedulerRegistry.getCronJob(name)?.stop();
    this.logger.log(`暂停任务 ${name}`);
  }
  
  // 恢复任务
  resumeCronJob(name: string) {
    this.schedulerRegistry.getCronJob(name)?.start();
    this.logger.log(`恢复任务 ${name}`);
  }
}
```

### 4.2 任务调度事件

可以监听任务调度相关事件，如任务开始、结束、失败等：

```typescript
// src/event-listeners/schedule.listener.ts
import { Injectable } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';

@Injectable()
export class ScheduleListener {
  // 监听任务开始事件
  @OnEvent('schedule.started')
  handleScheduleStarted(event: { name: string }) {
    console.log(`任务 ${event.name} 开始执行`);
  }
  
  // 监听任务完成事件
  @OnEvent('schedule.completed')
  handleScheduleCompleted(event: { name: string, result: any }) {
    console.log(`任务 ${event.name} 执行完成，结果：`, event.result);
  }
  
  // 监听任务失败事件
  @OnEvent('schedule.failed')
  handleScheduleFailed(event: { name: string, error: Error }) {
    console.error(`任务 ${event.name} 执行失败，错误：`, event.error);
  }
}
```

### 4.3 任务调度元数据

可以为任务添加元数据，如名称、描述等：

```typescript
// src/tasks/metadata-task.service.ts
import { Injectable } from '@nestjs/common';
import { Cron, SchedulerRegistry } from '@nestjs/schedule';

@Injectable()
export class MetadataTaskService {
  constructor(private schedulerRegistry: SchedulerRegistry) {}
  
  @Cron('*/5 * * * * *', { name: 'my-cron-task' })
  handleCron() {
    // 任务逻辑
  }
  
  // 获取任务元数据
  getTaskMetadata() {
    const job = this.schedulerRegistry.getCronJob('my-cron-task');
    return {
      name: 'my-cron-task',
      lastDate: job?.lastDate(),
      nextDate: job?.nextDate(),
      running: job?.running,
    };
  }
}
```

## 5. 任务调度最佳实践

### 5.1 任务设计原则

- **单一职责**：每个任务只负责一个功能
- **幂等性**：任务重复执行不应产生副作用
- **容错性**：任务应能处理异常情况
- **可监控**：添加充分的日志记录
- **可配置**：任务参数应可配置

### 5.2 性能优化

- **避免长时间运行的任务**：将长时间运行的任务拆分为多个短任务
- **使用异步执行**：任务逻辑应使用异步方式执行
- **合理设置并发数**：避免过多任务同时执行
- **使用任务队列**：对于大量任务，使用任务队列异步处理

### 5.3 可靠性保障

- **添加重试机制**：对失败的任务进行重试
- **使用持久化存储**：将任务信息存储到数据库
- **监控任务状态**：定期检查任务执行状态
- **设置超时时间**：防止任务无限期运行

### 5.4 安全性

- **限制任务权限**：只允许特定用户管理任务
- **验证任务参数**：防止恶意参数注入
- **使用加密存储**：敏感任务信息应加密存储
- **审计日志**：记录任务执行日志，便于追溯

## 6. 完整示例

### 6.1 创建任务模块

```typescript
// src/modules/task/task.module.ts
import { Module } from '@nestjs/common';
import { TaskService } from './task.service';

@Module({
  providers: [TaskService],
})
export class TaskModule {}
```

### 6.2 创建任务服务

```typescript
// src/modules/task/task.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression, Interval, Timeout } from '@nestjs/schedule';

@Injectable()
export class TaskService {
  private readonly logger = new Logger(TaskService.name);
  
  // 使用CRON表达式：每秒执行一次
  @Cron('* * * * * *')
  handleCron() {
    this.logger.debug('CRON任务：每秒执行一次');
  }
  
  // 使用CronExpression枚举：每天凌晨2点执行
  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  handleDailyTask() {
    this.logger.debug('CRON任务：每天凌晨执行');
  }
  
  // 每5秒执行一次
  @Interval(5000)
  handleInterval() {
    this.logger.debug('间隔任务：每5秒执行一次');
  }
  
  // 延迟3秒后执行一次
  @Timeout(3000)
  handleTimeout() {
    this.logger.debug('超时任务：延迟3秒后执行');
  }
  
  // 自定义CRON表达式：每周一到周五上午9点执行
  @Cron('0 0 9 * * 1-5')
  handleWorkdayTask() {
    this.logger.debug('CRON任务：每周一到周五上午9点执行');
  }
}
```

### 6.3 在应用模块中注册

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';
import { TaskModule } from './modules/task/task.module';

@Module({
  imports: [
    ScheduleModule.forRoot(),
    TaskModule,
  ],
})
export class AppModule {}
```

### 6.4 启动应用

```bash
npm run start:dev
```

查看控制台输出，可以看到任务被自动执行：

```
[Nest] 12345  - 01/05/2026, 10:00:00 AM     LOG [TaskService] CRON任务：每秒执行一次
[Nest] 12345  - 01/05/2026, 10:00:03 AM     LOG [TaskService] 超时任务：延迟3秒后执行
[Nest] 12345  - 01/05/2026, 10:00:05 AM     LOG [TaskService] 间隔任务：每5秒执行一次
[Nest] 12345  - 01/05/2026, 10:00:06 AM     LOG [TaskService] CRON任务：每秒执行一次
```

## 7. 与其他任务调度工具集成

### 7.1 与Bull集成

Bull是基于Redis的任务队列，支持延迟任务和重试机制：

```bash
npm install @nestjs/bull bull
```

配置Bull模块：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';

@Module({
  imports: [
    BullModule.forRoot({
      redis: {
        host: 'localhost',
        port: 6379,
      },
    }),
    BullModule.registerQueue({
      name: 'tasks',
    }),
  ],
})
export class AppModule {}
```

创建任务处理器：

```typescript
// src/processors/task.processor.ts
import { Process, Processor } from '@nestjs/bull';
import { Job } from 'bull';

@Processor('tasks')
export class TaskProcessor {
  @Process('delayed-task')
  async handleDelayedTask(job: Job) {
    console.log('处理延迟任务:', job.data);
    return '任务完成';
  }
}
```

添加延迟任务：

```typescript
// src/services/task.service.ts
import { Injectable } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';

@Injectable()
export class TaskService {
  constructor(@InjectQueue('tasks') private taskQueue: Queue) {}
  
  // 添加延迟任务
  async addDelayedTask(data: any, delay: number) {
    await this.taskQueue.add('delayed-task', data, { delay });
  }
}
```

### 7.2 与Agenda集成

Agenda是基于MongoDB的轻量级任务调度库：

```bash
npm install agenda
```

创建Agenda服务：

```typescript
// src/services/agenda.service.ts
import { Injectable } from '@nestjs/common';
import { Agenda } from 'agenda';

@Injectable()
export class AgendaService {
  private agenda: Agenda;
  
  constructor() {
    this.agenda = new Agenda({
      db: { address: 'mongodb://localhost:27017/agenda' },
    });
    
    // 定义任务
    this.agenda.define('send-email', async (job) => {
      const { to, subject, body } = job.attrs.data;
      console.log(`发送邮件到 ${to}: ${subject}`);
    });
    
    // 启动Agenda
    this.agenda.start();
  }
  
  // 安排任务
  async scheduleTask() {
    await this.agenda.schedule('in 10 minutes', 'send-email', {
      to: 'user@example.com',
      subject: '测试邮件',
      body: '这是一封测试邮件',
    });
  }
}
```

## 8. 常见问题与解决方案

### 8.1 任务不执行

**问题**：任务定义后不执行

**解决方案**：
- 检查CRON表达式是否正确
- 检查任务服务是否被正确注册
- 检查应用是否正常运行
- 检查日志输出，查看是否有错误信息

### 8.2 任务重复执行

**问题**：任务被重复执行

**解决方案**：
- 确保任务服务只被注册一次
- 检查是否有多个应用实例在运行
- 使用分布式锁避免重复执行

### 8.3 任务执行失败

**问题**：任务执行失败，没有重试

**解决方案**：
- 添加错误处理逻辑
- 使用任务队列支持重试机制
- 设置合理的超时时间

### 8.4 大量任务导致性能问题

**问题**：大量任务同时执行导致性能下降

**解决方案**：
- 优化任务逻辑，减少执行时间
- 使用任务队列异步处理
- 合理设置任务执行间隔
- 使用集群模式分散任务负载

## 9. 总结

任务调度是后端应用中的重要功能，NestJS提供了强大的任务调度支持，可以轻松实现各种任务调度需求。通过`@nestjs/schedule`模块，我们可以：

1. 使用`@Cron()`装饰器定义CRON任务
2. 使用`@Interval()`装饰器定义周期性任务
3. 使用`@Timeout()`装饰器定义延迟任务
4. 使用`CronExpression`枚举简化CRON表达式
5. 动态管理任务
6. 监听任务事件
7. 与其他任务调度工具集成

在实际开发中，我们应该遵循任务调度最佳实践，设计可靠、高效、可监控的任务，确保系统的稳定运行。通过合理使用任务调度，可以提高应用的自动化程度，减少人工干预，提高工作效率。