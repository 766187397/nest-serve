# 独立应用

NestJS独立应用是一种不依赖HTTP服务器的应用形式，可以用于创建CLI工具、微服务、定时任务、消息处理器等。独立应用保留了NestJS的核心功能，如依赖注入、模块系统、装饰器等，同时提供了更加灵活的启动和运行方式。本文将详细介绍NestJS独立应用的创建、配置和使用。

## 1. 独立应用的概念

### 1.1 什么是独立应用

独立应用是一种不依赖HTTP服务器的NestJS应用形式，它使用NestJS的核心功能，但不启动HTTP服务器。独立应用可以作为：

- CLI工具
- 微服务
- 定时任务
- 消息处理器
- 数据迁移工具
- 脚本工具

### 1.2 独立应用的特点

- **不依赖HTTP服务器**：不需要启动HTTP服务器，可以直接运行
- **保留核心功能**：保留了NestJS的依赖注入、模块系统、装饰器等核心功能
- **灵活的启动方式**：可以通过命令行参数、环境变量等方式启动
- **易于部署**：可以作为独立进程运行，也可以作为容器部署
- **高性能**：避免了HTTP服务器的开销，适合处理大量数据或高并发任务

### 1.3 独立应用的使用场景

- **CLI工具**：创建命令行工具，如代码生成器、数据迁移工具等
- **微服务**：创建不依赖HTTP的微服务，如消息处理器、事件处理器等
- **定时任务**：创建定时执行的任务，如数据同步、报表生成等
- **消息处理器**：处理消息队列中的消息，如RabbitMQ、Kafka等
- **数据迁移工具**：执行数据库迁移、数据导入导出等任务
- **脚本工具**：执行各种脚本任务，如文件处理、数据清洗等

## 2. 创建独立应用

### 2.1 基本步骤

创建NestJS独立应用的基本步骤如下：

1. 创建NestJS项目
2. 安装必要的依赖
3. 创建独立应用的主文件
4. 配置独立应用
5. 运行独立应用

### 2.2 创建NestJS项目

首先，使用Nest CLI创建一个新的NestJS项目：

```bash
# 创建新项目
nest new standalone-app
```

### 2.3 安装依赖

对于独立应用，我们只需要安装基本的NestJS依赖，不需要安装HTTP相关的依赖：

```bash
# 安装基本依赖
npm install @nestjs/core @nestjs/common reflect-metadata rxjs
```

### 2.4 创建独立应用的主文件

创建一个主文件来启动独立应用：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  // 创建独立应用，不启动HTTP服务器
  const app = await NestFactory.createApplicationContext(AppModule);
  
  // 执行应用逻辑
  console.log('独立应用已启动');
  
  // 关闭应用
  await app.close();
}

bootstrap();
```

### 2.5 创建应用模块

创建一个基本的应用模块：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [],
  providers: [AppService],
})
export class AppModule {}
```

### 2.6 创建应用服务

创建一个应用服务，实现具体的业务逻辑：

```typescript
// src/app.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
  
  // 执行具体的业务逻辑
  async executeTask() {
    console.log('开始执行任务');
    // 执行任务逻辑
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log('任务执行完成');
    return '任务执行成功';
  }
}
```

## 3. 配置独立应用

### 3.1 基本配置

独立应用可以通过`NestFactory.createApplicationContext`方法的第二个参数进行配置：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';

async function bootstrap() {
  // 创建独立应用，配置日志级别
  const app = await NestFactory.createApplicationContext(AppModule, {
    logger: ['error', 'warn', 'log'], // 配置日志级别
    abortOnError: false, // 遇到错误时是否终止应用
  });
  
  // 执行应用逻辑
  console.log('独立应用已启动');
  
  // 关闭应用
  await app.close();
}

bootstrap();
```

### 3.2 环境变量配置

可以使用`ConfigModule`来加载环境变量：

```bash
# 安装依赖
npm install @nestjs/config
```

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppService } from './app.service';

@Module({
  imports: [
    // 配置环境变量
    ConfigModule.forRoot({
      envFilePath: '.env', // 环境变量文件路径
      isGlobal: true, // 是否全局可用
    }),
  ],
  providers: [AppService],
})
export class AppModule {}
```

### 3.3 日志配置

可以配置独立应用的日志：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { WinstonModule } from 'nest-winston';
import * as winston from 'winston';

async function bootstrap() {
  // 创建独立应用，配置Winston日志
  const app = await NestFactory.createApplicationContext(AppModule, {
    logger: WinstonModule.createLogger({
      transports: [
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.timestamp(),
            winston.format.colorize(),
            winston.format.simple(),
          ),
        }),
        new winston.transports.File({
          filename: 'logs/app.log',
          format: winston.format.combine(
            winston.format.timestamp(),
            winston.format.json(),
          ),
        }),
      ],
    }),
  });
  
  // 执行应用逻辑
  console.log('独立应用已启动');
  
  // 关闭应用
  await app.close();
}

bootstrap();
```

## 4. 独立应用的生命周期

独立应用的生命周期包括以下阶段：

1. **初始化**：创建应用上下文，加载模块和提供者
2. **启动**：执行应用逻辑
3. **关闭**：关闭应用上下文，释放资源

### 4.1 初始化阶段

在初始化阶段，NestJS会：

- 加载应用模块
- 注册提供者
- 执行依赖注入
- 初始化所有模块和提供者

### 4.2 启动阶段

在启动阶段，我们可以执行应用的核心逻辑，如：

- 执行定时任务
- 处理消息队列
- 执行数据迁移
- 处理命令行参数

### 4.3 关闭阶段

在关闭阶段，我们应该：

- 关闭数据库连接
- 关闭消息队列连接
- 释放资源
- 记录日志

## 5. 独立应用的依赖注入

独立应用保留了NestJS的依赖注入功能，可以使用`@Inject`、`@Injectable`等装饰器来管理依赖。

### 5.1 基本使用

```typescript
// src/modules/user/user.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class UserService {
  async findAll() {
    // 模拟查询用户
    return [
      { id: 1, name: '张三' },
      { id: 2, name: '李四' },
    ];
  }
}
```

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { UserService } from './modules/user/user.service';
import { AppService } from './app.service';

@Module({
  imports: [],
  providers: [UserService, AppService],
})
export class AppModule {}
```

```typescript
// src/app.service.ts
import { Injectable } from '@nestjs/common';
import { UserService } from './modules/user/user.service';

@Injectable()
export class AppService {
  constructor(private readonly userService: UserService) {}
  
  async execute() {
    // 使用UserService查询用户
    const users = await this.userService.findAll();
    console.log('查询到的用户:', users);
    return users;
  }
}
```

### 5.2 注入配置

可以使用`@ConfigService`来注入配置：

```typescript
// src/modules/config/config.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class AppConfigService {
  constructor(private readonly configService: ConfigService) {}
  
  getDatabaseUrl() {
    return this.configService.get<string>('DATABASE_URL');
  }
  
  getPort() {
    return this.configService.get<number>('PORT', 3000);
  }
}
```

## 6. 独立应用的日志

独立应用可以使用NestJS内置的日志系统，也可以使用第三方日志库，如Winston、Pino等。

### 6.1 使用内置日志

```typescript
// src/app.service.ts
import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class AppService {
  private readonly logger = new Logger(AppService.name);
  
  async execute() {
    this.logger.log('开始执行任务');
    
    // 执行任务逻辑
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    this.logger.log('任务执行完成');
    return '任务执行成功';
  }
}
```

### 6.2 使用Winston日志

```bash
# 安装依赖
npm install nest-winston winston
```

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { WinstonModule } from 'nest-winston';
import * as winston from 'winston';

async function bootstrap() {
  // 创建独立应用，配置Winston日志
  const app = await NestFactory.createApplicationContext(AppModule, {
    logger: WinstonModule.createLogger({
      transports: [
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.timestamp(),
            winston.format.colorize(),
            winston.format.simple(),
          ),
        }),
        new winston.transports.File({
          filename: 'logs/app.log',
          format: winston.format.combine(
            winston.format.timestamp(),
            winston.format.json(),
          ),
        }),
      ],
    }),
  });
  
  // 执行应用逻辑
  console.log('独立应用已启动');
  
  // 关闭应用
  await app.close();
}

bootstrap();
```

## 7. 独立应用的测试

独立应用的测试可以使用Jest和NestJS的测试工具：

### 7.1 安装测试依赖

```bash
# 安装测试依赖
npm install --save-dev @nestjs/testing jest ts-jest
```

### 7.2 编写测试用例

```typescript
// src/app.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppService } from './app.service';
import { UserService } from './modules/user/user.service';

describe('AppService', () => {
  let appService: AppService;
  let userService: UserService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AppService,
        {
          provide: UserService,
          useValue: {
            findAll: jest.fn().mockResolvedValue([{ id: 1, name: '张三' }]),
          },
        },
      ],
    }).compile();

    appService = module.get<AppService>(AppService);
    userService = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(appService).toBeDefined();
  });

  it('should execute task', async () => {
    const result = await appService.execute();
    expect(result).toEqual([{ id: 1, name: '张三' }]);
    expect(userService.findAll).toHaveBeenCalled();
  });
});
```

### 7.3 运行测试

```bash
# 运行测试
npm run test
```

## 8. 完整示例

### 8.1 CLI工具示例

下面是一个创建CLI工具的完整示例：

#### 8.1.1 创建项目

```bash
# 创建新项目
nest new cli-tool
```

#### 8.1.2 安装依赖

```bash
# 安装依赖
npm install commander
npm install --save-dev @types/commander
```

#### 8.1.3 创建CLI服务

```typescript
// src/modules/cli/cli.service.ts
import { Injectable } from '@nestjs/common';
import { Command } from 'commander';

@Injectable()
export class CliService {
  private program: Command;
  
  constructor() {
    // 创建CLI程序
    this.program = new Command();
    
    // 配置CLI程序
    this.program
      .name('cli-tool')
      .description('A simple CLI tool built with NestJS')
      .version('1.0.0');
    
    // 添加命令
    this.addCommands();
  }
  
  // 添加命令
  private addCommands() {
    // 示例命令：hello
    this.program
      .command('hello')
      .description('Say hello')
      .option('-n, --name <name>', 'Your name')
      .action((options) => {
        const name = options.name || 'World';
        console.log(`Hello, ${name}!`);
      });
    
    // 示例命令：calculate
    this.program
      .command('calculate')
      .description('Calculate two numbers')
      .argument('<a>', 'First number')
      .argument('<b>', 'Second number')
      .option('-o, --operation <operation>', 'Operation to perform', 'add')
      .action((a, b, options) => {
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        let result: number;
        
        switch (options.operation) {
          case 'add':
            result = numA + numB;
            break;
          case 'subtract':
            result = numA - numB;
            break;
          case 'multiply':
            result = numA * numB;
            break;
          case 'divide':
            result = numA / numB;
            break;
          default:
            console.error('Invalid operation');
            process.exit(1);
        }
        
        console.log(`Result: ${result}`);
      });
  }
  
  // 解析命令行参数
  async parse() {
    await this.program.parseAsync(process.argv);
  }
}
```

#### 8.1.4 创建应用服务

```typescript
// src/app.service.ts
import { Injectable } from '@nestjs/common';
import { CliService } from './modules/cli/cli.service';

@Injectable()
export class AppService {
  constructor(private readonly cliService: CliService) {}
  
  async run() {
    // 解析命令行参数
    await this.cliService.parse();
  }
}
```

#### 8.1.5 创建应用模块

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { CliService } from './modules/cli/cli.service';
import { AppService } from './app.service';

@Module({
  providers: [CliService, AppService],
})
export class AppModule {}
```

#### 8.1.6 创建主文件

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AppService } from './app.service';

async function bootstrap() {
  // 创建独立应用
  const app = await NestFactory.createApplicationContext(AppModule);
  
  // 获取应用服务
  const appService = app.get(AppService);
  
  // 运行应用
  await appService.run();
  
  // 关闭应用
  await app.close();
}

bootstrap();
```

#### 8.1.7 配置package.json

```json
{
  "name": "cli-tool",
  "version": "1.0.0",
  "description": "A simple CLI tool built with NestJS",
  "bin": {
    "cli-tool": "dist/main.js"
  },
  "scripts": {
    "build": "nest build",
    "start": "node dist/main.js",
    "dev": "nest start --watch",
    "test": "jest"
  },
  // 其他配置...
}
```

#### 8.1.8 运行CLI工具

```bash
# 构建项目
npm run build

# 运行CLI工具
npm start -- hello --name "John"

# 运行计算命令
npm start -- calculate 10 5 --operation multiply
```

### 8.2 定时任务示例

下面是一个创建定时任务的完整示例：

#### 8.2.1 安装依赖

```bash
# 安装依赖
npm install @nestjs/schedule
```

#### 8.2.2 创建定时任务服务

```typescript
// src/modules/schedule/schedule.service.ts
import { Injectable } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';

@Injectable()
export class ScheduleService {
  // 每分钟执行一次
  @Cron('* * * * *')
  async handleCron() {
    console.log('定时任务执行时间:', new Date().toISOString());
    // 执行定时任务逻辑
    await this.executeTask();
  }
  
  private async executeTask() {
    // 模拟执行任务
    console.log('执行定时任务...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log('定时任务执行完成');
  }
}
```

#### 8.2.3 创建应用模块

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';
import { ScheduleService } from './modules/schedule/schedule.service';

@Module({
  imports: [
    // 配置定时任务模块
    ScheduleModule.forRoot(),
  ],
  providers: [ScheduleService],
})
export class AppModule {}
```

#### 8.2.4 创建主文件

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  // 创建独立应用
  const app = await NestFactory.createApplicationContext(AppModule);
  
  console.log('定时任务服务已启动');
  
  // 保持应用运行
  process.stdin.resume();
}

bootstrap();
```

#### 8.2.5 运行定时任务

```bash
# 构建项目
npm run build

# 运行定时任务
npm start
```

## 9. 常见问题与解决方案

### 9.1 应用立即退出

**问题**：独立应用启动后立即退出

**解决方案**：
- 对于需要长期运行的应用，使用`process.stdin.resume()`来保持应用运行
- 对于一次性任务，确保任务执行完成后再关闭应用

### 9.2 依赖注入失败

**问题**：依赖注入失败，提示找不到提供者

**解决方案**：
- 检查模块是否正确导入
- 检查提供者是否正确注册
- 检查依赖的提供者是否存在

### 9.3 日志不输出

**问题**：日志不输出

**解决方案**：
- 检查日志级别是否正确配置
- 检查日志服务是否正确注册
- 检查是否有其他中间件覆盖了日志配置

### 9.4 环境变量不生效

**问题**：环境变量不生效

**解决方案**：
- 检查环境变量文件路径是否正确
- 检查环境变量是否正确加载
- 检查是否使用了`ConfigModule`

## 10. 总结

NestJS独立应用是一种不依赖HTTP服务器的应用形式，可以用于创建CLI工具、微服务、定时任务等。独立应用保留了NestJS的核心功能，如依赖注入、模块系统、装饰器等，同时提供了更加灵活的启动和运行方式。

在实际开发中，我们应该根据应用的需求选择合适的应用形式：

- 对于Web应用，使用HTTP服务器
- 对于CLI工具、微服务、定时任务等，使用独立应用

通过合理使用独立应用，可以提高应用的性能和灵活性，降低部署和维护成本，满足各种复杂的业务需求。