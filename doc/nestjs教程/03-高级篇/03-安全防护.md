# 安全防护

## 1. 安全防护概述

安全防护是保护应用免受各种攻击的过程，对于 Web 应用至关重要。NestJS 应用的安全防护可以从多个层面入手，包括认证授权、输入验证、防止常见攻击、安全配置等。

### 1.1 安全防护的重要性

- **保护用户数据**：防止用户数据泄露或被篡改
- **保护应用完整性**：防止应用被恶意修改或破坏
- **防止服务中断**：防止 DDoS 等攻击导致服务不可用
- **符合合规要求**：满足 GDPR、HIPAA 等合规要求
- **维护用户信任**：提高用户对应用的信任度

### 1.2 常见安全威胁

- **注入攻击**：SQL 注入、NoSQL 注入、命令注入等
- **跨站脚本攻击（XSS）**：存储型 XSS、反射型 XSS、DOM 型 XSS
- **跨站请求伪造（CSRF）**：利用用户身份执行恶意操作
- **认证绕过**：绕过认证机制访问受保护资源
- **授权问题**：越权访问或权限提升
- **敏感数据泄露**：敏感信息（如密码、API 密钥）泄露
- **DDoS 攻击**：大量请求导致服务不可用
- **不安全的直接对象引用**：直接访问内部对象
- **安全配置错误**：不安全的配置导致漏洞

## 2. 认证与授权

### 2.1 JWT 认证

JWT（JSON Web Token）是一种常用的认证机制，用于在客户端和服务器之间传递认证信息。

```typescript
// src/config/jwt.ts
// JWT 配置，首次出现，详细注释说明
import { JwtModuleOptions } from '@nestjs/jwt';

export const jwtConfig: JwtModuleOptions = {
  secret: process.env.JWT_SECRET || 'your-secret-key', // JWT 密钥，生产环境需使用环境变量
  signOptions: {
    expiresIn: '24h', // 令牌有效期
  },
};
```

```typescript
// src/module/auth/auth.guard.ts
// JWT 认证守卫，首次出现，详细注释说明
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private readonly jwtService: JwtService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    
    if (!token) {
      return false;
    }
    
    try {
      const payload = await this.jwtService.verifyAsync(token);
      request['user'] = payload;
    } catch {
      return false;
    }
    
    return true;
  }
  
  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers['authorization']?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

### 2.2 角色授权

使用角色守卫实现细粒度的权限控制。

```typescript
// src/common/decorator/roles.decorator.ts
// 角色装饰器，首次出现，详细注释说明
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

```typescript
// src/common/guards/roles.guard.ts
// 角色守卫，首次出现，详细注释说明
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorator/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    
    if (!requiredRoles) {
      return true;
    }
    
    const { user } = context.switchToHttp().getRequest();
    
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
```

```typescript
// src/module/users/users.controller.ts
// 使用角色守卫，首次出现，详细注释说明
import { Controller, Get, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../../common/guards/auth.guard';
import { RolesGuard } from '../../common/guards/roles.guard';
import { Roles } from '../../common/decorator/roles.decorator';

@Controller('users')
@UseGuards(JwtAuthGuard, RolesGuard)
export class UsersController {
  @Get('admin')
  @Roles('admin') // 需要 admin 角色
  getAdminUsers() {
    return 'Admin users list';
  }
  
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}
```

## 3. 输入验证

### 3.1 使用 Class Validator

Class Validator 是一个用于验证数据的库，与 NestJS 集成良好。

```bash
# 安装依赖
npm install class-validator class-transformer
```

```typescript
// src/module/users/dto/create-user.dto.ts
// 使用 Class Validator 验证输入，首次出现，详细注释说明
import { IsString, IsEmail, IsOptional, Length, Matches } from 'class-validator';

export class CreateUserDto {
  @IsString({ message: '用户名必须是字符串' })
  @Length(3, 50, { message: '用户名长度必须在 3-50 个字符之间' })
  username: string;
  
  @IsString({ message: '密码必须是字符串' })
  @Length(6, 100, { message: '密码长度必须在 6-100 个字符之间' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{6,}$/, {
    message: '密码必须包含大小写字母、数字和特殊字符',
  })
  password: string;
  
  @IsEmail({}, { message: '邮箱格式不正确' })
  email: string;
  
  @IsOptional()
  @Matches(/^1[3-9]\d{9}$/, { message: '手机号格式不正确' })
  phone?: string;
}
```

```typescript
// src/main.ts
// 启用全局验证管道，首次出现，详细注释说明
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 启用全局验证管道
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true, // 自动删除未在 DTO 中定义的属性
    forbidNonWhitelisted: true, // 禁止非白名单属性
    transform: true, // 自动转换类型
    disableErrorMessages: process.env.NODE_ENV === 'production', // 生产环境禁用详细错误信息
  }));
  
  await app.listen(3000);
}
bootstrap();
```

## 4. 防止常见攻击

### 4.1 防止 SQL 注入

使用 ORM（如 TypeORM）或参数化查询防止 SQL 注入。

```typescript
// 错误示例：字符串拼接导致 SQL 注入
async findUserByUsername(username: string) {
  const query = `SELECT * FROM users WHERE username = '${username}'`;
  return await this.connection.query(query);
}

// 正确示例：使用 TypeORM 防止 SQL 注入
async findUserByUsername(username: string) {
  return await this.userRepository.findOneBy({ username });
}

// 正确示例：使用参数化查询
async findUserByUsername(username: string) {
  const query = `SELECT * FROM users WHERE username = ?`;
  return await this.connection.query(query, [username]);
}
```

### 4.2 防止 XSS 攻击

使用转义输出防止 XSS 攻击。

```typescript
// 错误示例：直接输出用户输入
async createPost(postDto: CreatePostDto) {
  const post = this.postRepository.create({
    content: postDto.content, // 直接保存用户输入，可能包含恶意脚本
  });
  return await this.postRepository.save(post);
}

// 正确示例：使用转义函数
import { escape } from 'html-escaper';

async createPost(postDto: CreatePostDto) {
  const post = this.postRepository.create({
    content: escape(postDto.content), // 转义用户输入
  });
  return await this.postRepository.save(post);
}
```

### 4.3 防止 CSRF 攻击

使用 CSRF 令牌防止 CSRF 攻击。

```bash
# 安装 CSRF 依赖
npm install csurf
```

```typescript
// src/main.ts
// 启用 CSRF 保护，首次出现，详细注释说明
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as csurf from 'csurf';
import * as cookieParser from 'cookie-parser';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 启用 cookie 解析器
  app.use(cookieParser());
  
  // 启用 CSRF 保护
  app.use(csurf({
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
    },
  }));
  
  await app.listen(3000);
}
bootstrap();
```

### 4.4 防止 Clickjacking

使用 X-Frame-Options 头防止 Clickjacking。

```typescript
// src/main.ts
// 配置安全头，首次出现，详细注释说明
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 配置安全头
  app.use((req, res, next) => {
    // 防止 Clickjacking
    res.setHeader('X-Frame-Options', 'DENY');
    // 防止 XSS 攻击
    res.setHeader('X-XSS-Protection', '1; mode=block');
    // 防止 MIME 类型嗅探
    res.setHeader('X-Content-Type-Options', 'nosniff');
    // 内容安全策略
    res.setHeader('Content-Security-Policy', "default-src 'self'");
    // HTTP 严格传输安全
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
    next();
  });
  
  await app.listen(3000);
}
bootstrap();
```

## 5. 安全配置

### 5.1 使用环境变量

使用环境变量存储敏感配置，避免硬编码。

```bash
# 安装依赖
npm install @nestjs/config dotenv
```

```typescript
// src/app.module.ts
// 配置环境变量，首次出现，详细注释说明
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
      expandVariables: true,
    }),
  ],
})
export class AppModule {}
```

```env
# .env
# 应用配置
APP_PORT=3000
APP_ENV=development

# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_USERNAME=root
DB_PASSWORD=password
DB_DATABASE=nest_demo

# JWT 配置
JWT_SECRET=your-secret-key
JWT_EXPIRES_IN=24h

# Redis 配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=redis-password
```

### 5.2 启用 CORS

配置 CORS（跨域资源共享），限制跨域请求。

```typescript
// src/main.ts
// 配置 CORS，首次出现，详细注释说明
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 配置 CORS
  app.enableCors({
    origin: process.env.CORS_ORIGIN || '*', // 允许的源
    credentials: true, // 允许携带凭证
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'], // 允许的方法
    allowedHeaders: ['Content-Type', 'Authorization'], // 允许的头
    maxAge: 86400, // 预检请求缓存时间
  });
  
  await app.listen(3000);
}
bootstrap();
```

### 5.3 安全的密码存储

使用 bcrypt 或 Argon2 等算法安全存储密码。

```bash
# 安装依赖
npm install bcrypt
npm install -D @types/bcrypt
```

```typescript
// src/common/utils/bcrypt-hash.ts
// 密码哈希工具，首次出现，详细注释说明
import * as bcrypt from 'bcrypt';

export class BcryptHash {
  // 加密密码
  static async hash(password: string): Promise<string> {
    const salt = await bcrypt.genSalt(10); // 生成盐值
    return bcrypt.hash(password, salt); // 哈希密码
  }
  
  // 验证密码
  static async compare(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash); // 比较密码和哈希值
  }
}
```

```typescript
// src/module/users/users.service.ts
// 使用 bcrypt 存储密码，首次出现，详细注释说明
import { Injectable } from '@nestjs/common';
import { BcryptHash } from '../../common/utils/bcrypt-hash';

@Injectable()
export class UsersService {
  async create(createUserDto: CreateUserDto) {
    // 哈希密码
    const hashedPassword = await BcryptHash.hash(createUserDto.password);
    
    const user = this.userRepository.create({
      ...createUserDto,
      password: hashedPassword, // 存储哈希后的密码
    });
    
    return await this.userRepository.save(user);
  }
  
  async validateUser(username: string, password: string) {
    const user = await this.userRepository.findOneBy({ username });
    if (!user) {
      return null;
    }
    
    // 验证密码
    const isPasswordValid = await BcryptHash.compare(password, user.password);
    if (!isPasswordValid) {
      return null;
    }
    
    return user;
  }
}
```

## 6. 安全最佳实践

1. **使用 HTTPS**：在生产环境中使用 HTTPS，保护数据传输安全
2. **定期更新依赖**：及时更新依赖，修复安全漏洞
3. **使用安全的依赖**：使用经过安全审计的依赖库
4. **最小权限原则**：仅授予必要的权限
5. **输入验证**：对所有输入进行验证和清理
6. **输出编码**：对所有输出进行适当的编码
7. **认证和授权**：实现强认证和细粒度授权
8. **安全的密码存储**：使用安全的哈希算法存储密码
9. **安全配置**：使用安全的配置，避免默认配置
10. **日志和监控**：记录安全相关事件，监控异常活动
11. **安全测试**：定期进行安全测试和审计
12. **安全培训**：对开发团队进行安全培训

## 7. 安全审计与监控

### 7.1 日志记录

记录安全相关事件，便于审计和分析。

```bash
# 安装日志库
npm install winston winston-daily-rotate-file
```

```typescript
// src/config/logger.ts
// 安全日志配置，首次出现，详细注释说明
import { createLogger, transports, format } from 'winston';
import 'winston-daily-rotate-file';
import { join } from 'path';

const logDir = join(process.cwd(), 'logs');

const logger = createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: format.combine(
    format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss',
    }),
    format.errors({ stack: true }),
    format.splat(),
    format.json(),
  ),
  defaultMeta: { service: 'nestjs-api' },
  transports: [
    // 控制台日志
    new transports.Console({
      format: format.combine(
        format.colorize(),
        format.simple(),
      ),
    }),
    // 错误日志文件
    new transports.DailyRotateFile({
      filename: `${logDir}/error-%DATE%.log`,
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      level: 'error',
    }),
    // 安全日志文件
    new transports.DailyRotateFile({
      filename: `${logDir}/security-%DATE%.log`,
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '30d',
      level: 'info',
    }),
  ],
});

export default logger;
```

### 7.2 安全监控

使用安全监控工具（如 OWASP ZAP、Snyk）监控应用安全。

```bash
# 安装 Snyk CLI
npm install -g snyk

# 认证 Snyk
snyk auth

# 测试依赖安全性
snyk test

# 监控依赖安全性
snyk monitor
```

## 8. 常见安全问题

### 8.1 敏感信息泄露

**问题**：敏感信息（如密码、API 密钥）泄露。

**解决方案**：
1. 使用环境变量存储敏感信息
2. 避免硬编码敏感信息
3. 对敏感信息进行加密存储
4. 定期轮换敏感信息

### 8.2 认证绕过

**问题**：攻击者绕过认证机制访问受保护资源。

**解决方案**：
1. 实现强认证机制
2. 对所有受保护资源进行认证检查
3. 定期测试认证机制
4. 使用安全的认证库

### 8.3 授权问题

**问题**：用户越权访问或权限提升。

**解决方案**：
1. 实现细粒度的授权机制
2. 对所有操作进行授权检查
3. 遵循最小权限原则
4. 定期审查权限配置

### 8.4 输入验证不足

**问题**：输入验证不足导致注入攻击等漏洞。

**解决方案**：
1. 对所有输入进行严格验证
2. 使用成熟的验证库
3. 实现白名单验证
4. 避免信任用户输入

## 9. 总结

安全防护是 Web 应用开发的重要组成部分，需要从多个层面入手，包括认证授权、输入验证、防止常见攻击、安全配置等。NestJS 提供了丰富的安全功能和集成，便于开发者实现安全的应用。在实际应用中，需要遵循安全最佳实践，定期进行安全测试和审计，确保应用的安全性。安全防护是一个持续的过程，需要不断更新和改进，以应对新的安全威胁。
