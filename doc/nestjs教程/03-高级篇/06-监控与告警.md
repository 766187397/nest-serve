# 监控与告警

在生产环境中，监控和告警是确保应用稳定运行的重要手段。本章节将详细介绍NestJS应用的监控方案，包括性能监控、日志监控、错误监控以及告警机制的实现。

## 1. 监控概述

### 1.1 监控的重要性

- **实时掌握应用状态**：了解应用的运行状态、性能指标和资源使用情况
- **提前发现问题**：通过监控数据可以提前发现潜在问题，避免故障发生
- **快速定位故障**：当故障发生时，监控数据可以帮助快速定位问题根源
- **优化性能**：通过分析监控数据，优化应用性能和资源使用
- **满足SLA要求**：确保应用达到服务级别协议（SLA）的要求

### 1.2 监控类型

| 监控类型 | 监控内容 | 工具推荐 |
|---------|---------|---------|
| 性能监控 | 响应时间、吞吐量、资源使用率 | Prometheus + Grafana |
| 日志监控 | 访问日志、错误日志、业务日志 | ELK Stack、Winston + Logstash |
| 错误监控 | 异常、错误堆栈、崩溃信息 | Sentry、Bugsnag |
| 应用健康监控 | 应用状态、依赖服务健康 | NestJS Health Checks、Kubernetes Liveness/Readiness Probes |

## 2. 应用健康检查

NestJS提供了内置的健康检查模块，可以监控应用及其依赖服务的健康状态。

### 2.1 安装依赖

```bash
# 安装健康检查模块
npm install --save @nestjs/terminus @nestjs/axios
```

### 2.2 配置健康检查

创建健康检查模块：

```typescript
// src/health/health.module.ts
// 健康检查模块，用于监控应用和依赖服务的健康状态
import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { HttpModule } from '@nestjs/axios';
import { HealthController } from './health.controller';
import { DatabaseHealthIndicator } from './database.health';

@Module({
  imports: [
    // 导入Terminus模块
    TerminusModule,
    // 导入HttpModule，用于检查HTTP服务
    HttpModule,
  ],
  controllers: [HealthController],
  providers: [DatabaseHealthIndicator],
})
export class HealthModule {}
```

创建数据库健康检查指示器：

```typescript
// src/health/database.health.ts
// 数据库健康检查指示器，用于检查数据库连接状态
import { Injectable } from '@nestjs/common';
import { HealthIndicator, HealthIndicatorResult } from '@nestjs/terminus';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../users/user.entity';

@Injectable()
export class DatabaseHealthIndicator extends HealthIndicator {
  constructor(
    // 注入User仓库，用于测试数据库连接
    @InjectRepository(User)
    private userRepository: Repository<User>,
  ) {
    super();
  }

  // 检查数据库健康状态的方法
  async check(): Promise<HealthIndicatorResult> {
    try {
      // 尝试执行简单的查询，测试数据库连接
      await this.userRepository.query('SELECT 1');
      // 返回健康状态
      return this.getStatus('database', true);
    } catch (error) {
      // 返回不健康状态
      return this.getStatus('database', false, { error: error.message });
    }
  }
}
```

创建健康检查控制器：

```typescript
// src/health/health.controller.ts
// 健康检查控制器，提供健康检查API
import { Controller, Get } from '@nestjs/common';
import { HealthCheck, HealthCheckService, HttpHealthIndicator, MemoryHealthIndicator } from '@nestjs/terminus';
import { DatabaseHealthIndicator } from './database.health';

@Controller('health')
export class HealthController {
  constructor(
    // 注入健康检查服务
    private health: HealthCheckService,
    // 注入HTTP健康检查指示器，用于检查外部HTTP服务
    private http: HttpHealthIndicator,
    // 注入内存健康检查指示器，用于检查内存使用情况
    private memory: MemoryHealthIndicator,
    // 注入自定义的数据库健康检查指示器
    private db: DatabaseHealthIndicator,
  ) {}

  // 健康检查端点
  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      // 检查数据库健康状态
      () => this.db.check(),
      // 检查内存使用情况，阈值为300MB
      () => this.memory.checkHeap('memory_heap', 300 * 1024 * 1024),
      // 检查外部HTTP服务
      () => this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'),
    ]);
  }
}
```

### 2.3 访问健康检查端点

启动应用后，可以访问以下端点获取健康状态：

```
GET /health
```

返回结果示例：

```json
{
  "status": "ok",
  "info": {
    "database": { "status": "up" },
    "memory_heap": { "status": "up" },
    "nestjs-docs": { "status": "up" }
  },
  "error": {},
  "details": {
    "database": { "status": "up" },
    "memory_heap": { "status": "up", "heap_used": 100000000 },
    "nestjs-docs": { "status": "up" }
  }
}
```

## 3. 性能监控

Prometheus是一个流行的开源监控系统，用于收集和存储时间序列数据。Grafana是一个可视化工具，可以将Prometheus数据可视化。

### 3.1 安装依赖

```bash
# 安装Prometheus客户端
npm install --save prom-client
```

### 3.2 配置Prometheus

创建Prometheus模块：

```typescript
// src/metrics/metrics.module.ts
// Prometheus指标模块，用于收集应用性能指标
import { Module } from '@nestjs/common';
import { MetricsController } from './metrics.controller';
import { MetricsService } from './metrics.service';

@Module({
  controllers: [MetricsController],
  providers: [MetricsService],
})
export class MetricsModule {}
```

创建指标服务：

```typescript
// src/metrics/metrics.service.ts
// 指标服务，用于注册和收集Prometheus指标
import { Injectable, OnApplicationBootstrap } from '@nestjs/common';
import { Counter, Gauge, Histogram, Summary, register } from 'prom-client';

@Injectable()
export class MetricsService implements OnApplicationBootstrap {
  // 请求计数器，用于统计请求数量
  public readonly httpRequestCounter: Counter<string>;
  // 请求持续时间直方图，用于统计请求响应时间分布
  public readonly httpRequestDurationHistogram: Histogram<string>;
  // 活跃连接数 gauge，用于统计当前活跃连接数
  public readonly activeConnections: Gauge<string>;
  // 内存使用情况 gauge，用于统计内存使用情况
  public readonly memoryUsage: Gauge<string>;

  constructor() {
    // 配置默认指标
    register.setDefaultLabels({
      app: 'nestjs-app',
      version: '1.0.0',
    });

    // 初始化指标
    this.httpRequestCounter = new Counter({
      name: 'http_requests_total',
      help: 'Total number of HTTP requests',
      labelNames: ['method', 'route', 'status'],
    });

    this.httpRequestDurationHistogram = new Histogram({
      name: 'http_request_duration_seconds',
      help: 'HTTP request duration in seconds',
      labelNames: ['method', 'route', 'status'],
      buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 10],
    });

    this.activeConnections = new Gauge({
      name: 'http_active_connections',
      help: 'Number of active HTTP connections',
    });

    this.memoryUsage = new Gauge({
      name: 'process_memory_usage_bytes',
      help: 'Memory usage in bytes',
      labelNames: ['type'],
    });
  }

  // 应用启动后执行的方法
  onApplicationBootstrap() {
    // 收集Node.js默认指标
    require('prom-client').collectDefaultMetrics();
    
    // 定期收集内存使用情况
    setInterval(() => {
      const memUsage = process.memoryUsage();
      this.memoryUsage.set({ type: 'rss' }, memUsage.rss);
      this.memoryUsage.set({ type: 'heapTotal' }, memUsage.heapTotal);
      this.memoryUsage.set({ type: 'heapUsed' }, memUsage.heapUsed);
      this.memoryUsage.set({ type: 'external' }, memUsage.external);
    }, 5000);
  }

  // 获取所有指标
  async getMetrics() {
    return register.metrics();
  }
}
```

创建指标控制器：

```typescript
// src/metrics/metrics.controller.ts
// 指标控制器，提供Prometheus指标端点
import { Controller, Get } from '@nestjs/common';
import { MetricsService } from './metrics.service';

@Controller('metrics')
export class MetricsController {
  constructor(private readonly metricsService: MetricsService) {}

  // Prometheus指标端点
  @Get()
  async getMetrics() {
    return this.metricsService.getMetrics();
  }
}
```

### 3.3 创建中间件收集请求指标

```typescript
// src/metrics/metrics.middleware.ts
// 指标中间件，用于收集HTTP请求指标
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { MetricsService } from './metrics.service';

@Injectable()
export class MetricsMiddleware implements NestMiddleware {
  constructor(private readonly metricsService: MetricsService) {}

  use(req: Request, res: Response, next: NextFunction) {
    // 增加活跃连接数
    this.metricsService.activeConnections.inc();

    // 记录请求开始时间
    const start = process.hrtime();

    // 监听响应结束事件
    res.on('finish', () => {
      // 减少活跃连接数
      this.metricsService.activeConnections.dec();

      // 计算请求持续时间
      const duration = process.hrtime(start);
      const seconds = duration[0] + duration[1] / 1e9;

      // 记录请求指标
      const route = req.route ? req.route.path : req.url;
      const status = res.statusCode.toString();

      // 增加请求计数器
      this.metricsService.httpRequestCounter.inc({
        method: req.method,
        route,
        status,
      });

      // 记录请求持续时间
      this.metricsService.httpRequestDurationHistogram.observe(
        {
          method: req.method,
          route,
          status,
        },
        seconds,
      );
    });

    next();
  }
}
```

在应用模块中配置中间件：

```typescript
// src/app.module.ts
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { MetricsMiddleware } from './metrics/metrics.middleware';

@Module({
  // ...其他配置
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    // 应用指标中间件到所有路由
    consumer.apply(MetricsMiddleware).forRoutes('*');
  }
}
```

### 3.4 配置Prometheus和Grafana

1. **安装Prometheus**：
   - 下载Prometheus：https://prometheus.io/download/
   - 创建`prometheus.yml`配置文件：

```yaml
# prometheus.yml
# Prometheus配置文件，用于监控NestJS应用
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'nestjs-app'
    static_configs:
      - targets: ['localhost:3000']
    metrics_path: '/metrics'
```

2. **启动Prometheus**：
   ```bash
   prometheus --config.file=prometheus.yml
   ```

3. **安装Grafana**：
   - 下载Grafana：https://grafana.com/grafana/download
   - 启动Grafana：
   ```bash
   # Linux
   sudo systemctl start grafana-server
   
   # Windows
   grafana-server.exe
   ```

4. **配置Grafana**：
   - 访问Grafana：http://localhost:3000（默认用户名/密码：admin/admin）
   - 添加Prometheus数据源
   - 导入或创建仪表盘

## 4. 日志监控

NestJS默认使用`winston`作为日志库，可以将日志输出到控制台、文件或外部服务。

### 4.1 安装依赖

```bash
# 安装日志库
npm install --save winston winston-daily-rotate-file nest-winston
```

### 4.2 配置日志

创建日志配置文件：

```typescript
// src/config/logger.config.ts
// 日志配置文件，用于配置Winston日志器
import { WinstonModuleOptions } from 'nest-winston';
import * as winston from 'winston';
import 'winston-daily-rotate-file';

export const loggerConfig: WinstonModuleOptions = {
  // 日志级别
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  // 日志格式
  format: winston.format.combine(
    winston.format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss',
    }),
    winston.format.errors({
      stack: true,
    }),
    winston.format.splat(),
    winston.format.json(),
  ),
  // 日志传输
  transports: [
    // 控制台传输
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple(),
      ),
    }),
    // 错误日志文件传输，按天轮换
    new winston.transports.DailyRotateFile({
      filename: 'logs/error-%DATE%.log',
      level: 'error',
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
    }),
    // 所有日志文件传输，按天轮换
    new winston.transports.DailyRotateFile({
      filename: 'logs/combined-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
    }),
  ],
};
```

在应用模块中配置日志：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { WinstonModule } from 'nest-winston';
import { loggerConfig } from './config/logger.config';

@Module({
  imports: [
    // 配置Winston日志
    WinstonModule.forRoot(loggerConfig),
    // ...其他模块
  ],
  // ...其他配置
})
export class AppModule {}
```

### 4.3 使用日志

在控制器或服务中使用日志：

```typescript
// src/users/users.controller.ts
import { Controller, Get, Logger } from '@nestjs/common';

@Controller('users')
export class UsersController {
  // 创建日志实例
  private readonly logger = new Logger(UsersController.name);

  @Get()
  findAll() {
    // 记录日志
    this.logger.log('Fetching all users');
    this.logger.debug('Debug information');
    this.logger.warn('Warning message');
    this.logger.error('Error message');
    
    // ...其他逻辑
  }
}
```

### 4.4 集成ELK Stack

ELK Stack是Elasticsearch、Logstash和Kibana的组合，用于日志收集、存储和可视化。

1. **安装ELK Stack**：
   - 参考文档：https://www.elastic.co/guide/en/elastic-stack/current/installing-elastic-stack.html

2. **配置Logstash**：
   - 创建`logstash.conf`文件：

```conf
# logstash.conf
# Logstash配置文件，用于收集NestJS应用日志
input {
  file {
    path => ["/path/to/your/nestjs-app/logs/*.log"]
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "nestjs-app-%{+YYYY.MM.dd}"
  }
}
```

3. **启动ELK Stack**：
   - 启动Elasticsearch：`elasticsearch`
   - 启动Logstash：`logstash -f logstash.conf`
   - 启动Kibana：`kibana`

4. **在Kibana中查看日志**：
   - 访问Kibana：http://localhost:5601
   - 创建索引模式：`nestjs-app-*`
   - 在Discover页面查看和搜索日志

## 5. 错误监控

Sentry是一个流行的错误监控平台，可以捕获应用中的异常和错误，并提供详细的错误堆栈信息。

### 5.1 安装依赖

```bash
# 安装Sentry SDK
npm install --save @sentry/nestjs @sentry/node
```

### 5.2 配置Sentry

在应用模块中配置Sentry：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { SentryModule } from '@sentry/nestjs';
import * as Sentry from '@sentry/node';

@Module({
  imports: [
    // 配置Sentry
    SentryModule.forRoot({
      dsn: 'your-sentry-dsn',
      tracesSampleRate: 1.0,
      environment: process.env.NODE_ENV,
    }),
    // ...其他模块
  ],
  // ...其他配置
})
export class AppModule {
  constructor() {
    // 配置Sentry错误处理
    Sentry.init({
      dsn: 'your-sentry-dsn',
      tracesSampleRate: 1.0,
      environment: process.env.NODE_ENV,
    });
  }
}
```

### 5.3 创建全局异常过滤器

```typescript
// src/common/filters/sentry-exception.filter.ts
// Sentry异常过滤器，用于捕获和上报异常
import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from '@nestjs/common';
import * as Sentry from '@sentry/node';

@Catch()
export class SentryExceptionFilter implements ExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    // 确定HTTP状态码
    const status = exception instanceof HttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    // 上报异常到Sentry
    Sentry.captureException(exception, {
      extra: {
        request: {
          method: request.method,
          url: request.url,
          headers: request.headers,
          body: request.body,
          query: request.query,
          params: request.params,
        },
      },
    });

    // 返回响应
    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: exception.message || 'Internal server error',
    });
  }
}
```

在应用模块中配置全局异常过滤器：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { SentryExceptionFilter } from './common/filters/sentry-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 配置全局异常过滤器
  app.useGlobalFilters(new SentryExceptionFilter());
  
  await app.listen(3000);
}
bootstrap();
```

### 5.4 在Sentry中查看错误

- 访问Sentry：https://sentry.io/
- 在项目中查看错误事件
- 查看错误堆栈、上下文信息和发生频率
- 配置告警规则

## 6. 告警机制

### 6.1 告警类型

- **性能告警**：响应时间超过阈值、错误率过高
- **资源告警**：CPU使用率过高、内存不足、磁盘空间不足
- **错误告警**：异常数量超过阈值、特定错误类型
- **业务告警**：关键业务指标异常

### 6.2 告警渠道

- **邮件**：发送告警邮件
- **Slack/Discord**：发送告警消息到聊天平台
- **短信/电话**：紧急告警
- **Webhook**：触发自定义告警处理逻辑

### 6.3 配置Prometheus告警

1. **创建告警规则文件**：
   - 创建`alerts.yml`文件：

```yaml
# alerts.yml
# Prometheus告警规则配置文件
groups:
  - name: nestjs-app-alerts
    rules:
      # 高错误率告警
      - alert: HighErrorRate
        expr: sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m])) > 0.05
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }}% for the last 5 minutes"

      # 高响应时间告警
      - alert: HighResponseTime
        expr: histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le, route)) > 2
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "High response time detected for route {{ $labels.route }}"
          description: "95th percentile response time is {{ $value }} seconds for the last 5 minutes"

      # 内存使用率过高告警
      - alert: HighMemoryUsage
        expr: process_memory_usage_bytes{type="heapUsed"} / process_memory_usage_bytes{type="heapTotal"} > 0.8
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High memory usage detected"
          description: "Memory usage is {{ $value | humanizePercentage }} for the last 5 minutes"
```

2. **在Prometheus配置中添加告警规则**：
   ```yaml
   # prometheus.yml
   rule_files:
     - alerts.yml
   ```

3. **配置Alertmanager**：
   - 下载Alertmanager：https://prometheus.io/download/#alertmanager
   - 创建`alertmanager.yml`文件：

```yaml
# alertmanager.yml
# Alertmanager配置文件，用于处理Prometheus告警
global:
  resolve_timeout: 5m

route:
  group_by: ['alertname', 'severity']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 1h
  receiver: 'email'

receivers:
  - name: 'email'
    email_configs:
      - to: 'your-email@example.com'
        from: 'alertmanager@example.com'
        smarthost: 'smtp.example.com:587'
        auth_username: 'alertmanager'
        auth_password: 'password'
        auth_identity: 'alertmanager'
```

4. **启动Alertmanager**：
   ```bash
   alertmanager --config.file=alertmanager.yml
   ```

5. **在Prometheus配置中添加Alertmanager**：
   ```yaml
   # prometheus.yml
   alerting:
     alertmanagers:
       - static_configs:
           - targets: ['localhost:9093']
   ```

## 7. 监控最佳实践

### 7.1 监控指标选择

- **关键业务指标**：根据业务需求选择重要的业务指标
- **系统资源指标**：CPU、内存、磁盘、网络等
- **应用性能指标**：响应时间、吞吐量、错误率等
- **依赖服务指标**：数据库、缓存、外部API等

### 7.2 告警阈值设置

- 基于历史数据设置合理的阈值
- 避免告警风暴，设置适当的告警间隔和抑制规则
- 区分告警级别（warning、critical）
- 定期调整告警阈值

### 7.3 监控数据保留

- 短期数据（1-7天）：高分辨率，用于实时监控和故障排查
- 中期数据（30天）：中等分辨率，用于趋势分析
- 长期数据（1年以上）：低分辨率，用于容量规划和年度报告

### 7.4 自动化与可视化

- 自动化监控配置，避免手动操作
- 可视化监控数据，便于理解和分析
- 定期生成监控报告，总结应用运行情况

## 8. 总结

本章节介绍了NestJS应用的监控与告警方案，包括：

- 应用健康检查，使用NestJS的Terminus模块监控应用和依赖服务的健康状态
- 性能监控，使用Prometheus和Grafana收集和可视化应用性能指标
- 日志监控，使用Winston记录日志，并集成ELK Stack进行日志管理
- 错误监控，使用Sentry捕获和分析应用异常
- 告警机制，配置Prometheus告警规则和Alertmanager处理告警

通过合理的监控和告警配置，可以实时掌握应用状态，提前发现和解决问题，确保应用的稳定运行。在实际项目中，需要根据应用的规模和需求选择合适的监控方案，并不断优化和调整监控策略。

## 9. 扩展阅读

- [NestJS Health Checks文档](https://docs.nestjs.com/recipes/terminus) | [NestJS Health Checks中文文档](https://nest.nodejs.cn/recipes/terminus)
- [Prometheus官方文档](https://prometheus.io/docs/introduction/overview/)
- [Grafana官方文档](https://grafana.com/docs/)
- [Winston官方文档](https://github.com/winstonjs/winston)
- [Sentry官方文档](https://docs.sentry.io/)
- [ELK Stack官方文档](https://www.elastic.co/guide/en/elastic-stack/current/index.html)
- [Alertmanager官方文档](https://prometheus.io/docs/alerting/latest/alertmanager/)
