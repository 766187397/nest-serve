# 网络状态与错误处理

在后端开发中，网络状态与错误处理是确保应用稳定性和可靠性的关键部分。前端开发者在与后端API交互时，经常会遇到各种HTTP状态码和错误信息，但可能不太了解后端是如何生成和处理这些状态与错误的。本文将详细介绍后端开发中的网络状态与错误处理机制。

## 1. HTTP状态码详解

HTTP状态码是服务器对客户端请求的响应状态标识，分为5个类别：

### 1.1 信息性状态码（1xx）

- **100 Continue**：服务器已收到请求头，客户端应继续发送请求体
- **101 Switching Protocols**：服务器同意切换协议，如升级到WebSocket

### 1.2 成功状态码（2xx）

- **200 OK**：请求成功，服务器返回请求的数据
- **201 Created**：请求成功，服务器创建了新资源
- **202 Accepted**：请求已接受，但尚未处理完成
- **204 No Content**：请求成功，但返回的响应体为空
- **206 Partial Content**：服务器成功处理了部分GET请求

### 1.3 重定向状态码（3xx）

- **301 Moved Permanently**：资源已永久移动到新位置
- **302 Found**：资源临时移动到新位置
- **304 Not Modified**：资源未修改，可使用缓存
- **307 Temporary Redirect**：临时重定向，保持请求方法不变

### 1.4 客户端错误状态码（4xx）

- **400 Bad Request**：请求格式错误
- **401 Unauthorized**：请求需要身份验证
- **403 Forbidden**：服务器拒绝请求
- **404 Not Found**：请求的资源不存在
- **405 Method Not Allowed**：请求方法不被允许
- **406 Not Acceptable**：服务器无法提供请求的内容类型
- **408 Request Timeout**：请求超时
- **409 Conflict**：请求与服务器当前状态冲突
- **429 Too Many Requests**：客户端请求次数超过限制

### 1.5 服务器错误状态码（5xx）

- **500 Internal Server Error**：服务器内部错误
- **501 Not Implemented**：服务器不支持请求的功能
- **502 Bad Gateway**：网关或代理服务器收到无效响应
- **503 Service Unavailable**：服务器暂时不可用
- **504 Gateway Timeout**：网关或代理服务器超时
- **505 HTTP Version Not Supported**：服务器不支持请求的HTTP版本

## 2. 后端错误处理机制

### 2.1 错误处理的原则

- **统一错误格式**：所有错误返回统一的JSON格式
- **明确的错误信息**：提供清晰、有用的错误描述
- **适当的状态码**：使用正确的HTTP状态码
- **错误日志记录**：记录详细的错误日志，便于调试和监控
- **不暴露敏感信息**：不在错误响应中暴露服务器内部信息

### 2.2 统一错误响应格式

后端应返回统一格式的错误响应，便于前端处理：

```json
{
  "statusCode": 400,
  "timestamp": "2026-01-05T10:00:00.000Z",
  "path": "/api/users",
  "error": "Bad Request",
  "message": "请求参数格式错误",
  "details": [
    {
      "field": "email",
      "message": "邮箱格式不正确"
    }
  ]
}
```

### 2.3 NestJS中的错误处理

NestJS提供了多种错误处理机制：

#### 2.3.1 异常过滤器

```typescript
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();
    const exceptionResponse = exception.getResponse();

    // 记录错误日志
    console.error(`[${new Date().toISOString()}] ${request.method} ${request.url} ${status}`, {
      error: exception.name,
      message: exception.message,
      stack: exception.stack,
    });

    // 返回统一格式的错误响应
    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
        error: exception.name,
        message: exceptionResponse['message'] || exception.message,
        details: exceptionResponse['details'] || [],
      });
  }
}
```

#### 2.3.2 自定义异常

```typescript
import { HttpException, HttpStatus } from '@nestjs/common';

export class BusinessException extends HttpException {
  constructor(message: string, details?: any[], status: HttpStatus = HttpStatus.BAD_REQUEST) {
    super({ message, details }, status);
  }
}
```

#### 2.3.3 全局错误过滤器

```typescript
// main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { HttpExceptionFilter } from './filters/http-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 注册全局异常过滤器
  app.useGlobalFilters(new HttpExceptionFilter());
  
  await app.listen(3000);
}
bootstrap();
```

## 3. 网络状态监控

### 3.1 健康检查

后端应用应提供健康检查端点，用于监控应用状态：

```typescript
// health.controller.ts
import { Controller, Get } from '@nestjs/common';
import { HealthCheckService, HttpHealthIndicator, HealthCheck } from '@nestjs/terminus';

@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private http: HttpHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      // 检查自身健康状态
      () => this.http.pingCheck('self', 'http://localhost:3000/health'),
      // 可以添加其他健康检查，如数据库、Redis等
    ]);
  }
}
```

### 3.2 网络状态指标

使用监控工具（如Prometheus）收集网络状态指标：

- 请求总数
- 响应时间分布
- 各状态码数量
- 错误率
- 并发连接数

## 4. 重试机制

### 4.1 客户端重试策略

后端应支持客户端的合理重试，通过设置适当的重试头：

```typescript
// 在响应头中添加重试信息
response.setHeader('Retry-After', '60'); // 60秒后重试
response.setHeader('X-RateLimit-Limit', '100'); // 每分钟请求限制
response.setHeader('X-RateLimit-Remaining', '95'); // 剩余请求数
response.setHeader('X-RateLimit-Reset', Date.now() + 60000); // 重置时间
```

### 4.2 后端内部重试

后端服务间调用时，应实现重试机制：

```typescript
import axios from 'axios';
import { retry } from 'rxjs/operators';

// 使用axios-retry实现重试
import axiosRetry from 'axios-retry';

axiosRetry(axios, {
  retries: 3, // 重试3次
  retryDelay: (retryCount) => {
    // 指数退避策略
    return Math.pow(2, retryCount) * 1000;
  },
  retryCondition: (error) => {
    // 只重试特定错误
    return error.response?.status >= 500 || !error.response;
  },
});
```

## 5. 错误日志记录

### 5.1 日志级别

- **DEBUG**：详细的调试信息
- **INFO**：一般信息
- **WARN**：警告信息
- **ERROR**：错误信息
- **FATAL**：致命错误

### 5.2 日志内容

日志应包含以下关键信息：

- 时间戳
- 日志级别
- 请求方法和URL
- 客户端IP
- HTTP状态码
- 响应时间
- 错误信息和堆栈跟踪
- 请求ID（用于跟踪请求）

### 5.3 日志实现

```typescript
import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class UserService {
  private readonly logger = new Logger(UserService.name);

  async findUserById(id: string) {
    try {
      // 业务逻辑
      this.logger.log(`查找用户 ${id}`);
      return await this.userRepository.findOne(id);
    } catch (error) {
      this.logger.error(`查找用户 ${id} 失败: ${error.message}`, error.stack);
      throw new BusinessException('查找用户失败', [], HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
}
```

## 6. 常见错误场景与处理

### 6.1 数据库连接错误

**场景**：数据库连接失败
**处理**：
- 记录详细错误日志
- 返回503 Service Unavailable
- 实现自动重连机制
- 提供健康检查端点

### 6.2 资源不存在

**场景**：请求的资源不存在
**处理**：
- 返回404 Not Found
- 提供清晰的错误信息
- 不要暴露内部实现细节

### 6.3 请求参数错误

**场景**：请求参数格式错误或缺失
**处理**：
- 返回400 Bad Request
- 提供详细的参数验证错误信息
- 使用DTO（数据传输对象）进行参数验证

### 6.4 权限不足

**场景**：用户没有权限访问资源
**处理**：
- 返回403 Forbidden
- 不要泄露资源是否存在
- 提供清晰的权限要求

### 6.5 请求超时

**场景**：请求处理时间过长
**处理**：
- 返回408 Request Timeout
- 优化长时间运行的操作
- 考虑异步处理
- 设置合理的超时时间

## 7. 最佳实践

### 7.1 统一错误格式

- 所有API返回统一的错误格式
- 包含状态码、时间戳、路径、错误类型、错误信息和详细信息

### 7.2 详细的错误信息

- 为开发者提供有用的调试信息
- 为最终用户提供友好的错误提示
- 不要暴露敏感信息

### 7.3 适当的状态码

- 使用正确的HTTP状态码
- 遵循RESTful API设计原则

### 7.4 全面的日志记录

- 记录所有错误和异常
- 包含足够的上下文信息
- 实现日志分级

### 7.5 监控和告警

- 监控关键指标
- 设置合理的告警阈值
- 及时响应和处理告警

### 7.6 重试机制

- 为客户端提供重试建议
- 实现后端服务间的重试
- 使用指数退避策略

## 8. 前端开发者指南

### 8.1 如何处理不同状态码

```javascript
// 前端处理不同状态码的示例
fetch('/api/users')
  .then(response => {
    if (response.ok) {
      // 2xx状态码
      return response.json();
    } else if (response.status === 401) {
      // 未授权，跳转到登录页
      window.location.href = '/login';
    } else if (response.status === 403) {
      // 禁止访问，显示权限错误
      showError('您没有权限访问此资源');
    } else if (response.status === 404) {
      // 资源不存在，显示未找到
      showError('请求的资源不存在');
    } else if (response.status >= 500) {
      // 服务器错误，显示系统错误
      showError('系统错误，请稍后重试');
    } else {
      // 其他错误
      showError('请求失败，请稍后重试');
    }
    throw new Error('HTTP error! status: ' + response.status);
  })
  .then(data => {
    // 处理成功响应
    console.log(data);
  })
  .catch(error => {
    console.error('请求错误:', error);
  });
```

### 8.2 如何解读错误信息

- 关注`message`字段获取友好提示
- 查看`details`字段获取详细错误信息
- 注意`timestamp`和`path`用于调试

### 8.3 重试策略

```javascript
// 实现指数退避重试策略
async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {
  try {
    const response = await fetch(url, options);
    if (response.ok) {
      return response.json();
    }
    throw new Error('HTTP error! status: ' + response.status);
  } catch (error) {
    if (retries > 0) {
      // 指数退避
      const nextDelay = delay * 2;
      console.log(`请求失败，${nextDelay}ms后重试...`);
      await new Promise(resolve => setTimeout(resolve, nextDelay));
      return fetchWithRetry(url, options, retries - 1, nextDelay);
    }
    throw error;
  }
}
```

## 9. 总结

网络状态与错误处理是后端开发的重要组成部分，直接影响应用的稳定性和用户体验。通过统一的错误格式、适当的状态码、全面的日志记录和监控告警，可以有效地管理和处理网络状态与错误。

前端开发者了解后端的网络状态与错误处理机制，有助于更好地理解API响应，编写更健壮的前端代码，提高前后端协作效率。

在实际开发中，需要根据应用的规模和需求，选择合适的错误处理策略和监控方案，并不断优化和调整。