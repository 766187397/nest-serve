# 日志管理

日志是系统运行状态的重要记录，对于故障排查、性能分析、安全审计等方面都具有重要意义。本文将详细介绍日志管理的基本概念、常用工具和最佳实践，以及在NestJS应用中的日志管理实现。

## 1. 日志管理概述

### 1.1 什么是日志

日志是系统在运行过程中产生的记录，它包含了系统的各种状态信息、事件、错误等。日志可以帮助开发者了解系统的运行情况，排查故障，分析性能问题，以及进行安全审计。

### 1.2 日志的重要性

- **故障排查**：通过日志可以快速定位系统故障，了解故障发生的原因和上下文
- **性能分析**：通过分析日志可以了解系统的性能瓶颈，优化系统性能
- **安全审计**：日志可以记录系统的安全事件，用于安全审计和入侵检测
- **业务分析**：通过分析日志可以了解用户行为和业务流程，优化业务逻辑
- **合规要求**：某些行业（如金融、医疗）对日志管理有严格的合规要求

### 1.3 日志管理的主要内容

- **日志生成**：定义日志格式、级别和内容
- **日志收集**：将分散在不同位置的日志收集到统一的地方
- **日志存储**：选择合适的存储方式，保证日志的安全性和可访问性
- **日志分析**：对日志进行查询、分析和可视化
- **日志归档与清理**：定期归档和清理日志，避免存储压力过大

## 2. 日志级别

日志级别用于区分日志的重要程度，不同的日志级别对应不同的使用场景。

### 2.1 常见日志级别

| 级别   | 描述                           | 使用场景                             |
| ------ | ------------------------------ | ------------------------------------ |
| DEBUG  | 调试信息，最详细的日志         | 开发阶段调试代码                     |
| INFO   | 信息性日志，记录正常运行状态   | 记录系统运行情况                     |
| WARN   | 警告信息，可能存在潜在问题     | 非致命错误，需要关注                 |
| ERROR  | 错误信息，系统出现错误         | 致命错误，需要立即处理               |
| FATAL  | 严重错误，系统可能无法继续运行 | 系统崩溃，需要立即修复               |

### 2.2 日志级别配置

在不同的环境中，应该使用不同的日志级别：

- **开发环境**：使用DEBUG级别，记录详细的调试信息
- **测试环境**：使用INFO级别，记录系统运行情况
- **生产环境**：使用WARN或ERROR级别，只记录重要的警告和错误信息

## 3. 日志格式

合理的日志格式可以提高日志的可读性和可分析性。

### 3.1 常见日志格式

**文本格式**：
```
2023-10-01T12:00:00.000Z INFO [AppController] GET /api/users - 200 - 100ms
```

**JSON格式**（更适合机器分析）：
```json
{
  "timestamp": "2023-10-01T12:00:00.000Z",
  "level": "INFO",
  "context": "AppController",
  "message": "GET /api/users",
  "statusCode": 200,
  "responseTime": 100
}
```

### 3.2 日志内容建议

一条完整的日志应该包含以下信息：

- **时间戳**：精确到毫秒，便于分析时序问题
- **日志级别**：区分日志的重要程度
- **上下文**：如模块名、控制器名、函数名等
- **消息**：日志的核心内容
- **请求信息**：如HTTP方法、URL、客户端IP等
- **响应信息**：如状态码、响应时间等
- **错误信息**：如错误类型、错误消息、堆栈跟踪等
- **用户信息**：如用户ID、用户名等（用于安全审计）

## 4. 日志收集与管理工具

### 4.1 常用日志工具

| 工具         | 类型       | 功能描述                                                   |
| ------------ | ---------- | ---------------------------------------------------------- |
| Winston      | 日志库     | Node.js常用的日志库，支持多种传输方式                     |
| Pino         | 日志库     | 高性能Node.js日志库，适合高并发场景                       |
| Bunyan       | 日志库     | 结构化日志库，支持JSON格式                                 |
| Log4js       | 日志库     | 功能丰富的日志库，支持多种输出方式                         |
| ELK Stack    | 日志平台   | Elasticsearch + Logstash + Kibana，用于日志收集、存储和分析 |
| Graylog      | 日志平台   | 开源的日志管理平台，支持日志收集、存储、分析和告警         |
| Fluentd      | 日志收集   | 开源的日志收集工具，支持多种数据源和目标                   |
| Loki         | 日志平台   | Grafana Loki，轻量级的日志聚合系统                        |

### 4.2 Winston日志库

Winston是Node.js生态中最常用的日志库之一，它支持多种传输方式，如控制台、文件、数据库等。

**安装**：
```bash
npm install winston
```

**基本使用**：
```typescript
import * as winston from 'winston';

// 创建日志记录器
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    // 控制台输出
    new winston.transports.Console({
      format: winston.format.simple()
    }),
    // 文件输出
    new winston.transports.File({
      filename: 'error.log',
      level: 'error'
    }),
    new winston.transports.File({
      filename: 'combined.log'
    })
  ]
});

// 使用日志记录器
logger.info('This is an info message');
logger.warn('This is a warning message');
logger.error('This is an error message');
```

### 4.3 ELK Stack

ELK Stack是由Elasticsearch、Logstash和Kibana组成的日志管理平台：

- **Elasticsearch**：分布式搜索引擎，用于存储和检索日志
- **Logstash**：日志收集和处理工具，支持多种数据源
- **Kibana**：日志可视化平台，用于查询和分析日志

**部署流程**：
1. 安装Elasticsearch
2. 安装Logstash
3. 安装Kibana
4. 配置Logstash收集日志
5. 通过Kibana查询和分析日志

## 5. NestJS中的日志管理

NestJS内置了日志系统，同时也支持集成第三方日志库。

### 5.1 内置日志系统

NestJS内置了Logger类，可以直接使用：

```typescript
import { Controller, Get, Logger } from '@nestjs/common';

@Controller('users')
export class UsersController {
  private readonly logger = new Logger(UsersController.name);

  @Get()
  getUsers() {
    this.logger.log('获取用户列表');
    this.logger.warn('警告：用户列表为空');
    this.logger.error('错误：获取用户列表失败');
    return [];
  }
}
```

### 5.2 配置内置日志

在`main.ts`中可以配置日志：

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    logger: ['error', 'warn', 'log'], // 配置日志级别
  });
  await app.listen(3000);
}
bootstrap();
```

### 5.3 集成Winston

**安装依赖**：
```bash
npm install winston
npm install nest-winston @nestjs/common
```

**配置Winston模块**：

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { WinstonModule } from 'nest-winston';
import * as winston from 'winston';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    WinstonModule.forRoot({
      // Winston配置
      transports: [
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.timestamp(),
            winston.format.colorize(),
            winston.format.simple()
          ),
        }),
        new winston.transports.File({
          filename: 'error.log',
          level: 'error',
          format: winston.format.combine(
            winston.format.timestamp(),
            winston.format.json()
          ),
        }),
        new winston.transports.File({
          filename: 'combined.log',
          format: winston.format.combine(
            winston.format.timestamp(),
            winston.format.json()
          ),
        }),
      ],
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

**使用Winston日志器**：

```typescript
import { Controller, Get, Logger } from '@nestjs/common';

@Controller('users')
export class UsersController {
  private readonly logger = new Logger(UsersController.name);

  @Get()
  getUsers() {
    this.logger.log('获取用户列表');
    return [];
  }
}
```

### 5.4 中间件日志

创建一个日志中间件，记录所有HTTP请求：

```typescript
// logger.middleware.ts
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  private readonly logger = new Logger('HTTP');

  use(req: Request, res: Response, next: NextFunction) {
    const startTime = Date.now();
    const { method, originalUrl, ip } = req;
    const userAgent = req.get('user-agent') || '';

    res.on('finish', () => {
      const endTime = Date.now();
      const responseTime = endTime - startTime;
      const { statusCode } = res;
      const contentLength = res.get('content-length') || 0;

      this.logger.log(
        `${method} ${originalUrl} ${statusCode} ${contentLength} - ${responseTime}ms ${userAgent} ${ip}`
      );
    });

    next();
  }
}
```

**配置中间件**：

```typescript
// app.module.ts
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './logger.middleware';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes('*');
  }
}
```

## 6. 日志管理最佳实践

### 6.1 日志级别使用

- 不要在生产环境中输出DEBUG级别日志，避免性能问题和日志过多
- 使用合适的日志级别，不要将所有日志都记为INFO或ERROR
- 错误日志应包含足够的上下文信息，便于排查

### 6.2 日志格式

- 使用结构化日志（如JSON），便于机器分析
- 统一日志格式，便于集中管理和分析
- 包含必要的上下文信息，如时间戳、模块名、请求ID等

### 6.3 日志存储

- 日志应存储在安全的地方，防止被篡改
- 定期备份日志，避免数据丢失
- 考虑日志的保留期限，定期清理过期日志
- 对于大规模应用，使用集中式日志管理平台

### 6.4 日志安全

- 不要在日志中记录敏感信息，如密码、API密钥等
- 对日志进行加密存储和传输
- 限制日志的访问权限，只有授权人员才能查看
- 记录日志访问审计，便于追踪日志的使用情况

### 6.5 日志分析

- 定期分析日志，发现潜在问题
- 使用日志分析工具，如ELK Stack、Graylog等
- 设置日志告警，及时发现异常情况
- 结合监控系统，全面了解系统运行状态

## 7. 日志管理案例

### 7.1 简单应用日志配置

对于小型应用，可以使用文件日志：

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { WinstonModule } from 'nest-winston';
import * as winston from 'winston';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    WinstonModule.forRoot({
      transports: [
        new winston.transports.File({
          filename: 'logs/error.log',
          level: 'error',
          maxsize: 10 * 1024 * 1024, // 10MB
          maxFiles: 5, // 保留5个文件
        }),
        new winston.transports.File({
          filename: 'logs/combined.log',
          maxsize: 10 * 1024 * 1024,
          maxFiles: 5,
        }),
      ],
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

### 7.2 大规模应用日志配置

对于大规模应用，使用ELK Stack进行日志管理：

**1. 安装ELK Stack**

**2. 配置Logstash**

创建`logstash.conf`文件：

```conf
input {
  file {
    path => "/path/to/your/nestjs/app/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
  }
}

filter {
  if [message] =~ /^\{/ {
    json {
      source => "message"
    }
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "nestjs-logs-%{+YYYY.MM.dd}"
  }
  stdout {
    codec => rubydebug
  }
}
```

**3. 配置NestJS输出JSON日志**

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { WinstonModule } from 'nest-winston';
import * as winston from 'winston';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    WinstonModule.forRoot({
      transports: [
        new winston.transports.File({
          filename: 'logs/combined.log',
          format: winston.format.combine(
            winston.format.timestamp(),
            winston.format.json()
          ),
        }),
      ],
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

**4. 使用Kibana查看日志**

在Kibana中创建索引模式，然后在Discover页面查看和搜索日志。

## 8. 总结

日志管理是系统运维的重要组成部分，合理的日志管理可以提高系统的可维护性、可靠性和安全性。在NestJS应用中，可以使用内置日志系统或集成第三方日志库如Winston来实现日志管理。

对于不同规模的应用，应该选择不同的日志管理方案：

- 小型应用：使用文件日志即可
- 中型应用：考虑使用集中式日志管理工具
- 大型应用：使用ELK Stack、Graylog等专业日志管理平台

通过遵循日志管理的最佳实践，可以提高日志的质量和可用性，更好地支持系统的运维和开发工作。