# 用户认证与授权

用户认证与授权是大多数Web应用的基础功能，用于验证用户身份和控制用户访问权限。本章节将详细介绍如何使用NestJS实现一个完整的用户认证与授权系统，包括用户注册、登录、JWT认证、权限控制等功能。

## 1. 功能概述

### 1.1 核心功能

- **用户注册**：允许新用户创建账号
- **用户登录**：验证用户身份，生成访问令牌
- **JWT认证**：使用JSON Web Token进行身份验证
- **刷新令牌**：允许用户在不重新登录的情况下获取新的访问令牌
- **密码重置**：允许用户重置密码
- **权限控制**：基于角色的访问控制（RBAC）

### 1.2 技术栈

- **框架**：NestJS 11.x
- **语言**：TypeScript
- **认证方式**：JWT + Passport
- **ORM**：TypeORM
- **数据库**：MySQL/SQLite
- **密码加密**：bcrypt

## 2. 项目结构

```
src/
├── auth/                    # 认证模块
│   ├── auth.module.ts       # 认证模块定义
│   ├── auth.controller.ts   # 认证控制器
│   ├── auth.service.ts      # 认证服务
│   ├── auth.guard.ts        # 认证守卫
│   ├── jwt.strategy.ts      # JWT策略
│   ├── local.strategy.ts    # 本地策略
│   ├── dto/                 # 数据传输对象
│   │   ├── login.dto.ts     # 登录DTO
│   │   ├── register.dto.ts  # 注册DTO
│   │   └── reset-password.dto.ts  # 密码重置DTO
│   └── entities/            # 实体
│       └── user.entity.ts   # 用户实体
├── users/                   # 用户模块
│   ├── users.module.ts      # 用户模块定义
│   ├── users.controller.ts  # 用户控制器
│   ├── users.service.ts     # 用户服务
│   └── users.repository.ts  # 用户仓库
├── roles/                   # 角色模块
│   ├── roles.module.ts      # 角色模块定义
│   ├── roles.controller.ts  # 角色控制器
│   ├── roles.service.ts     # 角色服务
│   ├── roles.guard.ts       # 角色守卫
│   └── entities/            # 实体
│       └── role.entity.ts   # 角色实体
└── app.module.ts            # 应用主模块
```

## 3. 数据库设计

### 3.1 用户表

| 字段名 | 类型 | 描述 |
|-------|------|------|
| id | INT | 用户ID，主键 |
| username | VARCHAR(50) | 用户名，唯一 |
| email | VARCHAR(100) | 邮箱，唯一 |
| password | VARCHAR(255) | 加密后的密码 |
| nickname | VARCHAR(50) | 昵称 |
| avatar | VARCHAR(255) | 头像URL |
| status | TINYINT | 状态（0：禁用，1：启用） |
| createdAt | DATETIME | 创建时间 |
| updatedAt | DATETIME | 更新时间 |

### 3.2 角色表

| 字段名 | 类型 | 描述 |
|-------|------|------|
| id | INT | 角色ID，主键 |
| name | VARCHAR(50) | 角色名称，唯一 |
| code | VARCHAR(50) | 角色编码，唯一 |
| description | TEXT | 角色描述 |
| createdAt | DATETIME | 创建时间 |
| updatedAt | DATETIME | 更新时间 |

### 3.3 用户角色关联表

| 字段名 | 类型 | 描述 |
|-------|------|------|
| userId | INT | 用户ID，外键 |
| roleId | INT | 角色ID，外键 |

## 4. 实现步骤

### 4.1 安装依赖

```bash
# 安装核心依赖
npm install --save @nestjs/jwt @nestjs/passport passport passport-jwt passport-local bcrypt

# 安装类型定义
npm install --save-dev @types/passport-jwt @types/passport-local @types/bcrypt
```

### 4.2 创建用户实体

```typescript
// src/auth/entities/user.entity.ts
// 用户实体，定义用户表结构
import { Entity, Column, PrimaryGeneratedColumn, ManyToMany, JoinTable, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { Role } from '../../roles/entities/role.entity';

@Entity('users', { comment: '用户表，存储系统所有用户信息' })
export class User {
  // 主键，自增
  @PrimaryGeneratedColumn({ comment: '用户ID' })
  id: number;

  // 用户名，唯一
  @Column({ unique: true, length: 50, comment: '用户名' })
  username: string;

  // 邮箱，唯一
  @Column({ unique: true, length: 100, comment: '邮箱' })
  email: string;

  // 密码，使用bcrypt加密
  @Column({ length: 255, comment: '密码' })
  password: string;

  // 昵称
  @Column({ length: 50, nullable: true, comment: '昵称' })
  nickname: string;

  // 头像URL
  @Column({ length: 255, nullable: true, comment: '头像URL' })
  avatar: string;

  // 状态，0：禁用，1：启用
  @Column({ type: 'tinyint', default: 1, comment: '用户状态，0：禁用，1：启用' })
  status: number;

  // 创建时间
  @CreateDateColumn({ comment: '创建时间' })
  createdAt: Date;

  // 更新时间
  @UpdateDateColumn({ comment: '更新时间' })
  updatedAt: Date;

  // 多对多关系：一个用户可以有多个角色，一个角色可以属于多个用户
  @ManyToMany(() => Role, (role) => role.users, { cascade: true })
  @JoinTable({
    name: 'user_roles', // 关联表名称
    joinColumn: { name: 'userId', referencedColumnName: 'id' }, // 关联到当前实体的字段
    inverseJoinColumn: { name: 'roleId', referencedColumnName: 'id' }, // 关联到对方实体的字段
  })
  roles: Role[];
}
```

### 4.3 创建角色实体

```typescript
// src/roles/entities/role.entity.ts
// 角色实体，定义角色表结构
import { Entity, Column, PrimaryGeneratedColumn, ManyToMany, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { User } from '../../auth/entities/user.entity';

@Entity('roles', { comment: '角色表，存储系统所有角色信息' })
export class Role {
  // 主键，自增
  @PrimaryGeneratedColumn({ comment: '角色ID' })
  id: number;

  // 角色名称
  @Column({ length: 50, comment: '角色名称' })
  name: string;

  // 角色编码，唯一
  @Column({ unique: true, length: 50, comment: '角色编码' })
  code: string;

  // 角色描述
  @Column({ type: 'text', nullable: true, comment: '角色描述' })
  description: string;

  // 创建时间
  @CreateDateColumn({ comment: '创建时间' })
  createdAt: Date;

  // 更新时间
  @UpdateDateColumn({ comment: '更新时间' })
  updatedAt: Date;

  // 多对多关系：一个角色可以属于多个用户，一个用户可以有多个角色
  @ManyToMany(() => User, (user) => user.roles)
  users: User[];
}
```

### 4.4 创建DTO

#### 4.4.1 注册DTO

```typescript
// src/auth/dto/register.dto.ts
// 注册数据传输对象，用于验证用户注册请求
import { IsNotEmpty, IsString, IsEmail, MinLength, MaxLength } from 'class-validator';

export class RegisterDto {
  // 用户名，必填，长度5-50
  @IsNotEmpty({ message: '用户名不能为空' })
  @IsString({ message: '用户名必须是字符串' })
  @MinLength(5, { message: '用户名长度不能少于5个字符' })
  @MaxLength(50, { message: '用户名长度不能超过50个字符' })
  username: string;

  // 邮箱，必填，格式正确
  @IsNotEmpty({ message: '邮箱不能为空' })
  @IsEmail({}, { message: '邮箱格式不正确' })
  email: string;

  // 密码，必填，长度8-20
  @IsNotEmpty({ message: '密码不能为空' })
  @IsString({ message: '密码必须是字符串' })
  @MinLength(8, { message: '密码长度不能少于8个字符' })
  @MaxLength(20, { message: '密码长度不能超过20个字符' })
  password: string;

  // 昵称，可选，长度1-50
  @IsString({ message: '昵称必须是字符串' })
  @MaxLength(50, { message: '昵称长度不能超过50个字符' })
  nickname?: string;
}
```

#### 4.4.2 登录DTO

```typescript
// src/auth/dto/login.dto.ts
// 登录数据传输对象，用于验证用户登录请求
import { IsNotEmpty, IsString } from 'class-validator';

export class LoginDto {
  // 用户名，必填
  @IsNotEmpty({ message: '用户名不能为空' })
  @IsString({ message: '用户名必须是字符串' })
  username: string;

  // 密码，必填
  @IsNotEmpty({ message: '密码不能为空' })
  @IsString({ message: '密码必须是字符串' })
  password: string;
}
```

### 4.5 创建认证服务

```typescript
// src/auth/auth.service.ts
// 认证服务，处理用户注册、登录、令牌生成等逻辑
import { Injectable, ConflictException, UnauthorizedException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    // 注入用户仓库
    @InjectRepository(User)
    private usersRepository: Repository<User>,
    // 注入JWT服务
    private jwtService: JwtService,
  ) {}

  // 用户注册方法
  async register(registerDto: RegisterDto): Promise<User> {
    // 检查用户名是否已存在
    const existingUser = await this.usersRepository.findOne({
      where: [{ username: registerDto.username }, { email: registerDto.email }],
    });

    if (existingUser) {
      // 用户名或邮箱已存在，抛出冲突异常
      throw new ConflictException('用户名或邮箱已存在');
    }

    // 加密密码
    const hashedPassword = await bcrypt.hash(registerDto.password, 10);

    // 创建新用户
    const user = this.usersRepository.create({
      ...registerDto,
      password: hashedPassword,
    });

    // 保存用户到数据库
    return this.usersRepository.save(user);
  }

  // 用户登录方法
  async login(loginDto: LoginDto): Promise<{ accessToken: string; refreshToken: string }> {
    // 查找用户
    const user = await this.usersRepository.findOne({
      where: { username: loginDto.username },
      relations: ['roles'], // 加载用户角色
    });

    if (!user) {
      // 用户不存在，抛出未授权异常
      throw new UnauthorizedException('用户名或密码错误');
    }

    // 验证密码
    const isPasswordValid = await bcrypt.compare(loginDto.password, user.password);

    if (!isPasswordValid) {
      // 密码错误，抛出未授权异常
      throw new UnauthorizedException('用户名或密码错误');
    }

    // 检查用户状态
    if (user.status === 0) {
      // 用户被禁用，抛出未授权异常
      throw new UnauthorizedException('用户已被禁用');
    }

    // 生成访问令牌
    const payload = { username: user.username, sub: user.id, roles: user.roles.map(role => role.code) };
    const accessToken = this.jwtService.sign(payload, {
      expiresIn: '1h', // 访问令牌有效期1小时
    });

    // 生成刷新令牌
    const refreshToken = this.jwtService.sign(payload, {
      expiresIn: '7d', // 刷新令牌有效期7天
    });

    return { accessToken, refreshToken };
  }

  // 验证令牌方法
  async validateUser(payload: any): Promise<User | null> {
    // 根据用户ID查找用户
    return this.usersRepository.findOne({
      where: { id: payload.sub },
      relations: ['roles'],
    });
  }

  // 刷新令牌方法
  async refreshToken(refreshToken: string): Promise<{ accessToken: string }> {
    try {
      // 验证刷新令牌
      const payload = this.jwtService.verify(refreshToken);
      
      // 查找用户
      const user = await this.usersRepository.findOne({
        where: { id: payload.sub },
        relations: ['roles'],
      });

      if (!user) {
        throw new UnauthorizedException('无效的刷新令牌');
      }

      // 生成新的访问令牌
      const newPayload = { username: user.username, sub: user.id, roles: user.roles.map(role => role.code) };
      const accessToken = this.jwtService.sign(newPayload, {
        expiresIn: '1h',
      });

      return { accessToken };
    } catch (error) {
      throw new UnauthorizedException('无效的刷新令牌');
    }
  }
}
```

### 4.6 创建JWT策略

```typescript
// src/auth/jwt.strategy.ts
// JWT策略，用于验证JWT令牌
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { AuthService } from './auth.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({
      // 从Authorization头中提取Bearer令牌
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      // 是否忽略过期令牌
      ignoreExpiration: false,
      // JWT密钥，从环境变量获取
      secretOrKey: process.env.JWT_SECRET || 'your-secret-key',
    });
  }

  // 验证JWT令牌的方法
  async validate(payload: any) {
    // 调用认证服务验证用户
    const user = await this.authService.validateUser(payload);
    
    if (!user) {
      // 用户不存在，抛出未授权异常
      throw new UnauthorizedException();
    }
    
    // 返回用户对象，会被添加到请求对象中
    return user;
  }
}
```

### 4.7 创建本地策略

```typescript
// src/auth/local.strategy.ts
// 本地策略，用于验证用户名和密码
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from './auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super();
  }

  // 验证用户名和密码的方法
  async validate(username: string, password: string): Promise<any> {
    // 调用认证服务验证用户
    const user = await this.authService.validateUser({ username, password });
    
    if (!user) {
      // 用户不存在或密码错误，抛出未授权异常
      throw new UnauthorizedException('用户名或密码错误');
    }
    
    // 返回用户对象
    return user;
  }
}
```

### 4.8 创建认证守卫

```typescript
// src/auth/auth.guard.ts
// 认证守卫，用于保护需要认证的路由
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

### 4.9 创建认证控制器

```typescript
// src/auth/auth.controller.ts
// 认证控制器，处理用户注册、登录、刷新令牌等请求
import { Controller, Post, Body, UseGuards, Req } from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { JwtAuthGuard } from './auth.guard';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  // 用户注册接口
  @Post('register')
  register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }

  // 用户登录接口
  @Post('login')
  login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  // 刷新令牌接口
  @Post('refresh')
  @UseGuards(JwtAuthGuard)
  refreshToken(@Req() req) {
    // 从请求头中获取刷新令牌
    const refreshToken = req.headers.authorization?.replace('Bearer ', '');
    return this.authService.refreshToken(refreshToken);
  }

  // 获取当前用户信息接口
  @Post('profile')
  @UseGuards(JwtAuthGuard)
  getProfile(@Req() req) {
    // 从请求对象中获取用户信息
    return req.user;
  }
}
```

### 4.10 创建角色守卫

```typescript
// src/roles/roles.guard.ts
// 角色守卫，用于基于角色的权限控制
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

export const ROLES_KEY = 'roles';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  // 检查用户是否有权限访问路由
  canActivate(context: ExecutionContext): boolean {
    // 从路由元数据中获取所需角色
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      // 没有设置角色要求，允许访问
      return true;
    }

    // 从请求对象中获取用户
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      // 用户未认证，抛出未授权异常
      throw new UnauthorizedException();
    }

    // 检查用户角色是否包含所需角色
    const hasRole = user.roles.some((role) => requiredRoles.includes(role.code));

    if (!hasRole) {
      // 用户没有所需角色，抛出禁止访问异常
      throw new ForbiddenException('没有访问权限');
    }

    return true;
  }
}
```

### 4.11 创建角色装饰器

```typescript
// src/roles/roles.decorator.ts
// 角色装饰器，用于设置路由所需的角色
import { SetMetadata } from '@nestjs/common';
import { ROLES_KEY } from './roles.guard';

export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

### 4.12 配置认证模块

```typescript
// src/auth/auth.module.ts
// 认证模块，整合认证相关的控制器、服务、策略等
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from './entities/user.entity';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { JwtStrategy } from './jwt.strategy';
import { LocalStrategy } from './local.strategy';

@Module({
  // 导入TypeOrm模块，注册User实体
  imports: [
    TypeOrmModule.forFeature([User]),
    // 配置Passport模块
    PassportModule.register({ defaultStrategy: 'jwt' }),
    // 配置JWT模块
    JwtModule.register({
      // JWT密钥，从环境变量获取
      secret: process.env.JWT_SECRET || 'your-secret-key',
      // 令牌有效期
      signOptions: {
        expiresIn: '1h',
      },
    }),
  ],
  // 注册控制器
  controllers: [AuthController],
  // 注册服务、策略等提供者
  providers: [AuthService, JwtStrategy, LocalStrategy],
  // 导出认证相关的服务和守卫
  exports: [AuthService, JwtAuthGuard],
})
export class AuthModule {}
```

### 4.13 配置应用主模块

```typescript
// src/app.module.ts
// 应用主模块，整合所有功能模块
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';
import { RolesModule } from './roles/roles.module';
import { ConfigModule } from '@nestjs/config';

@Module({
  // 导入配置模块
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, // 全局可用
    }),
    // 配置TypeOrm
    TypeOrmModule.forRoot({
      type: process.env.DB_TYPE as any || 'mysql',
      host: process.env.DB_HOST || 'localhost',
      port: parseInt(process.env.DB_PORT) || 3306,
      username: process.env.DB_USERNAME || 'root',
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_DATABASE || 'nestjs-app',
      entities: [__dirname + '/**/*.entity{.ts,.js}'],
      synchronize: true, // 开发环境下自动同步数据库结构
    }),
    // 导入功能模块
    AuthModule,
    UsersModule,
    RolesModule,
  ],
})
export class AppModule {}
```

## 5. 测试认证功能

### 5.1 注册用户

```bash
# 使用curl测试注册接口
curl -X POST http://localhost:3000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","email":"test@example.com","password":"password123","nickname":"Test User"}'
```

### 5.2 用户登录

```bash
# 使用curl测试登录接口
curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"password123"}'
```

### 5.3 获取用户信息

```bash
# 使用curl测试获取用户信息接口
curl -X POST http://localhost:3000/auth/profile \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

## 6. 权限控制示例

### 6.1 创建需要权限的路由

```typescript
// src/users/users.controller.ts
// 用户管理控制器，使用角色守卫保护路由
import { Controller, Get, UseGuards } from '@nestjs/common';
import { UsersService } from './users.service';
import { JwtAuthGuard } from '../auth/auth.guard';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';

@Controller('users')
@UseGuards(JwtAuthGuard, RolesGuard) // 应用认证守卫和角色守卫
@Roles('admin') // 要求admin角色

export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  // 获取所有用户列表接口
  @Get()
  findAll() {
    return this.usersService.findAll();
  }
}
```

## 7. 最佳实践

### 7.1 密码安全

- 使用bcrypt等安全算法加密密码
- 设置合理的密码长度和复杂度要求
- 定期提醒用户更换密码
- 禁止在日志中记录密码

### 7.2 令牌管理

- 设置合理的令牌有效期
- 使用刷新令牌机制，避免频繁登录
- 实现令牌黑名单，支持令牌撤销
- 考虑使用OAuth 2.0或OpenID Connect等标准协议

### 7.3 权限管理

- 基于角色的访问控制（RBAC）是常用的权限管理模型
- 最小权限原则：只授予用户完成任务所需的最小权限
- 定期审查和更新用户权限
- 实现权限审计，记录权限变更和访问日志

### 7.4 安全防护

- 使用HTTPS协议，加密数据传输
- 实现CSRF保护
- 防止XSS攻击，对用户输入进行过滤和转义
- 防止SQL注入，使用参数化查询
- 实现速率限制，防止暴力破解

## 8. 总结

本章节详细介绍了如何使用NestJS实现一个完整的用户认证与授权系统，包括：

- 用户注册和登录功能
- JWT令牌生成和验证
- 基于角色的权限控制
- 刷新令牌机制
- 安全最佳实践

通过本章节的学习，你可以掌握NestJS中的认证与授权机制，为你的应用提供安全可靠的用户管理功能。在实际项目中，你可以根据需求扩展和定制认证与授权功能，如添加社交登录、多因素认证等。

## 9. 扩展阅读

- [NestJS认证文档](https://docs.nestjs.com/security/authentication) | [NestJS认证中文文档](https://nest.nodejs.cn/security/authentication)
- [Passport.js官方文档](http://www.passportjs.org/docs/)
- [JWT官方文档](https://jwt.io/introduction/)
- [OWASP认证最佳实践](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
