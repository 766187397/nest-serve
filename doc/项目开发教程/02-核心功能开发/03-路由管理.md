# 路由管理

路由管理是Web应用的核心组成部分，用于定义API端点和处理HTTP请求。本章节将详细介绍如何使用NestJS实现路由管理，包括路由定义、路由分组、路由权限控制和动态路由等功能。

## 1. 功能概述

### 1.1 核心功能

- **路由定义**：创建和管理API路由
- **路由分组**：按模块或功能对路由进行分组
- **路由权限控制**：基于角色和权限控制路由访问
- **动态路由**：根据用户权限动态生成路由
- **路由文档**：自动生成API文档

### 1.2 技术栈

- **框架**：NestJS 11.x
- **语言**：TypeScript
- **认证方式**：JWT + Passport
- **API文档**：Swagger

## 2. 路由基础

### 2.1 路由定义

在NestJS中，路由是通过装饰器定义的，主要装饰器包括：

| 装饰器 | HTTP方法 | 描述 |
|-------|---------|------|
| `@Get()` | GET | 处理GET请求 |
| `@Post()` | POST | 处理POST请求 |
| `@Put()` | PUT | 处理PUT请求 |
| `@Patch()` | PATCH | 处理PATCH请求 |
| `@Delete()` | DELETE | 处理DELETE请求 |
| `@All()` | ALL | 处理所有HTTP方法 |

### 2.2 路由参数

NestJS支持多种路由参数类型：

#### 2.2.1 路径参数

```typescript
// src/users/users.controller.ts
@Get(':id')
findOne(@Param('id') id: string) {
  return this.usersService.findOne(+id);
}
```

#### 2.2.2 查询参数

```typescript
// src/users/users.controller.ts
@Get()
findAll(@Query('page') page: string, @Query('limit') limit: string) {
  return this.usersService.findAll(+page, +limit);
}
```

#### 2.2.3 请求体

```typescript
// src/users/users.controller.ts
@Post()
create(@Body() createUserDto: CreateUserDto) {
  return this.usersService.create(createUserDto);
}
```

#### 2.2.4 请求头

```typescript
// src/auth/auth.controller.ts
@Post('refresh')
refreshToken(@Headers('Authorization') authorization: string) {
  const refreshToken = authorization.replace('Bearer ', '');
  return this.authService.refreshToken(refreshToken);
}
```

## 3. 路由分组

### 3.1 控制器级分组

通过控制器装饰器`@Controller()`可以为一组路由添加前缀：

```typescript
// src/users/users.controller.ts
@Controller('users')
export class UsersController {
  // 路由: GET /users
  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  // 路由: GET /users/:id
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }
}
```

### 3.2 模块级分组

通过配置模块的`global`属性和`prefix`属性，可以实现更灵活的路由分组：

```typescript
// src/users/users.module.ts
@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {
  // 模块级中间件配置
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes('users');
  }
}
```

### 3.3 全局前缀

可以为所有路由添加全局前缀：

```typescript
// src/main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  // 添加全局前缀
  app.setGlobalPrefix('api/v1');
  await app.listen(3000);
}
bootstrap();
```

## 4. 路由权限控制

### 4.1 基于角色的路由保护

使用守卫（Guards）可以实现基于角色的路由保护：

```typescript
// src/articles/articles.controller.ts
@Controller('articles')
@UseGuards(JwtAuthGuard, RolesGuard) // 应用认证守卫和角色守卫
export class ArticlesController {
  constructor(private readonly articlesService: ArticlesService) {}

  // 创建文章接口，要求admin或editor角色
  @Post()
  @Roles('admin', 'editor') // 要求admin或editor角色
  create(@Body() createArticleDto: CreateArticleDto) {
    return this.articlesService.create(createArticleDto);
  }

  // 获取所有文章接口，所有认证用户均可访问
  @Get()
  findAll() {
    return this.articlesService.findAll();
  }
}
```

### 4.2 基于权限的路由保护

可以扩展角色守卫，实现基于权限的路由保护：

```typescript
// src/permissions/permissions.guard.ts
// 权限守卫，用于基于权限的路由保护
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

export const PERMISSIONS_KEY = 'permissions';

@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  // 检查用户是否有权限访问路由
  canActivate(context: ExecutionContext): boolean {
    // 从路由元数据中获取所需权限
    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(PERMISSIONS_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredPermissions) {
      // 没有设置权限要求，允许访问
      return true;
    }

    // 从请求对象中获取用户
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      // 用户未认证，抛出未授权异常
      throw new UnauthorizedException();
    }

    // 检查用户权限是否包含所需权限
    // 假设user.permissions是用户拥有的权限编码数组
    const hasPermission = requiredPermissions.some(permission => 
      user.permissions?.includes(permission)
    );

    if (!hasPermission) {
      // 用户没有所需权限，抛出禁止访问异常
      throw new ForbiddenException('没有访问权限');
    }

    return true;
  }
}
```

### 4.3 权限装饰器

```typescript
// src/permissions/permissions.decorator.ts
// 权限装饰器，用于设置路由所需的权限
import { SetMetadata } from '@nestjs/common';
import { PERMISSIONS_KEY } from './permissions.guard';

export const Permissions = (...permissions: string[]) => SetMetadata(PERMISSIONS_KEY, permissions);
```

### 4.4 使用权限守卫

```typescript
// src/articles/articles.controller.ts
@Controller('articles')
@UseGuards(JwtAuthGuard, PermissionsGuard) // 应用认证守卫和权限守卫
export class ArticlesController {
  constructor(private readonly articlesService: ArticlesService) {}

  // 创建文章接口，要求article:create权限
  @Post()
  @Permissions('article:create') // 要求article:create权限
  create(@Body() createArticleDto: CreateArticleDto) {
    return this.articlesService.create(createArticleDto);
  }

  // 更新文章接口，要求article:update权限
  @Patch(':id')
  @Permissions('article:update') // 要求article:update权限
  update(@Param('id') id: string, @Body() updateArticleDto: UpdateArticleDto) {
    return this.articlesService.update(+id, updateArticleDto);
  }
}
```

## 5. 动态路由

### 5.1 动态路由概述

动态路由是指根据用户权限动态生成的路由，用户只能访问其有权限的路由。动态路由通常用于前端路由管理，后端提供路由列表接口，前端根据返回的路由列表动态生成菜单和路由。

### 5.2 路由实体设计

创建路由实体，用于存储路由信息：

```typescript
// src/routes/entities/route.entity.ts
// 路由实体，定义路由表结构
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('routes', { comment: '路由表，存储系统所有路由信息' })
export class Route {
  // 主键，自增
  @PrimaryGeneratedColumn({ comment: '路由ID' })
  id: number;

  // 路由名称
  @Column({ length: 50, comment: '路由名称' })
  name: string;

  // 路由路径
  @Column({ length: 255, comment: '路由路径' })
  path: string;

  // 路由组件
  @Column({ length: 255, comment: '路由组件' })
  component: string;

  // 路由图标
  @Column({ length: 50, nullable: true, comment: '路由图标' })
  icon?: string;

  // 父路由ID
  @Column({ nullable: true, comment: '父路由ID' })
  parentId?: number;

  // 路由顺序
  @Column({ type: 'int', default: 0, comment: '路由顺序' })
  order: number;

  // 是否隐藏
  @Column({ type: 'boolean', default: false, comment: '是否隐藏' })
  hidden: boolean;

  // 是否需要认证
  @Column({ type: 'boolean', default: true, comment: '是否需要认证' })
  requireAuth: boolean;

  // 所需角色（JSON数组）
  @Column({ type: 'json', nullable: true, comment: '所需角色' })
  roles?: string[];

  // 所需权限（JSON数组）
  @Column({ type: 'json', nullable: true, comment: '所需权限' })
  permissions?: string[];

  // 创建时间
  @CreateDateColumn({ comment: '创建时间' })
  createdAt: Date;

  // 更新时间
  @UpdateDateColumn({ comment: '更新时间' })
  updatedAt: Date;
}
```

### 5.3 路由服务

创建路由服务，用于管理路由信息：

```typescript
// src/routes/routes.service.ts
// 路由服务，处理路由相关的业务逻辑
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Route } from './entities/route.entity';
import { CreateRouteDto } from './dto/create-route.dto';
import { UpdateRouteDto } from './dto/update-route.dto';

@Injectable()
export class RoutesService {
  constructor(
    // 注入路由仓库
    @InjectRepository(Route)
    private routesRepository: Repository<Route>,
  ) {}

  // 创建路由
  async create(createRouteDto: CreateRouteDto): Promise<Route> {
    const route = this.routesRepository.create(createRouteDto);
    return this.routesRepository.save(route);
  }

  // 获取所有路由
  async findAll(): Promise<Route[]> {
    return this.routesRepository.find({
      order: { order: 'ASC' }, // 按顺序排序
    });
  }

  // 根据ID获取路由
  async findOne(id: number): Promise<Route> {
    const route = await this.routesRepository.findOne({ where: { id } });
    if (!route) {
      throw new NotFoundException('路由不存在');
    }
    return route;
  }

  // 更新路由
  async update(id: number, updateRouteDto: UpdateRouteDto): Promise<Route> {
    const route = await this.findOne(id);
    Object.assign(route, updateRouteDto);
    return this.routesRepository.save(route);
  }

  // 删除路由
  async remove(id: number): Promise<void> {
    const route = await this.findOne(id);
    await this.routesRepository.remove(route);
  }

  // 生成树形路由
  async generateRoutesTree(): Promise<Route[]> {
    const routes = await this.findAll();
    return this.buildRoutesTree(routes);
  }

  // 根据用户角色生成动态路由
  async generateDynamicRoutes(userRoles: string[]): Promise<Route[]> {
    // 获取所有路由
    const routes = await this.findAll();
    
    // 根据用户角色过滤路由
    const filteredRoutes = routes.filter(route => {
      // 不需要认证的路由，直接允许访问
      if (!route.requireAuth) {
        return true;
      }
      
      // 没有设置角色要求的路由，所有认证用户均可访问
      if (!route.roles || route.roles.length === 0) {
        return true;
      }
      
      // 检查用户角色是否包含所需角色
      return route.roles.some(role => userRoles.includes(role));
    });
    
    // 生成树形路由
    return this.buildRoutesTree(filteredRoutes);
  }

  // 将路由列表转换为树形结构
  private buildRoutesTree(routes: Route[]): Route[] {
    const routeMap: Map<number, Route & { children?: Route[] }> = new Map();
    const rootRoutes: Route[] = [];
    
    // 首先将所有路由添加到Map中
    routes.forEach(route => {
      routeMap.set(route.id, { ...route, children: [] });
    });
    
    // 构建树形结构
    routeMap.forEach(route => {
      if (route.parentId) {
        // 如果有父路由，添加到父路由的children中
        const parent = routeMap.get(route.parentId);
        if (parent) {
          parent.children?.push(route);
        }
      } else {
        // 没有父路由，作为根路由
        rootRoutes.push(route);
      }
    });
    
    return rootRoutes;
  }
}
```

### 5.4 路由控制器

创建路由控制器，提供路由管理接口：

```typescript
// src/routes/routes.controller.ts
// 路由控制器，处理路由相关的HTTP请求
import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards, Req } from '@nestjs/common';
import { RoutesService } from './routes.service';
import { CreateRouteDto } from './dto/create-route.dto';
import { UpdateRouteDto } from './dto/update-route.dto';
import { JwtAuthGuard } from '../auth/auth.guard';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';

@Controller('routes')
@UseGuards(JwtAuthGuard, RolesGuard) // 应用认证守卫和角色守卫
export class RoutesController {
  constructor(private readonly routesService: RoutesService) {}

  // 创建路由接口，要求admin角色
  @Post()
  @Roles('admin')
  create(@Body() createRouteDto: CreateRouteDto) {
    return this.routesService.create(createRouteDto);
  }

  // 获取所有路由接口，要求admin角色
  @Get()
  @Roles('admin')
  findAll() {
    return this.routesService.findAll();
  }

  // 获取树形路由接口，要求admin角色
  @Get('tree')
  @Roles('admin')
  generateRoutesTree() {
    return this.routesService.generateRoutesTree();
  }

  // 获取动态路由接口，所有认证用户均可访问
  @Get('dynamic')
  getDynamicRoutes(@Req() req) {
    // 从请求对象中获取用户角色
    const userRoles = req.user.roles.map(role => role.code);
    // 生成动态路由
    return this.routesService.generateDynamicRoutes(userRoles);
  }

  // 根据ID获取路由接口，要求admin角色
  @Get(':id')
  @Roles('admin')
  findOne(@Param('id') id: string) {
    return this.routesService.findOne(+id);
  }

  // 更新路由接口，要求admin角色
  @Patch(':id')
  @Roles('admin')
  update(@Param('id') id: string, @Body() updateRouteDto: UpdateRouteDto) {
    return this.routesService.update(+id, updateRouteDto);
  }

  // 删除路由接口，要求admin角色
  @Delete(':id')
  @Roles('admin')
  remove(@Param('id') id: string) {
    return this.routesService.remove(+id);
  }
}
```

## 6. 路由文档

### 6.1 Swagger集成

NestJS支持使用Swagger自动生成API文档，安装依赖：

```bash
# 安装Swagger依赖
npm install --save @nestjs/swagger swagger-ui-express
```

### 6.2 配置Swagger

在`main.ts`中配置Swagger：

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 配置Swagger文档
  const config = new DocumentBuilder()
    .setTitle('NestJS API')
    .setDescription('NestJS API文档')
    .setVersion('1.0')
    .addBearerAuth() // 添加Bearer认证
    .build();
  
  // 创建Swagger文档
  const document = SwaggerModule.createDocument(app, config);
  
  // 设置Swagger文档路径
  SwaggerModule.setup('api-docs', app, document);
  
  await app.listen(3000);
}
bootstrap();
```

### 6.3 使用Swagger装饰器

在控制器和DTO中使用Swagger装饰器，可以生成更详细的API文档：

```typescript
// src/articles/articles.controller.ts
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth, ApiRoles } from '@nestjs/swagger';
import { ArticlesService } from './articles.service';
import { CreateArticleDto } from './dto/create-article.dto';
import { UpdateArticleDto } from './dto/update-article.dto';

@Controller('articles')
@ApiTags('文章管理') // 设置标签
@ApiBearerAuth() // 需要Bearer认证
export class ArticlesController {
  constructor(private readonly articlesService: ArticlesService) {}

  // 创建文章接口
  @Post()
  @ApiOperation({ summary: '创建文章', description: '创建新的文章' }) // 操作描述
  create(@Body() createArticleDto: CreateArticleDto) {
    return this.articlesService.create(createArticleDto);
  }

  // 获取所有文章接口
  @Get()
  @ApiOperation({ summary: '获取文章列表', description: '获取所有文章的列表' })
  findAll() {
    return this.articlesService.findAll();
  }
}
```

```typescript
// src/articles/dto/create-article.dto.ts
import { IsNotEmpty, IsString, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateArticleDto {
  @ApiProperty({ description: '文章标题', example: 'NestJS教程', maxLength: 100 })
  @IsNotEmpty({ message: '文章标题不能为空' })
  @IsString({ message: '文章标题必须是字符串' })
  @MaxLength(100, { message: '文章标题长度不能超过100个字符' })
  title: string;

  @ApiProperty({ description: '文章内容', example: 'NestJS是一个渐进式Node.js框架' })
  @IsNotEmpty({ message: '文章内容不能为空' })
  @IsString({ message: '文章内容必须是字符串' })
  content: string;
}
```

### 6.4 访问Swagger文档

启动应用后，可以通过以下URL访问Swagger文档：

```
http://localhost:3000/api-docs
```

## 7. 路由中间件

### 7.1 全局中间件

全局中间件对所有路由生效：

```typescript
// src/main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 使用全局中间件
  app.use(LoggerMiddleware);
  
  await app.listen(3000);
}
bootstrap();
```

### 7.2 模块级中间件

模块级中间件对特定模块的路由生效：

```typescript
// src/users/users.module.ts
@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule implements NestModule {
  // 配置中间件
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware) // 应用中间件
      .forRoutes('users'); // 对users路由生效
  }
}
```

### 7.3 路由级中间件

路由级中间件对特定路由生效：

```typescript
// src/users/users.module.ts
@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule implements NestModule {
  // 配置中间件
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes(
        { path: 'users', method: RequestMethod.GET }, // 仅对GET /users生效
        { path: 'users/:id', method: RequestMethod.GET } // 仅对GET /users/:id生效
      );
  }
}
```

## 8. 最佳实践

### 8.1 路由设计原则

- **RESTful API设计**：遵循RESTful API设计原则，使用合适的HTTP方法和状态码
- **路由命名规范**：使用清晰、一致的路由命名，如`/users/:id`、`/articles/:id/comments`
- **路由分组**：按模块或功能对路由进行分组，提高代码的可维护性
- **版本控制**：为API添加版本前缀，如`/api/v1/users`
- **权限控制**：合理使用守卫和装饰器，实现细粒度的权限控制

### 8.2 性能优化

- **路由缓存**：对静态路由进行缓存，减少路由匹配时间
- **中间件优化**：减少中间件的数量和复杂度，提高请求处理速度
- **路由懒加载**：对大型应用，考虑使用路由懒加载，减少初始加载时间

### 8.3 安全性

- **输入验证**：对所有用户输入进行验证，防止注入攻击
- **认证和授权**：为敏感路由添加认证和授权机制
- **HTTPS**：使用HTTPS协议，加密数据传输
- **CORS配置**：合理配置CORS，防止跨域攻击

## 9. 总结

本章节详细介绍了如何使用NestJS实现路由管理，包括：

- 路由定义和基本用法
- 路由分组和前缀设置
- 基于角色和权限的路由保护
- 动态路由生成，根据用户权限动态生成路由列表
- Swagger API文档生成
- 路由中间件配置
- 路由设计最佳实践

通过本章节的学习，你可以掌握NestJS中的路由管理机制，为你的应用设计和实现清晰、安全、高效的API路由。在实际项目中，你可以根据需求扩展和定制路由功能，如添加路由日志、路由限流等高级特性。

## 10. 扩展阅读

- [NestJS路由文档](https://docs.nestjs.com/controllers) | [NestJS路由中文文档](https://nest.nodejs.cn/controllers)
- [NestJS守卫文档](https://docs.nestjs.com/guards) | [NestJS守卫中文文档](https://nest.nodejs.cn/guards)
- [NestJS中间件文档](https://docs.nestjs.com/middleware) | [NestJS中间件中文文档](https://nest.nodejs.cn/middleware)
- [Swagger官方文档](https://swagger.io/docs/)
- [RESTful API设计最佳实践](https://restfulapi.net/)
