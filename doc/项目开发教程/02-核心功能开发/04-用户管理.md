# 用户管理

用户管理是任何系统的基础功能之一，用于管理系统用户的基本信息、状态和权限。本章节将详细介绍如何使用NestJS实现用户管理，包括用户创建、查询、更新、删除以及用户角色管理等功能。

## 1. 功能概述

### 1.1 核心功能

- **用户列表**：获取用户列表，支持分页和筛选
- **用户详情**：查看单个用户的详细信息
- **创建用户**：创建新用户
- **更新用户**：更新用户信息
- **删除用户**：删除用户
- **用户状态管理**：启用/禁用用户
- **用户角色管理**：为用户分配和管理角色
- **用户密码重置**：重置用户密码

### 1.2 技术栈

- **框架**：NestJS 11.x
- **语言**：TypeScript
- **ORM**：TypeORM
- **数据库**：MySQL/SQLite
- **认证方式**：JWT + Passport

## 2. 数据库设计

### 2.1 用户表（users）

| 字段名 | 类型 | 描述 |
|-------|------|------|
| id | INT | 用户ID，主键 |
| username | VARCHAR(50) | 用户名，唯一 |
| email | VARCHAR(100) | 邮箱，唯一 |
| password | VARCHAR(255) | 加密后的密码 |
| nickname | VARCHAR(50) | 昵称 |
| avatar | VARCHAR(255) | 头像URL |
| status | TINYINT | 状态（0：禁用，1：启用） |
| lastLoginAt | DATETIME | 最后登录时间 |
| createdAt | DATETIME | 创建时间 |
| updatedAt | DATETIME | 更新时间 |

### 2.2 用户角色关联表（user_roles）

| 字段名 | 类型 | 描述 |
|-------|------|------|
| userId | INT | 用户ID，外键 |
| roleId | INT | 角色ID，外键 |

## 3. 实现步骤

### 3.1 创建用户DTO

#### 3.1.1 创建用户DTO

```typescript
// src/users/dto/create-user.dto.ts
// 创建用户数据传输对象，用于验证创建用户请求
import { IsNotEmpty, IsString, IsEmail, MinLength, MaxLength, IsOptional } from 'class-validator';

export class CreateUserDto {
  // 用户名，必填，长度5-50
  @IsNotEmpty({ message: '用户名不能为空' })
  @IsString({ message: '用户名必须是字符串' })
  @MinLength(5, { message: '用户名长度不能少于5个字符' })
  @MaxLength(50, { message: '用户名长度不能超过50个字符' })
  username: string;

  // 邮箱，必填，格式正确
  @IsNotEmpty({ message: '邮箱不能为空' })
  @IsEmail({}, { message: '邮箱格式不正确' })
  @MaxLength(100, { message: '邮箱长度不能超过100个字符' })
  email: string;

  // 密码，必填，长度8-20
  @IsNotEmpty({ message: '密码不能为空' })
  @IsString({ message: '密码必须是字符串' })
  @MinLength(8, { message: '密码长度不能少于8个字符' })
  @MaxLength(20, { message: '密码长度不能超过20个字符' })
  password: string;

  // 昵称，可选，长度1-50
  @IsOptional()
  @IsString({ message: '昵称必须是字符串' })
  @MaxLength(50, { message: '昵称长度不能超过50个字符' })
  nickname?: string;

  // 头像URL，可选
  @IsOptional()
  @IsString({ message: '头像URL必须是字符串' })
  @MaxLength(255, { message: '头像URL长度不能超过255个字符' })
  avatar?: string;

  // 角色ID数组，可选
  @IsOptional()
  roleIds?: number[];
}
```

#### 3.1.2 更新用户DTO

```typescript
// src/users/dto/update-user.dto.ts
// 更新用户数据传输对象，用于验证更新用户请求
import { IsOptional, IsString, IsEmail, MaxLength, IsNumber } from 'class-validator';

export class UpdateUserDto {
  // 用户名，可选，长度5-50
  @IsOptional()
  @IsString({ message: '用户名必须是字符串' })
  @MaxLength(50, { message: '用户名长度不能超过50个字符' })
  username?: string;

  // 邮箱，可选，格式正确
  @IsOptional()
  @IsEmail({}, { message: '邮箱格式不正确' })
  @MaxLength(100, { message: '邮箱长度不能超过100个字符' })
  email?: string;

  // 昵称，可选，长度1-50
  @IsOptional()
  @IsString({ message: '昵称必须是字符串' })
  @MaxLength(50, { message: '昵称长度不能超过50个字符' })
  nickname?: string;

  // 头像URL，可选
  @IsOptional()
  @IsString({ message: '头像URL必须是字符串' })
  @MaxLength(255, { message: '头像URL长度不能超过255个字符' })
  avatar?: string;

  // 状态，可选，0：禁用，1：启用
  @IsOptional()
  @IsNumber({}, { message: '状态必须是数字' })
  status?: number;

  // 角色ID数组，可选
  @IsOptional()
  roleIds?: number[];
}
```

#### 3.1.3 重置密码DTO

```typescript
// src/users/dto/reset-password.dto.ts
// 重置密码数据传输对象，用于验证重置密码请求
import { IsNotEmpty, IsString, MinLength, MaxLength } from 'class-validator';

export class ResetPasswordDto {
  // 新密码，必填，长度8-20
  @IsNotEmpty({ message: '新密码不能为空' })
  @IsString({ message: '新密码必须是字符串' })
  @MinLength(8, { message: '新密码长度不能少于8个字符' })
  @MaxLength(20, { message: '新密码长度不能超过20个字符' })
  newPassword: string;

  // 确认密码，必填，必须与新密码一致
  @IsNotEmpty({ message: '确认密码不能为空' })
  @IsString({ message: '确认密码必须是字符串' })
  confirmPassword: string;
}
```

### 3.2 创建用户服务

```typescript
// src/users/users.service.ts
// 用户服务，处理用户相关的业务逻辑
import { Injectable, ConflictException, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../auth/entities/user.entity';
import { Role } from '../roles/entities/role.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UsersService {
  constructor(
    // 注入用户仓库
    @InjectRepository(User)
    private usersRepository: Repository<User>,
    // 注入角色仓库
    @InjectRepository(Role)
    private rolesRepository: Repository<Role>,
  ) {}

  // 获取用户列表，支持分页和筛选
  async findAll(page: number = 1, limit: number = 10, keyword?: string): Promise<{ data: User[]; total: number }> {
    // 构建查询条件
    const query = this.usersRepository.createQueryBuilder('user');
    
    // 添加关键字搜索条件
    if (keyword) {
      query.where('user.username LIKE :keyword OR user.email LIKE :keyword OR user.nickname LIKE :keyword', {
        keyword: `%${keyword}%`,
      });
    }
    
    // 添加分页
    const [data, total] = await query
      .leftJoinAndSelect('user.roles', 'role') // 加载用户角色
      .skip((page - 1) * limit)
      .take(limit)
      .getManyAndCount();
    
    return { data, total };
  }

  // 根据ID获取用户
  async findOne(id: number): Promise<User> {
    const user = await this.usersRepository.findOne({
      where: { id },
      relations: ['roles'], // 加载用户角色
    });

    if (!user) {
      throw new NotFoundException('用户不存在');
    }

    return user;
  }

  // 根据用户名获取用户
  async findByUsername(username: string): Promise<User | null> {
    return this.usersRepository.findOne({
      where: { username },
      relations: ['roles'],
    });
  }

  // 创建用户
  async create(createUserDto: CreateUserDto): Promise<User> {
    // 检查用户名或邮箱是否已存在
    const existingUser = await this.usersRepository.findOne({
      where: [{ username: createUserDto.username }, { email: createUserDto.email }],
    });

    if (existingUser) {
      throw new ConflictException('用户名或邮箱已存在');
    }

    // 加密密码
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);

    // 创建新用户
    const user = this.usersRepository.create({
      ...createUserDto,
      password: hashedPassword,
    });

    // 如果提供了角色ID，关联角色
    if (createUserDto.roleIds && createUserDto.roleIds.length > 0) {
      const roles = await this.rolesRepository.findByIds(createUserDto.roleIds);
      user.roles = roles;
    }

    // 保存用户到数据库
    return this.usersRepository.save(user);
  }

  // 更新用户
  async update(id: number, updateUserDto: UpdateUserDto): Promise<User> {
    // 检查用户是否存在
    const user = await this.findOne(id);

    // 检查用户名或邮箱是否已被其他用户使用
    if (updateUserDto.username || updateUserDto.email) {
      const existingUser = await this.usersRepository.findOne({
        where: [
          { username: updateUserDto.username, id: NOT id },
          { email: updateUserDto.email, id: NOT id },
        ],
      });

      if (existingUser) {
        throw new ConflictException('用户名或邮箱已存在');
      }
    }

    // 更新用户基本信息
    const { roleIds, ...userData } = updateUserDto;
    Object.assign(user, userData);

    // 如果提供了角色ID，更新用户角色关联
    if (roleIds !== undefined) {
      if (roleIds.length === 0) {
        // 清空用户角色
        user.roles = [];
      } else {
        // 关联新的角色
        const roles = await this.rolesRepository.findByIds(roleIds);
        user.roles = roles;
      }
    }

    // 保存更新后的用户到数据库
    return this.usersRepository.save(user);
  }

  // 删除用户
  async remove(id: number): Promise<void> {
    // 检查用户是否存在
    const user = await this.findOne(id);

    // 删除用户
    await this.usersRepository.remove(user);
  }

  // 更新用户状态
  async updateStatus(id: number, status: number): Promise<User> {
    // 检查用户是否存在
    const user = await this.findOne(id);

    // 更新状态
    user.status = status;

    // 保存更新后的用户到数据库
    return this.usersRepository.save(user);
  }

  // 重置用户密码
  async resetPassword(id: number, resetPasswordDto: ResetPasswordDto): Promise<User> {
    // 检查密码是否一致
    if (resetPasswordDto.newPassword !== resetPasswordDto.confirmPassword) {
      throw new BadRequestException('两次输入的密码不一致');
    }

    // 检查用户是否存在
    const user = await this.findOne(id);

    // 加密新密码
    const hashedPassword = await bcrypt.hash(resetPasswordDto.newPassword, 10);

    // 更新密码
    user.password = hashedPassword;

    // 保存更新后的用户到数据库
    return this.usersRepository.save(user);
  }

  // 为用户分配角色
  async assignRoles(userId: number, roleIds: number[]): Promise<User> {
    // 检查用户是否存在
    const user = await this.findOne(userId);

    // 获取角色列表
    const roles = await this.rolesRepository.findByIds(roleIds);

    // 关联角色到用户
    user.roles = roles;

    // 保存更新后的用户到数据库
    return this.usersRepository.save(user);
  }

  // 更新用户最后登录时间
  async updateLastLoginAt(id: number): Promise<void> {
    await this.usersRepository.update(id, { lastLoginAt: new Date() });
  }
}
```

### 3.3 创建用户控制器

```typescript
// src/users/users.controller.ts
// 用户控制器，处理用户相关的HTTP请求
import { Controller, Get, Post, Body, Patch, Param, Delete, Query, UseGuards, HttpStatus, HttpCode } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { JwtAuthGuard } from '../auth/auth.guard';
import { RolesGuard } from '../roles/roles.guard';
import { Roles } from '../roles/roles.decorator';

@Controller('users')
@UseGuards(JwtAuthGuard, RolesGuard) // 应用认证守卫和角色守卫
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  // 获取用户列表接口
  @Get()
  @Roles('admin') // 要求admin角色
  findAll(
    @Query('page') page: string,
    @Query('limit') limit: string,
    @Query('keyword') keyword?: string,
  ) {
    return this.usersService.findAll(+page || 1, +limit || 10, keyword);
  }

  // 获取用户详情接口
  @Get(':id')
  @Roles('admin')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }

  // 创建用户接口
  @Post()
  @Roles('admin')
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  // 更新用户接口
  @Patch(':id')
  @Roles('admin')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(+id, updateUserDto);
  }

  // 删除用户接口
  @Delete(':id')
  @Roles('admin')
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id);
  }

  // 更新用户状态接口
  @Patch(':id/status')
  @Roles('admin')
  updateStatus(@Param('id') id: string, @Body('status') status: number) {
    return this.usersService.updateStatus(+id, status);
  }

  // 重置用户密码接口
  @Post(':id/reset-password')
  @Roles('admin')
  resetPassword(@Param('id') id: string, @Body() resetPasswordDto: ResetPasswordDto) {
    return this.usersService.resetPassword(+id, resetPasswordDto);
  }

  // 为用户分配角色接口
  @Post(':id/roles')
  @Roles('admin')
  assignRoles(@Param('id') id: string, @Body('roleIds') roleIds: number[]) {
    return this.usersService.assignRoles(+id, roleIds);
  }
}
```

### 3.4 配置用户模块

```typescript
// src/users/users.module.ts
// 用户模块，整合用户相关的控制器、服务等
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { User } from '../auth/entities/user.entity';
import { Role } from '../roles/entities/role.entity';
import { RolesModule } from '../roles/roles.module';

@Module({
  // 导入TypeOrm模块，注册User和Role实体
  imports: [
    TypeOrmModule.forFeature([User, Role]),
    RolesModule,
  ],
  // 注册控制器
  controllers: [UsersController],
  // 注册服务
  providers: [UsersService],
  // 导出服务，供其他模块使用
  exports: [UsersService],
})
export class UsersModule {}
```

### 3.5 更新认证服务，集成用户服务

```typescript
// src/auth/auth.service.ts
// 认证服务，处理用户认证相关的业务逻辑
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { UsersService } from '../users/users.service';
import { LoginDto } from './dto/login.dto';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  // 用户登录
  async login(loginDto: LoginDto): Promise<{ accessToken: string; refreshToken: string }> {
    // 查找用户
    const user = await this.usersService.findByUsername(loginDto.username);

    if (!user) {
      throw new UnauthorizedException('用户名或密码错误');
    }

    // 验证密码
    const isPasswordValid = await bcrypt.compare(loginDto.password, user.password);

    if (!isPasswordValid) {
      throw new UnauthorizedException('用户名或密码错误');
    }

    // 检查用户状态
    if (user.status === 0) {
      throw new UnauthorizedException('用户已被禁用');
    }

    // 更新用户最后登录时间
    await this.usersService.updateLastLoginAt(user.id);

    // 生成访问令牌
    const payload = { username: user.username, sub: user.id, roles: user.roles.map(role => role.code) };
    const accessToken = this.jwtService.sign(payload, {
      expiresIn: '1h',
    });

    // 生成刷新令牌
    const refreshToken = this.jwtService.sign(payload, {
      expiresIn: '7d',
    });

    return { accessToken, refreshToken };
  }

  // 其他认证方法...
}
```

## 4. API使用示例

### 4.1 获取用户列表

```bash
# 请求
GET /users?page=1&limit=10&keyword=admin

# 响应
{
  "data": [
    {
      "id": 1,
      "username": "admin",
      "email": "admin@example.com",
      "nickname": "管理员",
      "avatar": "https://example.com/avatar.jpg",
      "status": 1,
      "roles": [
        {
          "id": 1,
          "name": "管理员",
          "code": "admin",
          "description": "系统管理员"
        }
      ]
    }
  ],
  "total": 1
}
```

### 4.2 创建用户

```bash
# 请求
POST /users
Content-Type: application/json

{
  "username": "testuser",
  "email": "test@example.com",
  "password": "password123",
  "nickname": "测试用户",
  "roleIds": [2]
}

# 响应
{
  "id": 2,
  "username": "testuser",
  "email": "test@example.com",
  "nickname": "测试用户",
  "status": 1,
  "roles": [
    {
      "id": 2,
      "name": "普通用户",
      "code": "user",
      "description": "普通用户"
    }
  ]
}
```

### 4.3 更新用户

```bash
# 请求
PATCH /users/2
Content-Type: application/json

{
  "nickname": "更新后的测试用户",
  "status": 1
}

# 响应
{
  "id": 2,
  "username": "testuser",
  "email": "test@example.com",
  "nickname": "更新后的测试用户",
  "status": 1,
  "roles": [
    {
      "id": 2,
      "name": "普通用户",
      "code": "user",
      "description": "普通用户"
    }
  ]
}
```

### 4.4 重置用户密码

```bash
# 请求
POST /users/2/reset-password
Content-Type: application/json

{
  "newPassword": "newpassword123",
  "confirmPassword": "newpassword123"
}

# 响应
{
  "id": 2,
  "username": "testuser",
  "email": "test@example.com",
  "nickname": "更新后的测试用户",
  "status": 1,
  "roles": [
    {
      "id": 2,
      "name": "普通用户",
      "code": "user",
      "description": "普通用户"
    }
  ]
}
```

## 5. 最佳实践

### 5.1 安全性

- **密码安全**：使用bcrypt等安全算法加密密码，禁止明文存储
- **输入验证**：对所有用户输入进行验证，防止注入攻击
- **权限控制**：合理使用守卫和装饰器，实现细粒度的权限控制
- **防止暴力破解**：实现登录失败次数限制，防止暴力破解

### 5.2 性能优化

- **分页查询**：对用户列表查询进行分页，减少数据库负载
- **索引优化**：为用户表的常用查询字段（如username、email）添加索引
- **延迟加载**：根据需要加载关联数据，避免不必要的数据库查询

### 5.3 可维护性

- **代码结构**：保持清晰的代码结构，遵循NestJS的最佳实践
- **注释**：为核心代码添加注释，提高代码的可维护性
- **日志**：记录用户操作日志，便于审计和故障排查

### 5.4 用户体验

- **友好的错误信息**：返回清晰、友好的错误信息，便于前端处理
- **合理的响应格式**：返回统一的响应格式，便于前端解析
- **密码策略**：设置合理的密码长度和复杂度要求

## 6. 总结

本章节详细介绍了如何使用NestJS实现用户管理功能，包括：

- 用户列表查询，支持分页和关键字搜索
- 用户创建、更新、删除功能
- 用户状态管理，包括启用和禁用用户
- 用户角色管理，包括为用户分配和更新角色
- 用户密码重置功能
- 与认证服务的集成

通过本章节的学习，你可以掌握NestJS中的用户管理机制，为你的应用提供安全可靠的用户管理功能。在实际项目中，你可以根据需求扩展和定制用户管理功能，如添加用户头像上传、多因素认证等高级特性。

## 7. 扩展阅读

- [NestJS控制器文档](https://docs.nestjs.com/controllers) | [NestJS控制器中文文档](https://nest.nodejs.cn/controllers)
- [NestJS服务文档](https://docs.nestjs.com/providers) | [NestJS服务中文文档](https://nest.nodejs.cn/providers)
- [TypeORM文档](https://typeorm.io/)
- [bcrypt官方文档](https://github.com/kelektiv/node.bcrypt.js)
- [OWASP密码存储最佳实践](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
