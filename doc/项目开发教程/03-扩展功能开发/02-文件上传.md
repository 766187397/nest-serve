# 文件上传

文件上传是Web应用中常见的功能需求，用于处理用户上传的图片、文档、视频等文件。在本章节中，我们将实现完整的文件上传功能，包括单文件上传、多文件上传、文件验证、文件存储和文件管理等功能。

## 1. 安装依赖

首先，我们需要安装NestJS的文件上传模块和相关依赖：

```bash
npm install @nestjs/platform-express multer
npm install -D @types/multer
```

- `@nestjs/platform-express`: NestJS的Express适配器，提供文件上传支持
- `multer`: Express的文件上传中间件，用于处理`multipart/form-data`类型的请求
- `@types/multer`: TypeScript类型定义文件

## 2. 配置文件上传

### 2.1 创建文件上传配置

创建文件上传配置文件，定义文件存储路径、文件大小限制等配置：

```typescript
// src/config/upload.config.ts
import { MulterModuleOptions } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname, join } from 'path';

// 生成唯一文件名
const generateFileName = (req: any, file: Express.Multer.File, callback: Function) => {
  const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
  const fileExtension = extname(file.originalname);
  callback(null, `${file.fieldname}-${uniqueSuffix}${fileExtension}`);
};

// 文件上传配置
export const uploadConfig: MulterModuleOptions = {
  // 使用磁盘存储
  storage: diskStorage({
    // 存储目录
    destination: join(__dirname, '../../uploads'),
    // 文件名生成函数
    filename: generateFileName,
  }),
  // 文件大小限制（10MB）
  limits: {
    fileSize: 10 * 1024 * 1024,
    // 最多文件数量
    files: 10,
  },
  // 文件过滤
  fileFilter: (req: any, file: Express.Multer.File, callback: Function) => {
    // 允许的文件类型
    const allowedMimeTypes = [
      'image/jpeg',
      'image/png',
      'image/gif',
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'text/plain',
    ];
    
    // 检查文件类型
    if (allowedMimeTypes.includes(file.mimetype)) {
      callback(null, true);
    } else {
      callback(new Error('不支持的文件类型'), false);
    }
  },
};
```

### 2.2 注册文件上传模块

在应用模块中注册Multer文件上传模块：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { MulterModule } from '@nestjs/platform-express';
import { uploadConfig } from './config/upload.config';

@Module({
  imports: [
    // 注册文件上传模块
    MulterModule.register(uploadConfig),
    // 其他模块
  ],
})
export class AppModule {}
```

## 3. 创建文件上传服务

创建文件上传服务，处理文件上传、文件删除、文件信息获取等业务逻辑：

```typescript
// src/services/upload.service.ts
import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
import { existsSync, unlinkSync, statSync } from 'fs';
import { join } from 'path';

@Injectable()
export class UploadService {
  // 上传目录
  private readonly uploadPath = join(__dirname, '../../uploads');
  
  /**
   * 保存文件信息到数据库
   * @param file 文件对象
   * @param userId 用户ID
   */
  async saveFileInfo(file: Express.Multer.File, userId: string) {
    try {
      // 这里可以将文件信息保存到数据库
      // 例如：文件名、文件路径、文件大小、文件类型、上传用户ID等
      return {
        filename: file.filename,
        originalName: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
        path: file.path,
        userId,
        createdAt: new Date(),
      };
    } catch (error) {
      throw new HttpException('保存文件信息失败', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
  
  /**
   * 删除文件
   * @param filename 文件名
   */
  async deleteFile(filename: string) {
    try {
      const filePath = join(this.uploadPath, filename);
      
      // 检查文件是否存在
      if (!existsSync(filePath)) {
        throw new HttpException('文件不存在', HttpStatus.NOT_FOUND);
      }
      
      // 删除文件
      unlinkSync(filePath);
      return { message: '文件删除成功' };
    } catch (error) {
      throw new HttpException('删除文件失败', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
  
  /**
   * 获取文件信息
   * @param filename 文件名
   */
  async getFileInfo(filename: string) {
    try {
      const filePath = join(this.uploadPath, filename);
      
      // 检查文件是否存在
      if (!existsSync(filePath)) {
        throw new HttpException('文件不存在', HttpStatus.NOT_FOUND);
      }
      
      // 获取文件状态
      const stats = statSync(filePath);
      
      return {
        filename,
        path: filePath,
        size: stats.size,
        createdAt: stats.birthtime,
        modifiedAt: stats.mtime,
      };
    } catch (error) {
      throw new HttpException('获取文件信息失败', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
  
  /**
   * 批量删除文件
   * @param filenames 文件名数组
   */
  async deleteFiles(filenames: string[]) {
    try {
      const results = [];
      
      for (const filename of filenames) {
        try {
          await this.deleteFile(filename);
          results.push({ filename, success: true });
        } catch (error) {
          results.push({ filename, success: false, error: error.message });
        }
      }
      
      return results;
    } catch (error) {
      throw new HttpException('批量删除文件失败', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
}
```

## 4. 创建文件上传控制器

创建文件上传控制器，处理文件上传的HTTP请求：

```typescript
// src/controllers/upload.controller.ts
import { Controller, Post, UseInterceptors, UploadedFile, UploadedFiles, Get, Param, Delete, Query, UseGuards } from '@nestjs/common';
import { FileInterceptor, FilesInterceptor } from '@nestjs/platform-express';
import { UploadService } from '../services/upload.service';
import { AuthGuard } from '../guards/auth.guard';
import { ApiTags, ApiOperation, ApiConsumes, ApiBody, ApiParam, ApiQuery, ApiResponse } from '@nestjs/swagger';

@ApiTags('文件上传')
@UseGuards(AuthGuard)
@Controller('upload')
export class UploadController {
  constructor(private readonly uploadService: UploadService) {}
  
  /**
   * 单文件上传
   * @param file 上传的文件
   */
  @Post('single')
  @ApiOperation({ summary: '单文件上传' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  @ApiResponse({ status: 201, description: '文件上传成功' })
  @UseInterceptors(FileInterceptor('file'))
  async uploadSingleFile(@UploadedFile() file: Express.Multer.File) {
    // 这里可以获取当前用户ID，例如从请求头或JWT中获取
    const userId = 'current-user-id';
    return await this.uploadService.saveFileInfo(file, userId);
  }
  
  /**
   * 多文件上传
   * @param files 上传的文件数组
   */
  @Post('multiple')
  @ApiOperation({ summary: '多文件上传' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        files: {
          type: 'array',
          items: {
            type: 'string',
            format: 'binary',
          },
        },
      },
    },
  })
  @ApiResponse({ status: 201, description: '文件上传成功' })
  @UseInterceptors(FilesInterceptor('files', 10)) // 最多上传10个文件
  async uploadMultipleFiles(@UploadedFiles() files: Express.Multer.File[]) {
    const userId = 'current-user-id';
    const results = [];
    
    for (const file of files) {
      const result = await this.uploadService.saveFileInfo(file, userId);
      results.push(result);
    }
    
    return results;
  }
  
  /**
   * 获取文件信息
   * @param filename 文件名
   */
  @Get(':filename')
  @ApiOperation({ summary: '获取文件信息' })
  @ApiParam({ name: 'filename', description: '文件名' })
  @ApiResponse({ status: 200, description: '获取文件信息成功' })
  async getFile(@Param('filename') filename: string) {
    return await this.uploadService.getFileInfo(filename);
  }
  
  /**
   * 删除文件
   * @param filename 文件名
   */
  @Delete(':filename')
  @ApiOperation({ summary: '删除文件' })
  @ApiParam({ name: 'filename', description: '文件名' })
  @ApiResponse({ status: 200, description: '文件删除成功' })
  async deleteFile(@Param('filename') filename: string) {
    return await this.uploadService.deleteFile(filename);
  }
  
  /**
   * 批量删除文件
   * @param filenames 文件名列表，用逗号分隔
   */
  @Delete()
  @ApiOperation({ summary: '批量删除文件' })
  @ApiQuery({ name: 'filenames', description: '文件名列表，用逗号分隔', example: 'file1.jpg,file2.png' })
  @ApiResponse({ status: 200, description: '批量删除文件成功' })
  async deleteFiles(@Query('filenames') filenames: string) {
    const filenameList = filenames.split(',');
    return await this.uploadService.deleteFiles(filenameList);
  }
}
```

## 5. 创建文件上传模块

将文件上传服务和控制器组织到一个模块中：

```typescript
// src/modules/upload/upload.module.ts
import { Module } from '@nestjs/common';
import { UploadController } from '../../controllers/upload.controller';
import { UploadService } from '../../services/upload.service';

@Module({
  controllers: [UploadController],
  providers: [UploadService],
  exports: [UploadService],
})
export class UploadModule {}
```

然后在主模块中导入UploadModule：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { UploadModule } from './modules/upload/upload.module';

@Module({
  imports: [
    // 其他模块
    UploadModule,
  ],
})
export class AppModule {}
```

## 6. 实现文件验证

为了确保上传的文件符合要求，我们可以创建自定义的文件验证管道：

```typescript
// src/pipes/file-validation.pipe.ts
import { PipeTransform, Injectable, ArgumentMetadata, HttpException, HttpStatus } from '@nestjs/common';

@Injectable()
export class FileValidationPipe implements PipeTransform {
  constructor(
    private readonly maxSize?: number,
    private readonly allowedMimeTypes?: string[],
  ) {
    // 设置默认值
    this.maxSize = maxSize || 10 * 1024 * 1024; // 默认10MB
    this.allowedMimeTypes = allowedMimeTypes || [
      'image/jpeg',
      'image/png',
      'image/gif',
    ];
  }
  
  transform(file: Express.Multer.File, metadata: ArgumentMetadata) {
    // 检查文件是否存在
    if (!file) {
      throw new HttpException('请选择要上传的文件', HttpStatus.BAD_REQUEST);
    }
    
    // 检查文件大小
    if (file.size > this.maxSize) {
      throw new HttpException(
        `文件大小不能超过${this.maxSize / (1024 * 1024)}MB`,
        HttpStatus.BAD_REQUEST,
      );
    }
    
    // 检查文件类型
    if (!this.allowedMimeTypes.includes(file.mimetype)) {
      throw new HttpException(
        `不支持的文件类型，允许的类型：${this.allowedMimeTypes.join(', ')}`,
        HttpStatus.BAD_REQUEST,
      );
    }
    
    return file;
  }
}
```

在控制器中使用自定义验证管道：

```typescript
// src/controllers/upload.controller.ts
import { FileValidationPipe } from '../pipes/file-validation.pipe';

@Controller('upload')
export class UploadController {
  // ...
  
  @Post('image')
  @ApiOperation({ summary: '图片上传' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        image: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  @UseInterceptors(FileInterceptor('image'))
  async uploadImage(
    @UploadedFile(new FileValidationPipe(5 * 1024 * 1024, ['image/jpeg', 'image/png', 'image/gif'])) 
    file: Express.Multer.File,
  ) {
    const userId = 'current-user-id';
    return await this.uploadService.saveFileInfo(file, userId);
  }
  
  // ...
}
```

## 7. 实现文件存储策略

除了使用本地磁盘存储外，我们还可以实现其他存储策略，如AWS S3、阿里云OSS、腾讯云COS等云存储服务。

### 7.1 安装云存储依赖

以AWS S3为例，安装相关依赖：

```bash
npm install aws-sdk multer-s3
npm install -D @types/multer-s3
```

### 7.2 创建S3存储配置

```typescript
// src/config/s3.config.ts
import { S3Client } from '@aws-sdk/client-s3';

export const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
  },
});
```

### 7.3 创建S3存储策略

```typescript
// src/config/upload-s3.config.ts
import { MulterModuleOptions } from '@nestjs/platform-express';
import multerS3 from 'multer-s3';
import { s3Client } from './s3.config';

// S3文件上传配置
export const uploadS3Config: MulterModuleOptions = {
  storage: multerS3({
    s3: s3Client,
    bucket: process.env.AWS_S3_BUCKET || 'your-bucket-name',
    acl: 'public-read', // 文件访问权限
    key: (req, file, callback) => {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
      callback(null, `${file.fieldname}-${uniqueSuffix}-${file.originalname}`);
    },
  }),
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
};
```

### 7.4 动态选择存储策略

根据环境变量动态选择存储策略：

```typescript
// src/config/upload.config.ts
import { MulterModuleOptions } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname, join } from 'path';
import { uploadS3Config } from './upload-s3.config';

// 根据环境变量选择存储策略
const storageStrategy = process.env.STORAGE_STRATEGY || 'local';

// 本地存储配置
const localStorageConfig: MulterModuleOptions = {
  storage: diskStorage({
    destination: join(__dirname, '../../uploads'),
    filename: (req, file, callback) => {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
      callback(null, `${file.fieldname}-${uniqueSuffix}${extname(file.originalname)}`);
    },
  }),
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
};

// 导出配置
export const uploadConfig = storageStrategy === 's3' ? uploadS3Config : localStorageConfig;
```

## 8. 实现文件访问控制

为了保护上传的文件，我们可以实现文件访问控制，只有授权用户才能访问：

```typescript
// src/controllers/file.controller.ts
import { Controller, Get, Param, Res, UseGuards } from '@nestjs/common';
import { Response } from 'express';
import { existsSync, createReadStream } from 'fs';
import { join } from 'path';
import { AuthGuard } from '../guards/auth.guard';

@UseGuards(AuthGuard)
@Controller('files')
export class FileController {
  private readonly uploadPath = join(__dirname, '../../uploads');
  
  @Get(':filename')
  async getFile(@Param('filename') filename: string, @Res() res: Response) {
    const filePath = join(this.uploadPath, filename);
    
    // 检查文件是否存在
    if (!existsSync(filePath)) {
      return res.status(404).send('文件不存在');
    }
    
    // 创建文件流并发送
    const fileStream = createReadStream(filePath);
    fileStream.pipe(res);
  }
}
```

## 9. 文件上传测试

使用Jest和Supertest测试文件上传功能：

```typescript
// test/upload/upload.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../../src/app.module';
import * as path from 'path';

describe('UploadController', () => {
  let app: INestApplication;
  
  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    
    app = moduleFixture.createNestApplication();
    await app.init();
  });
  
  afterAll(async () => {
    await app.close();
  });
  
  // 测试单文件上传
  it('should upload single file', async () => {
    const response = await request(app.getHttpServer())
      .post('/upload/single')
      .attach('file', path.join(__dirname, 'test-file.txt'))
      .set('Authorization', 'Bearer test-token')
      .expect(201);
    
    expect(response.body).toHaveProperty('filename');
    expect(response.body).toHaveProperty('originalName', 'test-file.txt');
  });
  
  // 测试多文件上传
  it('should upload multiple files', async () => {
    const response = await request(app.getHttpServer())
      .post('/upload/multiple')
      .attach('files', path.join(__dirname, 'test-file1.txt'))
      .attach('files', path.join(__dirname, 'test-file2.txt'))
      .set('Authorization', 'Bearer test-token')
      .expect(201);
    
    expect(Array.isArray(response.body)).toBe(true);
    expect(response.body.length).toBe(2);
  });
  
  // 测试文件信息获取
  it('should get file info', async () => {
    // 先上传一个文件
    const uploadResponse = await request(app.getHttpServer())
      .post('/upload/single')
      .attach('file', path.join(__dirname, 'test-file.txt'))
      .set('Authorization', 'Bearer test-token')
      .expect(201);
    
    const filename = uploadResponse.body.filename;
    
    // 获取文件信息
    const infoResponse = await request(app.getHttpServer())
      .get(`/upload/${filename}`)
      .set('Authorization', 'Bearer test-token')
      .expect(200);
    
    expect(infoResponse.body).toHaveProperty('filename', filename);
  });
});
```

## 10. 文件上传最佳实践

1. **文件验证**：对上传的文件进行严格的验证，包括文件类型、文件大小、文件内容等
2. **文件命名**：使用唯一的文件名，避免文件覆盖和安全问题
3. **文件存储**：根据业务需求选择合适的存储策略，如本地存储、云存储等
4. **文件访问控制**：对敏感文件实施访问控制，只有授权用户才能访问
5. **文件压缩**：对图片等大文件进行压缩处理，减少存储空间和网络传输时间
6. **文件备份**：定期备份重要文件，防止数据丢失
7. **文件清理**：定期清理过期或不再使用的文件，释放存储空间
8. **日志记录**：记录文件上传、下载、删除等操作日志，便于审计和调试
9. **错误处理**：实现完善的错误处理机制，向用户返回清晰的错误信息
10. **性能优化**：使用异步上传、分片上传等技术，提高大文件上传的性能和可靠性

## 11. 总结

本章节我们实现了完整的文件上传功能，包括：

1. 文件上传配置和依赖安装
2. 单文件上传和多文件上传
3. 文件验证和自定义验证管道
4. 本地存储和云存储（AWS S3）策略
5. 文件访问控制和权限管理
6. 文件上传测试
7. 文件上传最佳实践

文件上传是Web应用中常见的功能需求，通过本章节的学习，我们掌握了NestJS中文件上传的完整实现方案，可以根据实际业务需求进行扩展和优化。